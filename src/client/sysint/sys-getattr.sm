/* 
 * (C) 2003 Clemson University, The University of Chicago, and Omnibond Systems, LLC
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for obtaining attributes of an object
 *  (file or directory).
 */
#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-util.h"
#include "pvfs2-util.h"
#include "pint-cached-config.h"
#include "PINT-reqproto-encode.h"
#include "pvfs2-internal.h"
#include "pvfs2-types-debug.h"
#include "security-util.h"
#include "sid.h"
#include "dist-dir-utils.h"
#include "client-capcache.h"

/* pvfs2_client_getattr_sm
 *
 * The sm_p->msgpair structure is used to get the attributes of the
 * object itself.  We convert the original attribute mask (in
 * sm_p->u.getattr.attrmask) to ask for datafile and distribution info
 * if the user asked for file size (PVFS_ATTR_SYS_SIZE).  This allows
 * us to obtain this information (if the object turns out to be a
 * metafile) so that we can later look up the datafile sizes and
 * calculate the overall file size.
 *
 * The sm_p->msgpairarray is used to get datafile sizes, if it turns
 * out that we need them.  This space will also need to be freed, if
 * we grab these sizes.
 */

enum
{
    GETATTR_CACHE_MISS = 1,
    GETATTR_NEED_DATAFILE_ATTRS = 2,
    GETATTR_IO_RETRY = 3,
    GETATTR_NEED_DIRDATA_ATTRS = 4
};

/* completion function prototypes */
static int getattr_object_getattr_comp_fn(void *v_p,
                                          struct PVFS_server_resp *resp_p,
                                          int index);
static int getattr_datafile_getattr_comp_fn(void *v_p,
                                            struct PVFS_server_resp *resp_p,
                                            int index);
static int getattr_dirdata_getattr_comp_fn(void *v_p,
                                           struct PVFS_server_resp *resp_p,
                                           int index);

%%

nested machine pvfs2_client_datafile_getattr_sm
{
    state datafile_getattr_setup_msgpairarray
    {
        run getattr_datafile_getattr_setup_msgpairarray;
        success => datafile_getattr_xfer_msgpairarray;
        default => datafile_getattr_cleanup;
    }

    state datafile_getattr_xfer_msgpairarray
    {
        jump pvfs2_msgpairarray_sm;
        /* default => datafile_getattr_retry; */
        default => datafile_getattr_cleanup;
    }

/*
    state datafile_getattr_retry
    {
        run getattr_datafile_getattr_retry;
        GETATTR_IO_RETRY => datafile_getattr_xfer_msgpairarray;
        default => datafile_getattr_cleanup;
    }
*/

    state datafile_getattr_cleanup
    {
        run getattr_datafile_getattr_cleanup;
        default => return;
    }
}

nested machine pvfs2_client_dirdata_getattr_sm
{
    state dirdata_getattr_setup_msgpairarray
    {
        run getattr_dirdata_getattr_setup_msgpairarray;
        success => dirdata_getattr_xfer_msgpairarray;
        default => dirdata_getattr_cleanup;
    }

    state dirdata_getattr_xfer_msgpairarray
    {
        jump pvfs2_msgpairarray_sm;
        default => dirdata_getattr_cleanup;
    }

    state dirdata_getattr_cleanup
    {
        run getattr_dirdata_getattr_cleanup;
        default => return;
    }
}

nested machine pvfs2_client_getattr_sm
{
    state acache_lookup
    {
        run getattr_acache_lookup;
        GETATTR_CACHE_MISS => object_getattr_setup_msgpair;
        default => client_capcache_lookup;
    }

    state client_capcache_lookup
    {
        run getattr_client_capcache_lookup;
        GETATTR_CACHE_MISS => object_getattr_setup_msgpair;
        default => cleanup;
    }

    state object_getattr_setup_msgpair
    {
        run getattr_object_getattr_setup_msgpair;
        success => object_getattr_xfer_msgpair;
        default => cleanup;
    }

    state object_getattr_xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        success => acache_insert;
        GETATTR_NEED_DATAFILE_ATTRS => datafile_get_attrs;
        GETATTR_NEED_DIRDATA_ATTRS => dirdata_get_attrs;
        default => object_getattr_failure;
    }

    state acache_insert
    {
        run getattr_acache_insert;
        default => client_capcache_insert;
    }

    state client_capcache_insert
    {
        run getattr_client_capcache_insert;
        default => cleanup;
    }

    state object_getattr_failure
    {
        run getattr_object_getattr_failure;
        default => cleanup;
    }

    state datafile_get_attrs
    {
        jump pvfs2_client_datafile_getattr_sm;
        success => attr_mask_include_size;
        default => cleanup;
    }

    state attr_mask_include_size
    {
        run attr_mask_include_size;
        default => acache_insert;
    }

    state dirdata_get_attrs
    {
        jump pvfs2_client_dirdata_getattr_sm;
        success => acache_insert;
        default => cleanup;
    }

    state cleanup
    {
        run getattr_cleanup;
        default => return;
    }
}

machine pvfs2_client_sysint_getattr_sm
{
    state dowork
    {
        jump pvfs2_client_getattr_sm;
        default => set_sys_response; 
    }

    state set_sys_response
    {
        run getattr_set_sys_response;
        default => terminate;
    }
}

%%

/** Initiate retrieval of object attributes.
 */
PVFS_error PVFS_isys_getattr(PVFS_object_ref ref,
                             uint32_t attrmask, 
                             const PVFS_credential *credential,
                             PVFS_sysresp_getattr *resp_p,
                             PVFS_sys_op_id *op_id,
                             PVFS_hint hints,
                             void *user_ptr)
{
    PVFS_error ret = -PVFS_EINVAL;
    PINT_smcb *smcb = NULL;
    PINT_client_sm *sm_p = NULL;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "PVFS_isys_getattr entered\n");

    if ((!PVFS_OID_cmp(&ref.handle, &PVFS_HANDLE_NULL)) ||
        (ref.fs_id == PVFS_FS_ID_NULL) || (resp_p == NULL))
    {
        gossip_err("invalid (NULL) required argument\n");
        return ret;
    }
    
    /* attrmask can have PVFS_ATTR_CAPABILITY, PVFS_ATTR_ALL,
     * PVFS_ATTR_FASTER or PVFS_ATTR_LATEST
     */
    if (attrmask & ~(PVFS_ATTR_SYS_ALL_VALID))
    {
        gossip_err("invalid attrmask\n");
        return ret;
    }

    PINT_smcb_alloc(&smcb,
                    PVFS_SYS_GETATTR, 
                    sizeof(struct PINT_client_sm),
                    client_op_state_get_machine,
                    client_state_machine_terminate,
                    pint_client_sm_context);
    if (smcb == NULL)
    {
        return -PVFS_ENOMEM;
    }
    sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    PINT_init_msgarray_params(sm_p, ref.fs_id);
    PINT_init_sysint_credential(sm_p->cred_p, credential);

    sm_p->error_code = 0;
    sm_p->object_ref = ref;
    sm_p->u.getattr.getattr_resp_p = resp_p;

    PVFS_hint_copy(hints, &sm_p->hints);
    PVFS_hint_add(&sm_p->hints,
                  PVFS_HINT_HANDLE_NAME,
                  sizeof(PVFS_handle),
                  &ref.handle);

    PINT_SM_GETATTR_STATE_FILL(sm_p->getattr,
                               ref,
                               PVFS_util_sys_to_object_attr_mask(attrmask),
                               PVFS_TYPE_NONE,
                               0);

    return PINT_client_state_machine_post(smcb, op_id, user_ptr);
}

/** Retrieve object attributes.
 */
PVFS_error PVFS_sys_getattr(PVFS_object_ref ref,
                            uint32_t attrmask, 
                            const PVFS_credential *credential,
                            PVFS_sysresp_getattr *resp_p,
                            PVFS_hint hints)
{
    PVFS_error ret, error = 0;
    PVFS_sys_op_id op_id;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "PVFS_sys_getattr entered\n");

    ret = PVFS_isys_getattr(ref,
                            attrmask,
                            credential,
                            resp_p,
                            &op_id,
                            hints,
                            NULL);
    if (ret)
    {
        PVFS_perror_gossip("PVFS_isys_getattr call", ret);
        error = ret;
    }
    else if (!ret && op_id != -1)
    {
        ret = PVFS_sys_wait(op_id, "getattr", &error);
        if (ret)
        {
            PVFS_perror_gossip("PVFS_sys_wait call", ret);
            error = ret;
        }
        PINT_sys_release(op_id);
    }
    return error;
}

/* <======================= COMPLETION FUNCTIONS ====================> */

/*
 * copies data from getattr response into the user supplied sys_attr
 * structure.  returns 0 for directories and symlinks, and
 * GETATTR_NEED_DATAFILE_ATTRS for a metafile (when appropriate)
 */
static int getattr_object_getattr_comp_fn(void *v_p,
                                          struct PVFS_server_resp *resp_p,
                                          int index)
{
    PVFS_object_attr *attr = NULL;
    PINT_smcb *smcb = v_p;
    PINT_smcb *parent_smcb = smcb->parent_smcb;
    PINT_client_sm *sm_p = PINT_sm_frame(parent_smcb, PINT_MSGPAIR_PARENT_SM);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    assert(resp_p->op == PVFS_SERV_GETATTR);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "getattr_object_getattr_comp_fn called\n");

    if (resp_p->status != 0)
    {
        return resp_p->status;
    }

    /*
     * If we've reached the callback for the getattr msgpair tranfer,
     * then we can make a copy of the retrieved attribute for later
     * caching.
     */
    PINT_copy_object_attr(&sm_p->getattr.attr,
                          &resp_p->u.getattr.attr);

    attr = &sm_p->getattr.attr;  /* returned atributes */

    /* if the ref_type mask is set to a non-zero value (!PVFS_TYPE_NONE)
     * a -PVFS_error will be triggered if the
     * attributes received are not one of the the types specified.
     * This is useful so that the client can know (in some cases) that it
     * can avoid issuing an operation to the server since the server will 
     * just pass an error back anyway.
     */
    if(sm_p->getattr.ref_type &&
       sm_p->getattr.ref_type != attr->objtype)
    {
        int ret;
        gossip_debug(GOSSIP_GETATTR_DEBUG, "*** "
                     "object_getattr_comp_fn: Object type mismatch.\n Possibly "
                     "saving network roundtrip by returning an error\n");

        if (sm_p->getattr.ref_type == PVFS_TYPE_DIRECTORY)
        {
            ret = -PVFS_ENOTDIR;
        }
        else
        {
            assert(sm_p->getattr.ref_type == PVFS_TYPE_METAFILE);
            ret = ((attr->objtype == PVFS_TYPE_DIRECTORY) ?
                   -PVFS_EISDIR : -PVFS_EBADF);
        }
        PVFS_perror_gossip("Object Type mismatch error", ret);
        return ret;
    }

    /* do assertion checking of getattr response values, and
     * check if file sizes are needed.  With NDEBUG defined, this block
     * only checks if file sizes are needed.
     */
    switch (attr->objtype)
    {
        case PVFS_TYPE_METAFILE:
            gossip_debug(GOSSIP_GETATTR_DEBUG, "METAFILE\n");
            if (sm_p->msgarray_op.msgpair.req.u.getattr.attrmask &
                PVFS_ATTR_META_DIST)
            {
                /* if we requested distribution attrs, did the distribution 
                 * get set and is the size valid?
                 */
                assert(attr->mask & PVFS_ATTR_META_DIST);
                assert(attr->u.meta.dist && (attr->u.meta.dist_size > 0));
            }
/* V3 remove */
#if 0
            if (sm_p->msgarray_op.msgpair.req.u.getattr.attrmask &
                PVFS_ATTR_META_MIRROR_DFILES)
            {
                if (attr->mask & PVFS_ATTR_META_MIRROR_DFILES)
                {    assert(attr->u.meta.mirror_dfile_array &&
                          (attr->u.meta.mirror_copies_count > 0));
                     gossip_debug(GOSSIP_GETATTR_DEBUG,"%s: Mirror handles and "
                                                       "copy count retrieved.\n"
                                                     ,__func__);
                }
                else
                {
                   gossip_debug(GOSSIP_GETATTR_DEBUG,"%s: request attribute "
                   "mask says to get the mirror dfiles, if they exist, \nbut "
                   "the response attribute mask says they were not retrieved. "
                   "This is okay.\n"
                   ,__func__);
                }
            }
#endif
            if (attr->mask & PVFS_ATTR_META_DFILES)
            {
                /* if we requested the datafile handles for the file, did
                 * the datafile array get populated?
                 */
                assert(attr->u.meta.dfile_array &&
                       (attr->u.meta.dfile_count > 0));

                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             "getattr_object_getattr_comp_fn: "
                             "%d datafiles.\n", attr->u.meta.dfile_count);
                
                /* if we need the size, that should be the only time we're 
                 * going to have to do a full data file fetch. 
                 * (that's expensive)
                 */
                if (attr->mask & PVFS_ATTR_DATA_SIZE)
                {

/* stuffed going away - may want some code here later */
#if 0
                    /* is the file stuffed? */
                    if(!(attr->mask & PVFS_ATTR_META_UNSTUFFED))
                    {
                        /* we can compute the size without doing any more
                         * getattr requests
                         */
                        gossip_debug(GOSSIP_GETATTR_DEBUG,
                            "getattr_object_getattr_comp_fn: "
                            "detected stuffed file.\n");
                        return(0);
                    }
#endif
                    /* if caller asked for the latest size and time
                     * stamps, then we need
                     * to jump to the datafile_getattr state, which
                     * will retrieve the datafile sizes for us.
                     */
                    if (sm_p->getattr.req_attrmask & PVFS_ATTR_LATEST)
                    {
                        return GETATTR_NEED_DATAFILE_ATTRS;
                    }
                }
            }
            return 0;
        case PVFS_TYPE_DIRECTORY:
        {
            uint32_t dirent_file_count_i;
            uint32_t dirent_sid_count_i;
            int tmp_i;
            unsigned char *c;

            gossip_debug(GOSSIP_GETATTR_DEBUG, "DIRECTORY\n");

            if (gossip_debug_enabled(GOSSIP_GETATTR_DEBUG))
            {
                /* dirent_count will be collected later */
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                    "getattr comp_fn [%p] "
                    "dfile_count(hint) = %d "
                    "dfile_sid_count(hint) = %d "
                    "dist_name_len(hint) = %d "
                    "dist_params_len(hint) = %d\n",
                    attr,
                    attr->u.dir.hint.dfile_count,
                    attr->u.dir.hint.dfile_sid_count,
                    attr->u.dir.hint.dist_name_len,
                    attr->u.dir.hint.dist_params_len);

                if(1 /* && attr->mask & PVFS_ATTR_DISTDIR_ATTR */)
                {
                    gossip_debug(GOSSIP_GETATTR_DEBUG,
                           "sys-getattr: dist-dir-attr "
                           "with tree_height=%d, dirdata_count=%d, "
                           "sid_count=%d, bitmap_size=%d, "
                           "split_size=%d, server_no=%d and branch_level=%d\n",
                           attr->u.dir.dist_dir_attr.tree_height,
                           attr->u.dir.dist_dir_attr.dirdata_count,
                           attr->u.dir.dist_dir_attr.sid_count,
                           attr->u.dir.dist_dir_attr.bitmap_size,
                           attr->u.dir.dist_dir_attr.split_size,
                           attr->u.dir.dist_dir_attr.server_no,
                           attr->u.dir.dist_dir_attr.branch_level);

                    /* gossip bitmap */
                    gossip_debug(GOSSIP_GETATTR_DEBUG,
                            "sys-getattr: dist_dir_bitmap as:\n");

                    for(tmp_i = attr->u.dir.dist_dir_attr.bitmap_size - 1;
                        tmp_i >= 0;
                        tmp_i--)
                    {
                        c = (unsigned char *)(attr->u.dir.dist_dir_bitmap +
                                              tmp_i);
                        gossip_debug(GOSSIP_GETATTR_DEBUG,
                                " i=%d : %02x %02x %02x %02x\n",
                                tmp_i, c[3], c[2], c[1], c[0]);
                    }
                    gossip_debug(GOSSIP_GETATTR_DEBUG, "\n");

                    /* gossip dirdata handles */
                    gossip_debug(GOSSIP_GETATTR_DEBUG,
                            "sys-getattr: dirdata_handles as:\n");
                    for (dirent_file_count_i = 0;
                         dirent_file_count_i < 
                                     attr->u.dir.dist_dir_attr.dirdata_count;
                         dirent_file_count_i++)
                    {
                        gossip_debug(GOSSIP_GETATTR_DEBUG,
                                "    dirdata_handle[%d] = %s\n",
                                dirent_file_count_i,
                                PVFS_OID_str(&attr->u.dir.dirdata_handles[
                                                        dirent_file_count_i]));
                    }
                    /* gossip dirdata sids */
                    gossip_debug(GOSSIP_GETATTR_DEBUG,
                            "sys-getattr: dirdata_sids as:\n");
                    for (dirent_sid_count_i = 0;
                         dirent_sid_count_i < 
                                     attr->u.dir.dist_dir_attr.sid_count;
                         dirent_sid_count_i++)
                    {
                        gossip_debug(GOSSIP_GETATTR_DEBUG,
                                "    dirdata_sid[%d] = %s\n",
                                dirent_sid_count_i,
                                PVFS_SID_str(&attr->u.dir.dirdata_sids[
                                                        dirent_sid_count_i]));
                    }
                }

                /* need to gather dirdata attr */
                if (sm_p->getattr.req_attrmask & PVFS_ATTR_LATEST)
                {
                    assert(attr->mask & PVFS_ATTR_DISTDIR_ATTR);

                    gossip_debug(GOSSIP_GETATTR_DEBUG,
                            "  !!! need to contact dirdata to gather "
                            "dirent_count and timestamps!\n");

                    return GETATTR_NEED_DIRDATA_ATTRS;

                }
            } /* if (gossip_enabled()) */

            return 0;
        }
        case PVFS_TYPE_SYMLINK:
            gossip_debug(GOSSIP_GETATTR_DEBUG, "SYMLINK\n");
            return 0;
        case PVFS_TYPE_DATAFILE:
            gossip_debug(GOSSIP_GETATTR_DEBUG, "DATAFILE\n");
            return 0;
        case PVFS_TYPE_DIRDATA:
            gossip_debug(GOSSIP_GETATTR_DEBUG, "DIRDATA\n");
            return 0;
        case PVFS_TYPE_INTERNAL:
            gossip_debug(GOSSIP_GETATTR_DEBUG, "INTERNAL\n");
            return 0;
        default:
            gossip_err("error: getattr_object_getattr_comp_fn: "
                       "handle refers to invalid object type\n");
    }
    return -PVFS_EINVAL;
}

static int getattr_datafile_getattr_comp_fn(void *v_p,
                                            struct PVFS_server_resp *resp_p,
                                            int index)
{
    PINT_smcb *smcb = v_p;
    PINT_smcb *parent_smcb = smcb->parent_smcb;
    PINT_client_sm *sm_p = PINT_sm_frame(parent_smcb, PINT_MSGPAIR_PARENT_SM);
    PINT_sm_getattr_state *getattr = &(sm_p->getattr);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

/* V3 this functionality moved to MPA */
#if 0
    PINT_sm_msgpair_state *msg = &(sm_p->msgarray_op.msgarray[index]);
    struct PVFS_servreq_tree_get_file_size *tree = 
                                              &(msg->req.u.tree_get_file_size);
    PINT_client_getattr_mirror_ctx *ctx = NULL;
    uint32_t server_nr = 0;
#endif
    int i = 0;

    if (resp_p->status)
    {   /* tree request had a problem */
        return resp_p->status;
    }

    assert(resp_p->op == PVFS_SERV_TREE_GET_FILE_SIZE);

/* V3 this functionality moved to MPA */
#if 0
    /* if we are mirroring, then we need to check the error code returned from
     * each server. If an error is found, mirroring will try to get the size 
     * from a different server.  Below, we are marking which handles completed 
     * successfully, which tells mirroring NOT to retry them.
     */
    if (getattr->attr.mask & PVFS_ATTR_META_MIRROR_DFILES)  
    {
        for (i = 0; i < resp_p->u.tree_get_file_size.handle_count; i++)
        {
            if (resp_p->u.tree_get_file_size.error[i] != 0)
            {
                /* error retrieving size for this handle..we will retry it. */
                continue;
            }
            server_nr = getattr->index_to_server[i];
            sm_p->getattr.size_array[server_nr] =
                                 resp_p->u.tree_get_file_size.size[i];
            ctx = &(getattr->mir_ctx_array[server_nr]);
            ctx->msg_completed = 1; 

            /* For completed messages, update the size array with the file size
             * just retrieved.
             */
            getattr->size_array[server_nr] =
                                 resp_p->u.tree_get_file_size.size[i];
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "%s: size[%d]:%lld \thandle:%s\n"
                         ,__func__
                         ,i
                         ,llu(getattr->size_array[i])
                         ,PVFS_OID_str(&tree->handle_array[i]));
        }/*end for*/
    }
    else
    {
#endif
        /* if we are NOT mirroring and an error is found for an
         * individual handle, then we must invalidate the size array
         * and return an error code.
         */
   gossip_debug(GOSSIP_GETATTR_DEBUG,"%s:handle_count(%u)\n",__func__
                                                            ,resp_p->u.tree_get_file_size.handle_count);

   getattr->size = 0;
   for (i = 0; i < resp_p->u.tree_get_file_size.handle_count; i++)
   {
       gossip_debug(GOSSIP_GETATTR_DEBUG
                    ,"%s: error[%d]:%d\tsize[%d]:%d\n"
                    ,__func__
                    ,i
                    ,(int)resp_p->u.tree_get_file_size.error[i]
                    ,i
                    ,(int)resp_p->u.tree_get_file_size.size[i]);

       if (resp_p->u.tree_get_file_size.error[i] != 0)
       {
           gossip_debug(GOSSIP_GETATTR_DEBUG
                        ,"%s: error[%d] is %d\n"
                        ,__func__
                        ,i
                        ,resp_p->u.tree_get_file_size.error[i]);
           memset(getattr->size_array, 0, sizeof(*getattr->size_array));
           getattr->size = 0;
           return (resp_p->u.tree_get_file_size.error[i]);
       }

       getattr->size_array[i] = resp_p->u.tree_get_file_size.size[i];
       getattr->size += getattr->size_array[i];
   } /* end for */

   getattr->attr.mask |= PVFS_ATTR_DATA_SIZE;

#if 0
    } /* end if */
#endif

    return(0);
} /* end getattr_datafile_getattr_comp_fn */

/* <====================== STATE ACTION FUNCTIONS ===================> */

/**
 * getattr_acache_lookup
 * @ingroup client_sm_getattr
 *
 * This function is invoked as the first state action of the
 * getattr-dowork state machine.  It performs a lookup into the
 * attribute cache for the attribute in question, and returns
 * result codes for a hit or a miss.  
 *
 * @param smcb This must be a valid client state machine handle, with
 * the @ref getattr field containing valid values for the
 * fsid/handle of the desired attribute (in object_ref), as well as the 
 * requested attribute mask (req_attrmask).
 *
 * @param js_p Contains the return code to be set by this function in the
 * @ref error_code field.  This determines the next state action to jump
 * to in the getattr-dowork state machine.
 * Possible values for js_p->error_code are:
 * <ul>
 * <li><b>GETATTR_CACHE_MISS</b> - The requested attribute was
 * not found in the attribute cache, or the attributes were
 * found, but the attribute mask did not include values required
 * by the requested mask (req_attrmask).
 * </li>
 * <li><b>GETATTR_NEED_DATAFILE_ATTRS</b> - The requested attribute was found
 * in the attribute cache and the mask was sufficient, but the data file size
 * was requested for this handle, so we need to get that next.
 * </li>
 *
 * @return This function should always return SM_ACTION_COMPLETE
 * unless an error occurred within the internals of the state
 * machine.
 */
static PINT_sm_action getattr_acache_lookup(struct PINT_smcb *smcb,
                                            job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    uint32_t trimmed_mask = 0;
    int missing_attrs;
    PVFS_object_ref object_ref;
    int ret = -1;
    int attr_status = -1;
    int size_status = -1;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    js_p->error_code = 0;

    object_ref = sm_p->getattr.object_ref;

    assert(PVFS_OID_cmp(&object_ref.handle, &PVFS_HANDLE_NULL));
    assert(object_ref.fs_id != PVFS_FS_ID_NULL);
    assert(object_ref.sid_count > 0);
    assert(object_ref.sid_array != NULL);

    /* Useful for debugging acache access. */
#if 0
    gossip_backtrace();
#endif

    /* This dumps the whole mask */
    DEBUG_attr_mask(sm_p->getattr.req_attrmask);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "%s: handle %s fsid %d\n", __func__,
                 PVFS_OID_str(&object_ref.handle), object_ref.fs_id);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: called on behalf of %s\n",
                 __func__, PINT_client_get_name_str(smcb->op));

    /* The sys attr mask request is converted to object
     * attr mask values for comparison with the cached
     */
    if(sm_p->getattr.req_attrmask & PVFS_ATTR_DATA_SIZE)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG, "Mask has DATA_SIZE\n");
        sm_p->getattr.req_attrmask |= PVFS_ATTR_META_ALL;
        gossip_debug(GOSSIP_GETATTR_DEBUG, "Mask has META_ALL added\n");
    }
    
    /* check for PVFS_ATTR_DISTDIR_ATTR */
    if(sm_p->getattr.req_attrmask & PVFS_ATTR_DISTDIR_ATTR)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG, "Mask has DISTDIR_ATTR\n");
    }
    else
    {
        /* if need dir timestamp or dirent_count, need dist_dir_struct */
        if(sm_p->getattr.req_attrmask &
                (PVFS_ATTR_DIR_DIRENT_COUNT | PVFS_ATTR_COMMON_ATIME |
                 PVFS_ATTR_COMMON_CTIME | PVFS_ATTR_COMMON_MTIME |
                 0 )
          )
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, "Mask has DISTDIR_ATTR added\n");
            sm_p->getattr.req_attrmask |= PVFS_ATTR_DISTDIR_ATTR;
        }
    }

    /* we need dfile/distdir handles if a capability is requested */
    if(sm_p->getattr.req_attrmask & PVFS_ATTR_CAPABILITY)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG, "Mask has CAPABILITY\n");
        sm_p->getattr.req_attrmask |= 
            (PVFS_ATTR_META_DFILES|PVFS_ATTR_DISTDIR_ATTR);
        gossip_debug(GOSSIP_GETATTR_DEBUG, "Mask has META_DFILES added\n");
        gossip_debug(GOSSIP_GETATTR_DEBUG, "Mask has DISTDIR_ATTR added\n");
    }

    /* This dumps the whole mask */
    DEBUG_attr_mask(sm_p->getattr.req_attrmask);

#if 0
     /* TESTING ONLY: Force miss! */
    sm_p->getattr.flags |= PINT_SM_GETATTR_BYPASS_CACHE;
#endif

    if(sm_p->getattr.flags & PINT_SM_GETATTR_BYPASS_CACHE)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "acache: forced acache miss: [%s]\n",
                      PVFS_OID_str(&object_ref.handle));
        js_p->error_code = GETATTR_CACHE_MISS;
        return SM_ACTION_COMPLETE;
    }

    /* V3 - is sm_p->getattr.attr supposed to be empty at this point
     * This call makes sure it is
     */
    PINT_free_object_attr(&sm_p->getattr.attr);
    ret = PINT_acache_get_cached_entry(object_ref,
                                       &sm_p->getattr.attr,
                                       &attr_status,
                                       &sm_p->getattr.size,
                                       &size_status);
    if(ret < 0 || attr_status < 0)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "acache: clean acache miss: [%s]\n",
                      PVFS_OID_str(&object_ref.handle));
  
        js_p->error_code = GETATTR_CACHE_MISS;
        return SM_ACTION_COMPLETE;
    }

    /* Report a miss if capability is expired or within 
     * CAP_TIMEOUT_BUFFER of expiration
     *
     * sampson: TODO: in practice the acache timeout is likely 
     * much less than the capability timeout. Therefore it is
     * unlikely the capability will have expired. Additionally
     * this code may not be needed when more sophisticated caches
     * are added.  We DO care about the capability flag.
     */
    /* V3 note a chunck of code that checked for timed out capabilities
     * was removed here - pretty sure that was right, but this is here
     * as a marker just in case
     */

    /* acache hit, check results */

    /* The sys attr mask request is converted to object
     * attr mask values for comparison with the cached
     * entry
     */
    trimmed_mask = sm_p->getattr.req_attrmask;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: request attrmask:\n", __func__);
    PINT_attrmask_print(GOSSIP_GETATTR_DEBUG, sm_p->getattr.req_attrmask);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: returned attrmask:\n", __func__);
    PINT_attrmask_print(GOSSIP_GETATTR_DEBUG, sm_p->getattr.attr.mask);

    /* the trimmed mask is used for making sure that we're only
     * checking attr bits that make sense for the object type
     * since the caller may have requested all attributes in
     * the case where it doesn't know what type of object we're
     * doing the getattr against.
     */
    if (sm_p->getattr.attr.objtype == PVFS_TYPE_METAFILE)
    {
        trimmed_mask &= (PVFS_ATTR_META_ALL |
                         PVFS_ATTR_DATA_SIZE |
                         PVFS_ATTR_COMMON_ALL);
    }
    else if (sm_p->getattr.attr.objtype == PVFS_TYPE_SYMLINK)
    {
        trimmed_mask &= (PVFS_ATTR_SYMLNK_ALL | PVFS_ATTR_COMMON_ALL);
    }
    else if (sm_p->getattr.attr.objtype == PVFS_TYPE_DIRECTORY)
    {
        trimmed_mask &= (PVFS_ATTR_COMMON_ALL | PVFS_ATTR_DIR_ALL);
    }

    gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: trimmed attrmask:\n", __func__);
    PINT_attrmask_print(GOSSIP_GETATTR_DEBUG, trimmed_mask);

    /* trimmed_mask contains the list of attributes
     * requested for a particular object, 
     * while sm_p->getattr.attr.mask contains
     * the list of attributes cached for that object.
     * The cached attributes can be used if requested
     * is less than cached, i.e. all the attributes
     * we need are already cached.  So we need to do
     * a bitwise comparison of requested <= cached.
     *
     * xor of the two masks gives us the bits that are different,
     * and-ing that result with the requested mask gives us the
     * bits in the requested mask but not in the cached mask.
     */
    missing_attrs = ((trimmed_mask ^ sm_p->getattr.attr.mask) &
                     trimmed_mask);

    if (missing_attrs == 0)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: NO ATTRS MISSING.\n", __func__);

        PINT_perf_count(PINT_acache_get_pc(),
                        PERF_ACACHE_HITS,
                        1,
                        PINT_PERF_ADD);
        if(trimmed_mask & PVFS_ATTR_DATA_SIZE)
        {
            /* Definitely requested size and valid size was in cache. */
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "%s: NOTE, PVFS_ATTR_DATA_SIZE requested. \n",
                         __func__);
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "%s: NOTE, PVFS_ATTR_DATA_SIZE --> ACACHE HIT.\n",
                         __func__);
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "%s: cached size = %lld\n",
                         __func__,
                         lld(sm_p->getattr.size));
        }

        if(trimmed_mask & PVFS_ATTR_DIR_DIRENT_COUNT)
        {
            /* Definitely requested PVFS_ATTR_DIR_DIRENT_COUNT and valid
             * PVFS_ATTR_DIR_DIRENT_COUNT related attributes are cached.
             */
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "%s: NOTE, PVFS_ATTR_DIR_DIRENT_COUNT requested. \n",
                         __func__);
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "%s: NOTE, PVFS_ATTR_DIR_DIRENT_COUNT --> "
                         "ACACHE HIT.\n",
                         __func__);
            /* TODO consider displaying some debug output for
             * PVFS_ATTR_DIR_DIRENT_COUNT related attributes.
             */
            gossip_debug(GOSSIP_ACACHE_DEBUG,
                         "%s: tmp_payload->size_array = %p\n",
                         __func__,
                         (void *) sm_p->getattr.size_array);
        }

        /* nothing is missing, an acache hit on attrs and size! */
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "%s: acache hit on all attributes requested of handle: "
                     "[%s]. Returning...\n",
                     __func__,
                     PVFS_OID_str(&object_ref.handle));
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }
  
    /* check if the only thing missing is the file size, then
     * we don't need to do the object getattr operation, we only
     * need to do the datafile getattr operation, so we return
     * the GETATTR_NEED_DATAFILE_ATTRS error code which will make
     * the getattr-dowork state machine jump to the datafile getattr
     * operation state. 
     */
    if(missing_attrs == PVFS_ATTR_DATA_SIZE)
    {
        /* Some attr(s) are missing. */
        gossip_debug(GOSSIP_ACACHE_DEBUG, 
                     "%s: TRULY MISSING attrs:\n",
                     __func__);
        PINT_attrmask_print(GOSSIP_ACACHE_DEBUG, missing_attrs);

        /* Was the size missing? */
        if(missing_attrs & PVFS_ATTR_DATA_SIZE)
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "%s: NOTE, MISSING PVFS_ATTR_DATA_SIZE --> ACACHE MISS.\n",
                         __func__);
        }
    }

    /* MISS */
    PINT_perf_count(PINT_acache_get_pc(),
                    PERF_ACACHE_MISSES,
                    1,
                    PINT_PERF_ADD);

    /* clean out the attributes we got from the cache; this will be
     * overwritten when we request updated information from the server
     */
    PINT_free_object_attr(&sm_p->getattr.attr);
    gossip_debug(GOSSIP_ACACHE_DEBUG,
                 "acache: acache miss due to mask: [%s]\n",
                 PVFS_OID_str(&object_ref.handle));

    js_p->error_code = GETATTR_CACHE_MISS;
    return SM_ACTION_COMPLETE;
}

/**
 * getattr_client_capcache_lookup
 * @ingroup client_sm_getattr
 *
 * This function determines whether the state machine should
 * request a capability.
 * 
 * NOTE: js_p->error_code may contain GETATTR_CACHE_MISS,
 * indicating an acache miss. This will stay the same even if
 * the capcache hits.
 *
 * @param smcb This must be a valid client state machine handle, with
 * the @ref getattr field containing valid values for the
 * fsid/handle of the desired attribute (in object_ref), as well as the 
 * requested attribute mask (req_attrmask).
 *
 * @param js_p Contains the return code to be set by this function in the
 * @ref error_code field.  This determines the next state action to jump
 * to in the getattr-dowork state machine. 
 * Possible values for js_p->error_code are:
 * <ul>
 * <li><b>GETATTR_CACHE_MISS</b> - Either the acache missed in
 * the prior state, or the capcache missed.
 * </li>
 * <li><b>default (0)</b> - All requested attributes and the
 * capability (if requested) are available.
 * </li>
 *
 * @return This function should always return SM_ACTION_COMPLETE
 * unless an error occurred within the internals of the state
 * machine.
 */

static PINT_sm_action getattr_client_capcache_lookup(struct PINT_smcb *smcb,
                                                     job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_uid local_uid;
    int ret;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    /* only process if a capability was requested */
    if (!(sm_p->getattr.req_attrmask & PVFS_ATTR_CAPABILITY))
    {
        return SM_ACTION_COMPLETE;
    }

    /* retrieve the uid for cache indexing purposes */
    local_uid = PINT_HINT_GET_LOCAL_UID(sm_p->hints);

    /* check for the local UID hint; the kernel module (etc.) will 
      supply this hint -- otherwise we use the current user */
    if (local_uid == (PVFS_uid) -1)
    {
        local_uid = PINT_util_getuid();
        
        PVFS_hint_add(&sm_p->hints, PVFS_HINT_LOCAL_UID_NAME,
                      sizeof(PVFS_uid), &local_uid);
    }

    /* lookup capability */
    ret = PINT_client_capcache_get_cached_entry(sm_p->getattr.object_ref, 
              local_uid, &sm_p->getattr.attr.capability);
    if (ret == 0)
    {
        /* hit - no need to request cap */
        sm_p->getattr.req_attrmask &= ~PVFS_ATTR_CAPABILITY;

        /* mark capability available */
        sm_p->getattr.attr.mask |= PVFS_ATTR_CAPABILITY;
        sm_p->getattr.flags |= PINT_SM_GETATTR_CAPCACHE_HIT;
    }
    else
    {
        if (ret == -PVFS_ENOENT)
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: client capcache miss\n", 
                         __func__);
        }
        else if (ret == -PVFS_ETIME)
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: client capcache timeout\n",
                         __func__);
        }
        else
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: client capcache error "
                         "%d\n", __func__, ret);
        }

        /* report the miss */
        js_p->error_code = GETATTR_CACHE_MISS;
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_object_getattr_setup_msgpair(
                                               struct PINT_smcb *smcb,
                                               job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    PVFS_object_ref object_ref;
    PINT_sm_msgpair_state *msg_p;
    PVFS_capability capability;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    js_p->error_code = 0;

    PINT_null_capability(&capability);

    PINT_msgpair_init(&sm_p->msgarray_op);
    msg_p = &sm_p->msgarray_op.msgpair;

    object_ref = sm_p->getattr.object_ref;

    /* We should check for this earlier in the SM - like the first
     * state - and if it fails, return an error message, rather than an
     * assert.  Asserts are ONLY for situations that should never arrise
     * and even then I am suspisious of them.  They are not good error
     * handling.
     */
    assert(object_ref.fs_id != PVFS_FS_ID_NULL);
    assert(PVFS_OID_cmp(&object_ref.handle, &PVFS_HANDLE_NULL));
    assert(object_ref.sid_count > 0);
    assert(object_ref.sid_array != NULL);

    /* Since we are going to the metadata server for this object, return all
     * attributes stored on this server.  While you're at it, go ahead and
     * regenerate a new capability.  NOTE:  We may not know the object's type,
     * so we ask for everything under the sun; however, getattr on the server
     * will know the object's type, once prelude runs and retrieves this
     * handle's dspace entry.  No worries.
     *
     * One exception is PVFS_ATTR_SYMLNK_ALL.  If set, then the server side
     * getattr will retrieve the "st" (symlink target) entry from the keyval 
     * database.  This poses a problem for symlink creation, because it needs to
     * send a getattr to generate a capability BEFORE the "st" entry is created.
     * Thus, PVFS_ATTR_SYMLNK_ALL is not automatically added.  When the symlink
     * target is needed, the calling client should put this attribute in its
     * request mask.  
     */
    /* Why are we using GOSSIP_ACACHE_DEBUG here?  This would imply
     * this debugging is only of interest when debugging the acache, and
     * not the getattr call which should use GOSSIP_GETATTR_DEBUG, or
     * the combination (bitwise OR) of the two.
     */
    PINT_attrmask_print(GOSSIP_GETATTR_DEBUG, sm_p->getattr.req_attrmask);
    sm_p->getattr.req_attrmask |= PVFS_ATTR_COMMON_ALL
                               | PVFS_ATTR_META_ALL
                               | PVFS_ATTR_DISTDIR_ATTR
                               | PVFS_ATTR_DIR_ALL
                               | PVFS_ATTR_CAPABILITY;
    PINT_attrmask_print(GOSSIP_GETATTR_DEBUG, sm_p->getattr.req_attrmask);

    /* setup the msgpair to do a getattr operation */
    PINT_SERVREQ_GETATTR_FILL(msg_p->req,
                              PVFS_REQ_OTHER,
                              capability,
                              *sm_p->cred_p,
                              object_ref.fs_id,
                              object_ref.handle,
                              sm_p->getattr.req_attrmask,
                              sm_p->hints);

    PINT_cleanup_capability(&capability);

    msg_p->msgclass = PVFS_IO_METADATA;
    msg_p->msgdir = PVFS_IO_READ;
    msg_p->fs_id = object_ref.fs_id;
    msg_p->handle = object_ref.handle;
    msg_p->sid_count = object_ref.sid_count;
    msg_p->sid_index = 0;
    msg_p->sid_array = object_ref.sid_array;
    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
    msg_p->comp_fn = getattr_object_getattr_comp_fn;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: fs_id: %d\n",
                                       __func__, object_ref.fs_id);
    gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: handle: %s\n", __func__,
                                       PVFS_OID_str(&object_ref.handle));
    gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: sid_count: %d\n",
                                       __func__, object_ref.sid_count);
    gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: sid_array: %s\n", __func__,
                                       PVFS_SID_str(&object_ref.sid_array[0]));

    ret = PVFS_SID_get_addr(&msg_p->svr_addr, &msg_p->sid_array[0]);
    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }

    PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_object_getattr_failure(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
#ifdef WIN32
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
#else
    struct PINT_client_sm *sm_p __attribute__((unused)) = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
#endif
    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "(%p) getattr state: getattr_object_getattr_failure\n",
                 sm_p);

    if ((js_p->error_code != -PVFS_ENOENT) &&
        (js_p->error_code != -PVFS_EINVAL))
    {
        PVFS_perror_gossip("getattr_object_getattr_failure ",
                           js_p->error_code);
    }

    return SM_ACTION_COMPLETE;
}

/* NOTE:  This nested state machine allocates and stores the results
 * in getattr.size_array.  So, if you call this state machine directly,
 * do not allocate space prior to calling it to avoid a nasty memory leak.
 */
static PINT_sm_action getattr_datafile_getattr_setup_msgpairarray(
                                                      struct PINT_smcb *smcb,
                                                      job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_getattr_state *getattr = &(sm_p->getattr);
    int ret = -PVFS_EINVAL;
    PVFS_object_attr *attr = NULL;
    PINT_sm_msgpair_state *msg_p = NULL;
    uint64_t mirror_retry = (sm_p->getattr.attr.mask /* &
                                  PVFS_ATTR_META_MIRROR_DFILES */);
#if 0
    int i = 0;
    PVFS_handle *handles;
#endif
    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    PVFS_capability capability;

    gossip_debug(GOSSIP_MIRROR_DEBUG,
                 "Executing getattr_datafile_getattr_setup_msgpairarray...\n");
    gossip_debug(GOSSIP_MIRROR_DEBUG,
                 "%s: Are we mirroring? %s\n",__func__
                ,(mirror_retry ? "YES" : "NO")); 
    gossip_debug(GOSSIP_MIRROR_DEBUG,
                 "%s: attr.mask:0x%lx \tmirror_retry:0x%x\n"
                ,__func__
                ,sm_p->getattr.attr.mask
                ,(unsigned int)mirror_retry);

    js_p->error_code = 0;

    attr = &sm_p->getattr.attr;
    assert(attr);


    /* Note: permission not required for tree_get_file_size op */
    PINT_null_capability(&capability);

    PINT_msgpair_init(&sm_p->msgarray_op);
    msg_p = &sm_p->msgarray_op.msgpair;

    /*initialize the size_array, which will hold the size of each datahandle*/
    PINT_SM_DATAFILE_SIZE_ARRAY_INIT(&getattr->size_array,
                                     attr->u.meta.dfile_count);
    gossip_debug(GOSSIP_ACACHE_DEBUG,
                 "%s: getattr->size_array = %p\n",
                 __func__,
                 (void *) getattr->size_array);

/* V3 this is handled in MPA */
#if 0
    /* initialize mir_ctx_array: one context for each handle in the file */
    getattr->mir_ctx_array = malloc(attr->u.meta.dfile_count *
                                     sizeof(*getattr->mir_ctx_array));
    if (!getattr->mir_ctx_array)
    {
        gossip_lerr("Unable to allocate mirror context array.\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(getattr->mir_ctx_array,
           0,
           attr->u.meta.dfile_count * sizeof(*getattr->mir_ctx_array));

    getattr->mir_ctx_count = attr->u.meta.dfile_count;
    for (i = 0; i < getattr->mir_ctx_count; i++)
    {
        getattr->mir_ctx_array[i].original_datahandle =
                                 attr->u.meta.dfile_array[i];
        getattr->mir_ctx_array[i].original_server_nr = i;
    }
    /* allocate handle array and populate */
    /* freed in getattr_datafile_getattr_cleanup() */
    /* V3 no good reason for this - just pass in the meta.dfile_array */
    handles = malloc(sizeof(PVFS_handle) * attr->u.meta.dfile_count);
    if (!handles)
    {
        gossip_lerr("Unable to allocation local handles array.\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(handles, 0, sizeof(PVFS_handle) * attr->u.meta.dfile_count);
    memcpy(handles,
           attr->u.meta.dfile_array,
           attr->u.meta.dfile_count * sizeof(PVFS_handle));

    memcpy(handles,
           attr->u.meta.dfile_array,
           attr->u.meta.dfile_count * sizeof(PVFS_handle));

    /*allocate index-to-server array and populate*/
    getattr->index_to_server =
                  malloc(sizeof(uint32_t)*attr->u.meta.dfile_count);

    if (!getattr->index_to_server)
    {
        gossip_lerr("Unable to allocate index-to-server array.\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(getattr->index_to_server,
           0,
           sizeof(uint32_t) * attr->u.meta.dfile_count);

    for (i = 0; i < attr->u.meta.dfile_count; i++)
    {
        getattr->index_to_server[i] = (uint32_t)i;
    }
#endif

    PINT_SERVREQ_TREE_GET_FILE_SIZE_FILL(msg_p->req,
                                         capability,
                                         *sm_p->cred_p,
                                         sm_p->getattr.object_ref.fs_id,
                                         0,
                                         attr->u.meta.dfile_count,
                                         attr->u.meta.dfile_array,
                                         attr->u.meta.sid_count,
                                         attr->u.meta.sid_array,
                                         (mirror_retry ? 1 : 0),
                                         sm_p->hints);

    PINT_cleanup_capability(&capability);
    msg_p->msgclass = PVFS_IO_METADATA;
    msg_p->msgdir = PVFS_IO_READ;
    msg_p->fs_id = sm_p->getattr.object_ref.fs_id;
    msg_p->handle = attr->u.meta.dfile_array[0];
    msg_p->sid_count = attr->u.meta.sid_count;
    msg_p->sid_index = 0;
    msg_p->sid_array = attr->u.meta.sid_array;
    msg_p->comp_fn = getattr_datafile_getattr_comp_fn;

    ret = PVFS_SID_get_addr(&msg_p->svr_addr, &msg_p->sid_array[0]);
    if (ret)
    {
        gossip_lerr("Unable to map server address for this handle(%s) and "
                    "filesystem(%d)\n"
                   ,PVFS_OID_str(&msg_p->handle)
                   ,msg_p->fs_id);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    /* set retry flag based on mirroring option...if mirroring, we will handle
     * retries from this machine; if not, msgpairarray will handle retries.
    */
    if (mirror_retry)
    {
        msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
    }
    else
    {
        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
    }

    PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);
    return SM_ACTION_COMPLETE;
}

/* V3 functionality moved to MPA */
#if 0
static PINT_sm_action getattr_datafile_getattr_retry(struct PINT_smcb *smcb,
                                                     job_status_s *js_p)
{
    PINT_smcb *smcb = v_p;
    PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    PINT_sm_msgpair_state *msg = &(sm_p->msgarray_op.msgarray[index]);
    struct PVFS_servreq_tree_get_file_size *tree = 
                                              &(msg->req.u.tree_get_file_size);

    PINT_sm_getattr_state *getattr = &(sm_p->getattr);
    PINT_client_getattr_mirror_ctx *ctx = NULL;
    uint32_t server_nr = 0;
    int i = 0;

    if (resp_p->status)
    {   /* tree request had a problem */
        return resp_p->status;
    }

    assert(resp_p->op == PVFS_SERV_TREE_GET_FILE_SIZE);


    /* if we are mirroring, then we need to check the error code returned from
     * each server. If an error is found, mirroring will try to get the size 
     * from a different server.  Below, we are marking which handles completed 
     * successfully, which tells mirroring NOT to retry them.
    */
    if ( getattr->attr.mask & PVFS_ATTR_META_MIRROR_DFILES)  
    {
       for (i=0; i<resp_p->u.tree_get_file_size.handle_count; i++)
       {
          if (resp_p->u.tree_get_file_size.error[i] != 0)
          {   /* error retrieving size for this handle..we will retry it. */
              continue;
          }
          server_nr = getattr->index_to_server[i];
          sm_p->getattr.size_array[server_nr] = resp_p->u.tree_get_file_size.size[i];
          ctx = &(getattr->mir_ctx_array[server_nr]);
          ctx->msg_completed = 1; 

          /*For completed messages, update the size array with the file size
           *just retrieved.
          */
          getattr->size_array[server_nr] = resp_p->u.tree_get_file_size.size[i];
          gossip_debug(GOSSIP_GETATTR_DEBUG,"%s: size[%d]:%lld \thandle:%llu\n"
                                         ,__func__
                                         ,i
                                         ,llu(getattr->size_array[i])
                                         ,llu(tree->handle_array[i]));
       }/*end for*/
    }
    else
    {
     /* if we are NOT mirroring and an error is found for an individual handle, 
      * then we must invalidate the size array and return an error code.
     */
       for (i=0; i<resp_p->u.tree_get_file_size.handle_count; i++)
       {
          gossip_debug(GOSSIP_GETATTR_DEBUG,"%s: error[%d]:%d"
                                               "\tsize[%d]:%d\n"
                                           ,__func__
                                           ,i
                                           ,(int)resp_p->u.tree_get_file_size.error[i]
                                           ,i
                                           ,(int)resp_p->u.tree_get_file_size.size[i]);

          if (resp_p->u.tree_get_file_size.error[i] != 0)
          {
              gossip_debug(GOSSIP_GETATTR_DEBUG,"%s: error[%d] is %d\n"
                                               ,__func__
                                               ,i
                                               ,resp_p->u.tree_get_file_size.error[i]);
              memset(getattr->size_array,0,sizeof(*getattr->size_array));
              return (resp_p->u.tree_get_file_size.error[i]);
          }

          getattr->size_array[i] = resp_p->u.tree_get_file_size.size[i];
       }/*end for*/

    }/*end if*/

    return(0);
}/*end getattr_datafile_getattr_comp_fn*/

static PINT_sm_action getattr_datafile_getattr_retry(struct PINT_smcb *smcb,
                                                     job_status_s *js_p)
{
    struct PINT_client_sm   *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_object_attr *attr = &(sm_p->getattr.attr);
    PVFS_metafile_attr *meta = &(attr->u.meta);
    PINT_sm_getattr_state *getattr = &(sm_p->getattr);
    PINT_client_getattr_mirror_ctx *ctx = NULL;
    PINT_sm_msgarray_op *mop = &(sm_p->msgarray_op);
    PINT_sm_msgpair_state *msg = &(mop->msgarray[0]);
    char *enc_req_bytes = NULL;
    struct PVFS_servreq_tree_get_file_size *tree = 
                                              &(msg->req.u.tree_get_file_size);
    uint32_t retry_msg_count = 0;
    uint32_t index = 0;
    uint32_t copies = 0;
    uint32_t server_nr = 0;
    int i   = 0;
    int j   = 0;
    int k   = 0;
    int ret = 0;
    uint32_t *tmp_server_nr;
    PVFS_handle *tmp_handles;

    gossip_debug(GOSSIP_CLIENT_DEBUG, 
                 "(%p) getattr state: "
                 "getattr_datafile_getattr_retry\n", sm_p);

    /* We only need to retry if we have mirrors; otherwise, msgpairarray 
     * has already handled the retries.
     */
    if (!(attr->mask & PVFS_ATTR_META_MIRROR_DFILES))  
    {  
        /*we are NOT mirroring.*/
        return SM_ACTION_COMPLETE;
    }
    
    /* How many handles need to be retried? */
    for (i = 0; i < tree->num_data_files; i++)
    {
        server_nr = getattr->index_to_server[i];
        ctx = &(getattr->mir_ctx_array[server_nr]);
        if (ctx->msg_completed == 0)
        {
            retry_msg_count++;
        }
    }

    /* no retries needed */
    if (retry_msg_count == 0)
    {
        return SM_ACTION_COMPLETE;
    }

    /* do we have any retries available? */
    if (getattr->retry_count >= mop->params.retry_limit)
    {
        /* at this point, we have msgpairs that need to be retried, but we
         * we have met our retry limit.  so, we must invalidate the size array,
         * since we don't have all of the necessary sizes AND return an error.
         */
        memset(getattr->size_array,
               0,
               sizeof(*getattr->size_array) * getattr->size);
        js_p->error_code = (js_p->error_code ? js_p->error_code : -PVFS_ETIME);
        gossip_err("%s: Ran out of retries(%d)\n"
                   ,__func__
                   ,getattr->retry_count);
        return SM_ACTION_COMPLETE;
    }

    /*allocate temporary index-to-server array*/
    tmp_server_nr = malloc(sizeof(uint32_t) * retry_msg_count);
    if (!tmp_server_nr)
    {
        gossip_lerr("Unable to allocate temporary index-to-server array.\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(tmp_server_nr,0,sizeof(uint32_t) * retry_msg_count);

    /*allocate temporary handle array*/
    tmp_handles = malloc(sizeof(PVFS_handle) * retry_msg_count);
    if (!tmp_handles)
    {
        gossip_lerr("Unable to allocate temporary handle array.\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(tmp_handles, 0, sizeof(PVFS_handle) * retry_msg_count);

    /* okay. let's setup new handles to retry. 
     */
    for (i = 0, j = 0; i < tree->num_data_files; i++)
    {
        server_nr = getattr->index_to_server[i];
        ctx = &(getattr->mir_ctx_array[server_nr]);
     
        /* don't process completed messages */
        if (ctx->msg_completed)
        {
            continue;
        }

        /* for incomplete messages, cleanup memory, if necessary */ 
        enc_req_bytes = (char *)&(msg->encoded_req);
        for (k=0; k<sizeof(msg->encoded_req); k++)
        {
            if (enc_req_bytes[k] != '\0')
            {
                PINT_encode_release(&(msg->encoded_req),PINT_ENCODE_REQ);
                break;
            }
        }/*end for*/

        if (msg->encoded_resp_p)
        {
            BMI_memfree(msg->svr_addr
                       ,msg->encoded_resp_p
                       ,msg->max_resp_sz
                       ,BMI_RECV);
        }
        
        /* Should we use the original datahandle? */
        if (ctx->retry_original)
        {
            ctx->retry_original = 0;
            tmp_handles[j]   = ctx->original_datahandle;
            tmp_server_nr[j] = ctx->original_server_nr;
            j++;
            continue;
        }/*end retry_original*/

        /* otherwise, get next mirrored handle.  note:  if a mirrored handle is
         * zero, then this means that the creation of this mirrored object 
         * failed for its particular server.  in this case, get the next valid 
         * handle.  as a last resort, retry the original handle.
        */
        for (copies = ctx->current_copies_count;
             copies < meta->mirror_copies_count;
             copies++)
        {
            index = (copies*meta->dfile_count) + server_nr;
            if (PVFS_OID_cmp(&meta->mirror_dfile_array[index],
                             &PVFS_HANDLE_NULL))
            {
                /* we have found a valid mirrored handle */
                tmp_handles[j]   = meta->mirror_dfile_array[index];
                tmp_server_nr[j] = server_nr;
                j++;
                break;
            }
        }

        /* if we haven't found a valid mirrored handle, retry the original
         * datahandle.
        */
        if ( copies == meta->mirror_copies_count )
        {
            tmp_handles[j]   = ctx->original_datahandle;
            tmp_server_nr[j] = ctx->original_server_nr;
            j++;
            ctx->retry_original = 0;
            ctx->current_copies_count = 0;
            getattr->retry_count++;
            continue;
        }/*end if we have to use the original*/

        /* otherwise, setup for the next retry event */
        ctx->current_copies_count++;
        if (ctx->current_copies_count == meta->mirror_copies_count)
        {
            ctx->current_copies_count = 0;
            ctx->retry_original = 1;
            getattr->retry_count++;
        }
    }/*end for each handle in the old request*/

    /*replace values in old tree request*/
    free(tree->handle_array);
    tree->handle_array = tmp_handles;
    tree->num_data_files = retry_msg_count;
    
    /*replace values in old message request*/
    msg->handle = tmp_handles[0];
    msg->svr_addr=0;
    ret = PINT_cached_config_map_to_server(&msg->svr_addr
                                          ,msg->handle
                                          ,msg->fs_id);
    if (ret)
    {
        gossip_lerr("Unable to determine server address for handle(%s) and "
                    "file system(%d).\n"
                   ,PVFS_OID_str(&msg->handle)
                   ,msg->fs_id);
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /*save index-to-server array*/
    free(getattr->index_to_server);
    getattr->index_to_server = tmp_server_nr;

    /* Push the msgarray_op and jump to msgpairarray.sm */
    PINT_sm_push_frame(smcb, 0, mop);
    js_p->error_code=GETATTR_IO_RETRY;

    return SM_ACTION_COMPLETE;
} /* end datafile_getattr_retry */
#endif

static PINT_sm_action getattr_datafile_getattr_cleanup(struct PINT_smcb *smcb,
                                                       job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);    

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

#if 0
    PINT_sm_getattr_state *getattr = &(sm_p->getattr);

    /* cleanup handle_array created for the one tree request */
    /* V3 this should be freed elsewhere because we no longer allocate
     * this as a special array
     */
    PINT_sm_getattr_state *getattr = &(sm_p->getattr);
    PINT_sm_msgpair_state *msg_p = &(sm_p->msgarray_op.msgarray[0]);
    if (msg_p->req.u.tree_get_file_size.handle_array)
    {
        free(msg_p->req.u.tree_get_file_size.handle_array);
    }
#endif
    
    /* cleanup tree request */
    PINT_msgpairarray_destroy(&sm_p->msgarray_op);

#if 0
    /* cleanup memory that may have been used for mirrored retries.*/
    if (getattr->mir_ctx_array)
    {
        free(getattr->mir_ctx_array);
    }
    if (getattr->index_to_server)
    {
        free(getattr->index_to_server);
    }
#endif

    return SM_ACTION_COMPLETE;
}

/* We run this state if we are doing getattr on a direcotry AND we need
 * the up-to-date timestamps and total dirdate count.  Unlink the
 * earlier request this sends multiple getattr requests to the dirdate
 * objects (not the directory object) and only asks for the partial data
 * which will be combined afterwards.
 */
static PINT_sm_action getattr_dirdata_getattr_setup_msgpairarray(
                                                    struct PINT_smcb *smcb,
                                                    job_status_s *js_p)
{           
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    int i = 0;
    PVFS_object_attr *attr = NULL;
    PINT_sm_msgpair_state *msg_p = NULL;
    int tmp_index, cur_index;
    PVFS_capability capability;
        
    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    js_p->error_code = 0;
        
    attr = &sm_p->getattr.attr;
    assert(attr);

    assert(attr->mask & PVFS_ATTR_DISTDIR_ATTR);
            
    /* initialize size_array, used to store the dirent_count
     * of every dirdata handle
     */      
    PINT_SM_DATAFILE_SIZE_ARRAY_INIT(&sm_p->getattr.size_array,
            attr->u.dir.dist_dir_attr.dirdata_count);
            
    gossip_debug(GOSSIP_ACACHE_DEBUG,
                 "%s: sm_p->getattr->size_array = %p\n",
                 __func__,
                 (void *) sm_p->getattr.size_array);

    sm_p->getattr.active_dirdata_index = (int *)malloc(
            sizeof(*sm_p->getattr.active_dirdata_index) *
            attr->u.dir.dist_dir_attr.dirdata_count);

    if(!sm_p->getattr.active_dirdata_index)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }


    /* find out active dirdata handles. (active refers to dirdata handles
     * having directory entries) 
     */
    tmp_index = 0;
    for (i = 0; i < attr->u.dir.dist_dir_attr.dirdata_count; i++)
    {
        if (PINT_is_dist_dir_bucket_active(&attr->u.dir.dist_dir_attr,
                    attr->u.dir.dist_dir_bitmap, i))
        {
            sm_p->getattr.active_dirdata_index[tmp_index] = i;
            tmp_index++;
        }        
    }
    assert(tmp_index > 0);

    PINT_null_capability(&capability);

    /* initialize msgpair array */
    ret = PINT_msgpairarray_init(&sm_p->msgarray_op, tmp_index);
    if(ret != 0)
    {
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }
    
    /* prepare to post the getattr send/recv pairs for all dirdata*/
    foreach_msgpair(&sm_p->msgarray_op, msg_p, i)
    {
        cur_index = sm_p->getattr.active_dirdata_index[i];
    
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "getattr: posting dirdata getattr[%d] ([%d]:%s,%d)\n",
                     i, cur_index,
                     PVFS_OID_str(&attr->u.dir.dirdata_handles[cur_index]),
                     sm_p->getattr.object_ref.fs_id);

        PINT_SERVREQ_GETATTR_FILL(
                    msg_p->req,
                    PVFS_REQ_DIRDATA,
                    capability,
                    *sm_p->cred_p,
                    sm_p->getattr.object_ref.fs_id,
                    attr->u.dir.dirdata_handles[cur_index],
                    /* only interested in timestamp and dirent_count */
                    PVFS_ATTR_COMMON_ALL|PVFS_ATTR_DIR_DIRENT_COUNT,
                    sm_p->hints);

        /* fill in msgpair structure components */
        msg_p->msgclass = PVFS_IO_METADATA;
        msg_p->msgdir = PVFS_IO_READ;
        msg_p->fs_id = sm_p->getattr.object_ref.fs_id;
        msg_p->handle = attr->u.dir.dirdata_handles[cur_index];
        msg_p->sid_count = sm_p->getattr.object_ref.sid_count;
        msg_p->sid_index = 0;
        msg_p->sid_array = sm_p->getattr.object_ref.sid_array;
        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
        msg_p->comp_fn = getattr_dirdata_getattr_comp_fn;
        
        /* V3 */
#if 0
        ret = PINT_cached_config_map_to_server(
            &msg_p->svr_addr, msg_p->handle, msg_p->fs_id);
#endif

        ret = PVFS_SID_get_addr(&msg_p->svr_addr, &msg_p->sid_array[0]);
        if (ret)
        {   
            gossip_err("Failed to map meta server address\n");
            js_p->error_code = ret;
            break;
        }
    }

    PINT_cleanup_capability(&capability);
    
    PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);
    return SM_ACTION_COMPLETE;

}

/* V3 move up to comp_fn section */
/* This is called from mesgpairarray which has a PJMP and this code
 * tries to unroll the statck, thus it must use the parent point on the
 * smcb to correctly get back in context.
 */
static int getattr_dirdata_getattr_comp_fn(void *v_p,
                                           struct PVFS_server_resp *resp_p,
                                           int index)
{
    PINT_smcb *smcb = v_p; 
    PINT_smcb *parent_smcb = smcb->parent_smcb;
    PINT_client_sm *sm_p = PINT_sm_frame(parent_smcb, PINT_MSGPAIR_PARENT_SM);
    PVFS_object_attr *attr_p = NULL;
    PVFS_object_attr *resp_attr_p = NULL;
    int cur_index;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    /*NOTE: The getattr response is of type PVFS_TYPE_DIRDATA, so we should be
     *      looking in the dirdata structure, not the dir structure, for values.
     */ 
    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "getattr_dirdata_getattr_comp_fn called\n");
    gossip_debug(GOSSIP_GETATTR_DEBUG, "dirdata getattr[%d] got response %d\n",
                 index, resp_p->status);

    if (resp_p->status)
    {
        return resp_p->status;
    }

    assert(resp_p->op == PVFS_SERV_GETATTR);

    attr_p = &sm_p->getattr.attr;
    resp_attr_p = &resp_p->u.getattr.attr;
    cur_index = sm_p->getattr.active_dirdata_index[index];

    assert(resp_attr_p->objtype == PVFS_TYPE_DIRDATA);
    assert(resp_attr_p->mask & PVFS_ATTR_DIR_DIRENT_COUNT);
    assert( (cur_index >= 0) &&
            (cur_index < attr_p->u.dir.dist_dir_attr.dirdata_count));

    gossip_debug(GOSSIP_GETATTR_DEBUG,
            "dirdata getattr[%d] (#[%d]) returns attrs: "
            "[dirent_count=%llu, "
            "atime = %llu, mtime = %llu, ctime = %llu]\n",
            index, cur_index,
            llu(resp_attr_p->u.dirdata.dirent_count),
            llu(resp_attr_p->atime),
            llu(resp_attr_p->mtime),
            llu(resp_attr_p->ctime));

    /* update timestamp and dirent_count */
    sm_p->getattr.size_array[cur_index] = resp_attr_p->u.dirdata.dirent_count;

    /* we are adding the directory entry count from the DIRDATA object to the
     * total directory entry count.  A directory may have several DIRDATA objects,
     * so we must combine each directory entry count from each DIRDATA object in
     * order to calculate the total number of entries in a directory.
     */
    attr_p->u.dir.dirent_count += resp_attr_p->u.dirdata.dirent_count;

    /* If we have a non-zero dirent count, then make sure other function calls know
     * that we have a valid dirent count by setting the DIRENT_COUNT bit in the
     * attribute mask.
     */
    if ( resp_attr_p->u.dirdata.dirent_count != 0 )
    {
       attr_p->mask |= PVFS_ATTR_DIR_DIRENT_COUNT;
    }

    /* Reset times if they are newer than the ones we already have. */
    if(attr_p->atime < resp_attr_p->atime)
    {   
        attr_p->atime = resp_attr_p->atime;
    }
    if(attr_p->ctime < resp_attr_p->ctime)
    {   
        attr_p->ctime = resp_attr_p->ctime;
    }
    if(attr_p->mtime < resp_attr_p->mtime)
    {   
        attr_p->mtime = resp_attr_p->mtime;
    }

    PINT_attrmask_print(GOSSIP_GETATTR_DEBUG, attr_p->mask);
    gossip_debug(GOSSIP_GETATTR_DEBUG, "updated directory attrs: "
            "[dirent_count=%llu, atime = %llu, mtime = %llu, ctime = %llu]\n",
            llu(attr_p->u.dir.dirent_count),
            llu(attr_p->atime),
            llu(attr_p->mtime),
            llu(attr_p->ctime));

    return 0;
}

static PINT_sm_action getattr_dirdata_getattr_cleanup(
                                      struct PINT_smcb *smcb,
                                      job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    /* cleanup tree request */
    PINT_msgpairarray_destroy(&sm_p->msgarray_op);

    if(sm_p->getattr.active_dirdata_index)
    {
        free(sm_p->getattr.active_dirdata_index);
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_acache_insert(struct PINT_smcb *smcb,
                                            job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_size* tmp_size = NULL;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    /* TODO: This is for debugging only. */
#if 0
    if(sm_p->getattr.attr.mask & PVFS_ATTR_CAPABILITY)
    {
        gossip_debug(GOSSIP_ACACHE_DEBUG,
                     "%s: sm_p->getattr.attr.mask HAS PVFS_ATTR_CAPABILITY\n",
                     __func__);
        gossip_debug(GOSSIP_ACACHE_DEBUG,
                     "%s: capability timeout = %llu\n",
                     __func__,
                     llu(sm_p->getattr.attr.capability.timeout));
    }
    else
    {
        gossip_debug(GOSSIP_ACACHE_DEBUG,
                     "%s: sm_p->getattr.attr.mask DOES NOT HAVE "
                     "PVFS_ATTR_CAPABILITY\n", __func__);
    }
#endif

    uint32_t missing_attrs = (
        (sm_p->getattr.req_attrmask ^ sm_p->getattr.attr.mask) &
         sm_p->getattr.req_attrmask
        );

    gossip_debug(GOSSIP_ACACHE_DEBUG,
                 "%s: Mask properties of the request:\n",
                 __func__);
    PINT_attrmask_print(GOSSIP_ACACHE_DEBUG, sm_p->getattr.req_attrmask);
    gossip_debug(GOSSIP_ACACHE_DEBUG,
                 "%s: Mask properties of the object we are inserting:\n",
                 __func__);
    PINT_attr_dump_object_type(GOSSIP_ACACHE_DEBUG, &sm_p->getattr.attr);
    PINT_attrmask_print(GOSSIP_ACACHE_DEBUG, sm_p->getattr.attr.mask);
    if(missing_attrs)
    {
        gossip_debug(GOSSIP_ACACHE_DEBUG,
                     "%s: Mask properties missing:\n",
                     __func__);
        PINT_attrmask_print(GOSSIP_ACACHE_DEBUG, missing_attrs);
    }
    else
    {
        gossip_debug(GOSSIP_ACACHE_DEBUG,
                     "%s: No mask properties missing:\n",
                     __func__);
    }

    if( sm_p->getattr.attr.objtype == PVFS_TYPE_METAFILE || 
        sm_p->getattr.attr.objtype == PVFS_TYPE_DIRECTORY ||
        sm_p->getattr.attr.objtype == PVFS_TYPE_SYMLINK )
    {
        /* see if we have a size value to cache */

        /* TODO: we should not be using the req_attrmask here. */
        /* Apparently, using the attr.mask here causes problems.
         * This should not be the case, so some more debugging is needed.
         */
        if (sm_p->getattr.attr.objtype == PVFS_TYPE_METAFILE &&
            sm_p->getattr.req_attrmask & PVFS_ATTR_DATA_SIZE)
        {
            gossip_debug(GOSSIP_ACACHE_DEBUG,
                         "%s: NOTE, objtype is metafile and "
                         "PVFS_ATTR_DATA_SIZE is in mask. "
                         "Should cache size.\n",
                         __func__);
            gossip_debug(GOSSIP_ACACHE_DEBUG,
                         "%s: caching file size\n",
                         __func__);
            /* compute size as requested */
            assert(sm_p->getattr.attr.u.meta.dist);
            assert(sm_p->getattr.attr.u.meta.dist->methods &&
                    sm_p->getattr.attr.u.meta.dist->methods->logical_file_size);

            sm_p->getattr.size =
                   (sm_p->getattr.attr.u.meta.dist->methods->logical_file_size)(
                            sm_p->getattr.attr.u.meta.dist->params,
                            sm_p->getattr.attr.u.meta.dfile_count,
                            sm_p->getattr.size_array);

            tmp_size = &sm_p->getattr.size;
            gossip_debug(GOSSIP_GETATTR_DEBUG
                         ,"getattr_acache_insert calculated"
                          " logical size of %lld\n"
                         , lld(*tmp_size));
        }

        if (sm_p->getattr.attr.objtype == PVFS_TYPE_DIRECTORY &&
            sm_p->getattr.req_attrmask & PVFS_ATTR_DIR_DIRENT_COUNT)
        {
            /* size_array SHOULD be valid here if the proper bit was flipped */
            gossip_debug(GOSSIP_ACACHE_DEBUG,
                         "%s: getattr should cache size array! "
                         "handle=%s size_array=%p num_servers=%d\n",
                         __func__,
                         PVFS_OID_str(&sm_p->getattr.object_ref.handle),
                         (void *) sm_p->getattr.size_array,
                         sm_p->getattr.attr.u.dir.dist_dir_attr.dirdata_count);
        }

#if 0 /* Don't cache size_array. */
        PINT_acache_update(sm_p->getattr.object_ref,
                           &sm_p->getattr.attr,
                           tmp_size,
                           sm_p->getattr.size_array);
#endif
        PINT_acache_update(sm_p->getattr.object_ref,
                           &sm_p->getattr.attr,
                           tmp_size);
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_client_capcache_insert(struct PINT_smcb *smcb,
                                                     job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    PVFS_uid local_uid;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    /* only process if capability returned */
    if (!(sm_p->getattr.attr.mask & PVFS_ATTR_CAPABILITY))
    {
        return SM_ACTION_COMPLETE;
    }

    /* If the LOCAL_UID hint is not set, which can happen when the sysint interface
     * is called by an app like pvfs2-ls, then we set local uid to the process uid
     * running this code.  Otherwise, we assume the hint contains the proper uid,
     * as is the case for the client core.
     */
    local_uid = PINT_HINT_GET_LOCAL_UID(sm_p->hints);

    if (local_uid == (PVFS_uid) -1)
    {
        local_uid = PINT_util_getuid();

        PVFS_hint_add(&sm_p->hints, PVFS_HINT_LOCAL_UID_NAME,
                      sizeof(PVFS_uid), &local_uid);
    }

    ret = PINT_client_capcache_update(sm_p->getattr.object_ref, 
                                      local_uid, 
                                      &sm_p->getattr.attr.capability);
    gossip_debug(GOSSIP_SECURITY_DEBUG, "%s: "
                 "PINT_client_capcache_update returned %d\n",
                     __func__, ret);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_cleanup(struct PINT_smcb *smcb,
                                      job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_getattr_state *getattr = &(sm_p->getattr);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "(%p) getattr state: getattr_cleanup\n", sm_p);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "%s: js_p->error_code:%d \tgetattr->attr.mask:0x%lx\n",
                 __func__,
                 js_p->error_code,
                 getattr->attr.mask);

    sm_p->error_code = js_p->error_code;

    /* cleanup size array if not asked to keep;
     * is allocated if datafile sizes or dirent_count are retrieved */
    /* keep_size_array is initialized outside the state machine, 
     * now only used in sys-readdir.sm */
    if (!getattr->keep_size_array && getattr->size_array)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "%s: about to free: getattr->size_array = %p\n",
                     __func__,
                     (void *) getattr->size_array);
        PINT_SM_DATAFILE_SIZE_ARRAY_DESTROY(&getattr->size_array);
    }

    /* cleanup getattr when an error occurs */
    if (js_p->error_code)
    {
        PINT_free_object_attr(&getattr->attr);
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_set_sys_response(struct PINT_smcb *smcb,
                                               job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_sysresp_getattr * sysresp = NULL;
    PVFS_object_attr *attr = NULL;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    if(js_p->error_code != 0)
    {
        PINT_SET_OP_COMPLETE;
        return SM_ACTION_TERMINATE;
    }

    attr = &sm_p->getattr.attr;
    assert(attr);
    

    /* If we get to this state action, 
     * the getattr state machine was invoked, so
     * we can assume that one of the PVFS_[i]sys_getattr functions
     * was called, and the response field must be filled in for the
     * user.
     */
    sysresp = sm_p->u.getattr.getattr_resp_p;
    
    /*
     * if we retrieved a symlink target, copy it for the caller; this
     * target path will be handed all the way back up to the caller via
     * the PVFS_sys_attr object.  The caller of PVFS_[i]sys_getattr
     * must free it.
     */

    if(attr->objtype == PVFS_TYPE_SYMLINK &&
       attr->mask & PVFS_ATTR_SYMLNK_TARGET)
    {
        assert(attr->u.sym.target_path_len > 0);
        assert(attr->u.sym.target_path);

        sysresp->attr.link_target = strdup(attr->u.sym.target_path);
        if (!sysresp->attr.link_target)
        {
            js_p->error_code = -PVFS_ENOMEM;
            PINT_SET_OP_COMPLETE;
            return SM_ACTION_TERMINATE;
        }
    }

    if(attr->objtype == PVFS_TYPE_METAFILE) 
    {
        /* Copy if there are any special object specific flags */
        sysresp->attr.flags = attr->u.meta.flags;
        /* special case for when users ask for dfile count */
        if (attr->mask & PVFS_ATTR_META_DFILES)
        {
            sysresp->attr.dfile_count = attr->u.meta.dfile_count;
        }
/* V3 remove */
#if 0
        if (sm_p->getattr.req_attrmask & PVFS_ATTR_META_MIRROR_DFILES)
        {
            sysresp->attr.mirror_copies_count = attr->u.meta.mirror_copies_count;
        }
#endif
    }
    if (attr->objtype == PVFS_TYPE_DIRECTORY)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "dfile_count: %d\n", 
                     attr->u.dir.hint.dfile_count);
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "dist_name_len = %d, "
                     "dist_params_len = %d\n",
                     attr->u.dir.hint.dist_name_len,
                     attr->u.dir.hint.dist_params_len);
        sysresp->attr.dfile_count = attr->u.dir.hint.dfile_count;
        /* 
         * If we retrieved any extended attributes for the directory
         * in question, it is the caller's responsibility to free it up
         */
        if (attr->u.dir.hint.dist_name_len > 0 && 
            (sm_p->getattr.req_attrmask & PVFS_ATTR_DIR_HINT))
        {
            sysresp->attr.dist_name = strdup(attr->u.dir.hint.dist_name);
            if (!sysresp->attr.dist_name)
            {
                js_p->error_code = -PVFS_ENOMEM;
                PINT_SET_OP_COMPLETE;
                return SM_ACTION_TERMINATE;
            }
            gossip_debug(GOSSIP_GETATTR_DEBUG
                         , "dist_name_hint: %s\n"
                         , sysresp->attr.dist_name);
        }
        if (attr->u.dir.hint.dist_params_len > 0 &&
            (sm_p->getattr.req_attrmask & PVFS_ATTR_DIR_HINT))
        {
            sysresp->attr.dist_params = strdup(attr->u.dir.hint.dist_params);
            if (!sysresp->attr.dist_params)
            {
                free(sysresp->attr.dist_name);
                sysresp->attr.dist_name = NULL;
                js_p->error_code = -PVFS_ENOMEM;
                PINT_SET_OP_COMPLETE;
                return SM_ACTION_TERMINATE;
            }
            gossip_debug(GOSSIP_GETATTR_DEBUG, "dist_name_params: %s\n"
                                            , sysresp->attr.dist_params);
        }
    }

    /* copy outgoing sys_attr fields from returned object_attr */
    sysresp->attr.owner   = attr->owner;
    sysresp->attr.group   = attr->group;
    sysresp->attr.perms   = attr->perms;
    sysresp->attr.atime   = attr->atime;
    sysresp->attr.mtime   = attr->mtime;
    sysresp->attr.ctime   = attr->ctime;
    sysresp->attr.ntime   = attr->ntime;
    sysresp->attr.objtype = attr->objtype;

    sysresp->attr.mask  = 0;
    sysresp->attr.size  = 0;

    if (js_p->error_code == 0)
    {

        /* convert outgoing attribute mask based on what we got */
        sysresp->attr.mask = PVFS_util_object_to_sys_attr_mask(attr->mask);


        if (attr->mask & PVFS_ATTR_DATA_SIZE)
        {
            if( attr->objtype == PVFS_TYPE_DATAFILE )
            {
                sysresp->attr.size = attr->u.data.size;
            }
            else
            {
                sysresp->attr.size = sm_p->getattr.size;
            }

            sysresp->attr.mask |= PVFS_ATTR_SYS_SIZE;
        }

        if ((attr->mask & PVFS_ATTR_META_DIST) &&
            (attr->mask & PVFS_ATTR_META_DFILES))
        {
            /* we have enough information to set a block size */
            sysresp->attr.blksize = attr->u.meta.dist->methods->get_blksize(
                                                  attr->u.meta.dist->params,
                                                  attr->u.meta.dfile_count);
            sysresp->attr.mask |= PVFS_ATTR_SYS_BLKSIZE;
        }
        else
        {
            /* we can't return the blocksize */
            /* unfortunately, PVFS_util_object_to_sys_attr_mask adds PVFS_ATTR_SYS_BLKSIZE to
             * the mask by checking only for the meta distribution and not both the meta
             * distribution and dfile count.  So, we have to remove it.
             */
            sysresp->attr.mask &= (~PVFS_ATTR_SYS_BLKSIZE);
        }

        /* if this is a symlink, add the link target */
        if (attr->mask & PVFS_ATTR_SYMLNK_TARGET)
        {
            sysresp->attr.mask |= PVFS_ATTR_SYS_LNK_TARGET;
        }

        if(attr->mask & PVFS_ATTR_DIR_DIRENT_COUNT)
        {
            sysresp->attr.dirent_count = attr->u.dir.dirent_count;
            sysresp->attr.mask |= PVFS_ATTR_SYS_DIRENT_COUNT;
        }

        if (attr->mask & PVFS_ATTR_DISTDIR_ATTR)
        {
            sysresp->attr.distr_dir_servers_max =
                                attr->u.dir.dist_dir_attr.dirdata_count;
            sysresp->attr.mask |= PVFS_ATTR_SYS_DISTDIR_ATTR;
        }
    }
    else
    {
        /* in case of failure, blank out response */ 
        memset(sm_p->u.getattr.getattr_resp_p,
               0,
               sizeof(PVFS_sysresp_getattr));
    }

    PINT_SM_GETATTR_STATE_CLEAR(sm_p->getattr);

    PINT_SET_OP_COMPLETE;
    return SM_ACTION_TERMINATE;
}

static PINT_sm_action attr_mask_include_size(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *attr_p = &sm_p->getattr.attr;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", sm_p, __func__);

    gossip_debug(GOSSIP_ACACHE_DEBUG,
                 "%s: INCLUDING PVFS_ATTR_DATA_SIZE BIT IN ATTR MASK\n",
                 __func__);

    attr_p->mask |= PVFS_ATTR_DATA_SIZE;

    return SM_ACTION_COMPLETE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
