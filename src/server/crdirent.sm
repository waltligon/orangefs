/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "pvfs2-config.h"
#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-util.h"
#include "pvfs2-internal.h"
#include "pint-util.h"
#include "pint-security.h"
#include "dist-dir-utils.h"
#include "pint-cached-config.h"
#include "pvfs2-dist-basic.h"
#include "security-util.h"
#include "pint-uid-map.h"
#include "sid.h"

/* V3 */
#if 0
static int split_comp_fn(
        void *v_p,
        struct PVFS_server_resp *resp_p,
        int i);
static int tree_setattr_comp_fn(
        void *v_p,
        struct PVFS_server_resp *resp_p,
        int index);
#endif

enum
{
    SPLIT_REQUIRED = 131,
    SPLIT_FATAL_ERROR,
    NOTIFY_DIRDATA,
    LOCAL_METAHANDLE,
    REMOTE_METAHANDLE,
    REMOVE_ENTRIES_REQUIRED
};

%%

nested machine pvfs2_crdirent_work_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => get_bitmap_and_dirdata_handles;
        default => return;
    }

    /* these are used to validate the new entry */
    state get_bitmap_and_dirdata_handles
    {
        run crdirent_get_bitmap_and_dirdata_handles;
        success => validate;
        default => return;
    }

    state validate
    {
        run crdirent_validate;
        success => write_dirent;
        default => return;
    }

    state write_dirent
    {
        run crdirent_write_dirent;
        success => setup_read_parent_dir_attrs;
        default => return;
    }

    /*
    state update_directory_attr
    {
        run crdirent_update_directory_attr;
        success => setup_read_parent_dir_attrs;
        default => return;
    }
    */

    /* read parent dir apps so that CTIME and dirent_count can be updated */
    state setup_read_parent_dir_attrs
    {
        run crdirent_setup_read_parent_dir_attrs;
        REMOTE_METAHANDLE => complete_remote_read_parent_dir_attrs_xfer_msgpair;
        success => complete_read_local_parent_dir_attrs;
        default => return;
    }

    state complete_read_local_parent_dir_attrs
    {
        run crdirent_complete_read_local_parent_dir_attrs;
        default => check_for_split;
    }

    state complete_remote_read_parent_dir_attrs_xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        success => check_for_split;
        default => return;
    }

    /* setattr */
    state check_for_split
    {
        run crdirent_check_for_split;
        SPLIT_REQUIRED => do_split;
        default => update_dirdata_attr;
    }

    state do_split
    {
        /* state machine in dirent-split.sm */
        jump pvfs2_dirdata_split_sm;
        default => update_dirdata_attr;
    }

    state update_dirdata_attr
    {
        run crdirent_update_dirdata_attr;
        default => return;
    }
}

machine pvfs2_crdirent_sm
{
    state work
    {
        jump pvfs2_crdirent_work_sm;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run crdirent_cleanup;
        default => terminate;
    }
}

%%

#if 0
/* crdirent_setup_op()
 * 
 * prepare some state machine fields for later processing; mainly just
 * storing request structure fields in state machine so that nested
 * machines are not dependent on request type
 */
/* ECQ: Not sure why it is necessary to copy fields from the request structure.
 * This state machine is not itself nested and the only nested state machines
 * it calls are prelude_sm, pvfs2_msgpairarray_sm, and pvfs2_final_response_sm.
*/
static PINT_sm_action crdirent_setup_op(struct PINT_smcb *smcb,
                                        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t tmp_id;

    PINT_ACCESS_DEBUG(s_op, GOSSIP_SERVER_DEBUG,
                      "crdirent entry: %s points to %s\n", 
                      s_op->req->u.crdirent.name,
                      PVFS_OID_str(&s_op->req->u.crdirent.new_handle));
    
    js_p->error_code = 0;

    memset(&(s_op->u.crdirent.dirdata_ds_attr), 0, sizeof(PVFS_ds_attributes));
    memset(&s_op->u.crdirent.capability, 0, sizeof(PVFS_capability));

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "About to retrieve attributes for dirdata handle %s\n",
                 PVFS_OID_str(&s_op->req->u.crdirent.dirdata_handle));

    ret = job_trove_dspace_getattr(s_op->target_fs_id,
                                   s_op->req->u.crdirent.dirdata_handle,
                                   smcb,
                                   &(s_op->u.crdirent.dirdata_ds_attr),
                                   0,
                                   js_p,
                                   &tmp_id,
                                   server_job_context,
                                   s_op->req->hints);
    
    return ret;
}

/* crdirent_get_dist_dir_attr()
 * 
 * Retrieve basic distributed directory attributes for this dirent handle
 */
/* V3 distributed dir attributes are now part of the ds_attr struct and
 * are read during prelude so this lookup is obsolete
 */
static PINT_sm_action crdirent_get_dist_dir_attr(struct PINT_smcb *smcb,
                                                 job_status_s *js_p)
{   
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t j_id;
    
    /*
      first we translate the dirdata dspace attributes into a more convenient
      server use-able format.  i.e. a PVFS_object_attr
    */
    PVFS_objecct_attr_from_ds_attr(&s_op->u.crdirent.dirdata_attr,
                                   &s_op->u.crdirent.dirdata_ds_attr);
    s_op->u.crdirent.dirdata_attr.mask = PVFS_ATTR_COMMON_ALL;
    /* Must erase ATIME or it will be reset to the current time below,
     * which should not be done when creating a directory entry per
     * POSIX. */
    s_op->u.crdirent.dirdata_attr.mask &= ~PVFS_ATTR_COMMON_ATIME;

    /* set up key and value structures for reading the dist_dir_attr */
    s_op->key.buffer = Trove_Common_Keys[DIST_DIR_ATTR_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[DIST_DIR_ATTR_KEY].size;
    if(s_op->free_val)
    {   
        free(s_op->val.buffer);
    }
    
    s_op->val.buffer = &s_op->attr.u.dirdata.dist_dir_attr;
    s_op->val.buffer_sz = sizeof(PVFS_dist_dir_attr);
    s_op->free_val = 0;
    
    js_p->error_code = 0;
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "  trying to read dist_dir_attr (coll_id = %d, "
                 "handle = %s, key = %s (%d), val_buf = %p (%d))\n",
                 s_op->req->u.crdirent.fs_id,
                 PVFS_OID_str(&s_op->u.crdirent.dirent_handle),
                 (char *)s_op->key.buffer, s_op->key.buffer_sz,
                 s_op->val.buffer, s_op->val.buffer_sz);
    
    ret = job_trove_keyval_read(s_op->req->u.crdirent.fs_id,
                                s_op->u.crdirent.dirent_handle,
                                &s_op->key,
                                &s_op->val,
                                0,
                                NULL,
                                smcb,
                                0,
                                js_p,
                                &j_id,
                                server_job_context,
                                s_op->req->hints);
    
    return ret;
}
#endif

/* crdirent_get_bitmap_and_dirdata_handles()
 * 
 * Retrieve the rest of the distributed directory attributes for this
 * dirent handle.  If we created a new object, it should already have
 * these, so we need to test for that.
 * V3 - size is now read with ds_attr by prelude
 */
static PINT_sm_action crdirent_get_bitmap_and_dirdata_handles(
                                              struct PINT_smcb *smcb,
                                              job_status_s *js_p)
{   
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL, i = 0;
    PVFS_object_attr *attr_p = NULL;
    job_id_t j_id;

    PINT_ACCESS_DEBUG(s_op, GOSSIP_SERVER_DEBUG,
                      "crdirent entry: %s points to %s\n", 
                      s_op->req->u.crdirent.name,
                      PVFS_OID_str(&s_op->req->u.crdirent.new_ref.handle));
    
    js_p->error_code = 0;

    /* dirdata attributes are in s_op->attr
     */

    /* slot for later updating dirdata attributes */
    memset(&(s_op->u.crdirent.dirdata_ds_attr), 0, sizeof(PVFS_ds_attributes));
    memset(&s_op->u.crdirent.capability, 0, sizeof(PVFS_capability));

    /* New target object was just created and so 
     * bitmap and dirdata_handles are already in memory
     * Techically the parent_attr which is part of req also has
     * this, regardless if it is new, so we should never actually
     * need to read this, if we believe the dir and dirdatas are
     * consistent (might not want to do that).  Also we might
     * want to eliminate some this data from the req once we know
     * all of the dirdata are created (not sure how) so for now I'm
     * leaving this here.
     */
    /* if(s_op->u.crdirent.new_target_object) */
    if(s_op->new_target_object) /* set in prelude */
    {
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    /* this is either the attr just read by prelude
     */
    attr_p = &s_op->attr;

    assert(attr_p->u.dirdata.dist_dir_attr.dirdata_count > 0 &&
           attr_p->u.dirdata.dist_dir_attr.bitmap_size > 0);

    gossip_debug(GOSSIP_SERVER_DEBUG,
            "crdirent: get dist-dir-attr for dirdata handle %s "
            "with tree_height=%d, dirdata_count=%d, bitmap_size=%d, "
            "split_size=%d, server_no=%d and branch_level=%d\n",
            PVFS_OID_str(&s_op->req->u.crdirent.parent_attr.u.dir.dirdata_handles[
                          s_op->req->u.crdirent.dd_server_index]),
            attr_p->u.dirdata.dist_dir_attr.tree_height,
            attr_p->u.dirdata.dist_dir_attr.dirdata_count,
            attr_p->u.dirdata.dist_dir_attr.bitmap_size,
            attr_p->u.dirdata.dist_dir_attr.split_size,
            attr_p->u.dirdata.dist_dir_attr.server_no,
            attr_p->u.dirdata.dist_dir_attr.branch_level);

    /* allocate space for bitmap and dirdata handles */
    attr_p->u.dirdata.dist_dir_bitmap =
                malloc(attr_p->u.dirdata.dist_dir_attr.bitmap_size *
                       sizeof(PVFS_dist_dir_bitmap_basetype));

    attr_p->u.dirdata.dirdata_handles = malloc(
                OSASZ(attr_p->u.dirdata.dist_dir_attr.dirdata_count, 
                      attr_p->u.dirdata.dist_dir_attr.sid_count));

    if(!attr_p->u.dirdata.dist_dir_bitmap || !attr_p->u.dirdata.dirdata_handles)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* set pointer for dirdata_sids */
    attr_p->u.dirdata.dirdata_sids =
               (PVFS_SID *)(attr_p->u.dirdata.dirdata_handles +
                            attr_p->u.dirdata.dist_dir_attr.dirdata_count);

    /* set up attr->mask */
    /* not sure this works any more, should have individual mask bits
     * besides, should wait until AFTER we read the data to set the bits
     */
    attr_p->mask |= PVFS_ATTR_DISTDIR_ATTR;

    /* total 2 keyvals, DIST_DIRDATA_BITMAP, DIST_DIRDATA_HANDLES */

    if (s_op->free_val)
    {
       free(s_op->val.buffer);
    }
    memset(&(s_op->key), 0, sizeof(s_op->key));
    memset(&(s_op->val), 0, sizeof(s_op->val));

    /* free up any leftover structures */
    for (i = 0; i < s_op->keyval_count; i++)
    {
        if (s_op->val_a && s_op->val_a[i].buffer && s_op->free_val)
        {
            free(s_op->val_a[i].buffer);
        }
    }
    if (s_op->val_a)
    {
        free(s_op->val_a);
        s_op->val_a = NULL;
    }
    if (s_op->key_a)
    {
        free(s_op->key_a);
        s_op->key_a = NULL;
    }
    if (s_op->error_a)
    {
       free(s_op->error_a);
       s_op->error_a = NULL;
    }
    s_op->free_val = 0;

   /* allocate space for keys and values */
   s_op->keyval_count = 2;
   s_op->key_a = s_op->val_a = NULL;
   s_op->error_a = NULL;

    s_op->key_a = calloc(s_op->keyval_count, sizeof(PVFS_ds_keyval));
    s_op->val_a = calloc(s_op->keyval_count, sizeof(PVFS_ds_keyval));
    s_op->error_a = calloc(s_op->keyval_count, sizeof(PVFS_error));
    if(! s_op->key_a || ! s_op->val_a || ! s_op->error_a)
    {
        gossip_lerr("Cannot allocate memory for key/val/error.\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->key_a[0].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].size;
    s_op->key_a[0].buffer = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].key;

    s_op->val_a[0].buffer_sz = attr_p->u.dirdata.dist_dir_attr.bitmap_size *
                               sizeof(PVFS_dist_dir_bitmap_basetype);
    s_op->val_a[0].buffer = attr_p->u.dirdata.dist_dir_bitmap;

    s_op->key_a[1].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].size;
    s_op->key_a[1].buffer = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].key;

    s_op->val_a[1].buffer_sz =
                   OSASZ(attr_p->u.dirdata.dist_dir_attr.dirdata_count, 
                         attr_p->u.dirdata.dist_dir_attr.sid_count);
    s_op->val_a[1].buffer = attr_p->u.dirdata.dirdata_handles;

    js_p->error_code = 0;
    ret = job_trove_keyval_read_list(s_op->req->u.crdirent.parent_ref.fs_id,
                                     s_op->req->u.crdirent.parent_attr.u.dir.dirdata_handles[
                                             s_op->req->u.crdirent.dd_server_index],
                                     s_op->key_a,
                                     s_op->val_a,
                                     s_op->error_a,
                                     s_op->keyval_count,
                                     0,
                                     NULL,
                                     smcb,
                                     0,
                                     js_p,
                                     &j_id,
                                     server_job_context,
                                     s_op->req->hints);

    return ret;
}

/*
 * Function: crdirent_validate
 *
 * Synopsis: verifies that entry name and object type is valid,
 *           entry name belongs to the right dirdata object.
 */
static PINT_sm_action crdirent_validate(struct PINT_smcb *smcb,
                                        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    char *ptr = NULL;
    int i = 0;
    unsigned char *c = NULL;
    PVFS_object_attr *attr_p = NULL;
    PVFS_dist_dir_hash_type dirdata_hash;
    int dirdata_server_index;
    
    /* Need to verify the return code of the read, if there was one
     * and should set attr->mask bits here, not up there.
     */
    
    /* This is either the attr read by prelude
     *    AND kv's read by previous state
     * OR the attr created for a new dirdata by prelude
     */
    attr_p = &s_op->attr;

    /* gossip bitmap, since jump from get_bitmap_and_dirdata_handles */
    gossip_debug(GOSSIP_SERVER_DEBUG, "crdirent: dist_dir_bitmap as:\n");

    for(i = attr_p->u.dirdata.dist_dir_attr.bitmap_size - 1; i >= 0 ; i--)
    {       
        c = (unsigned char *)(attr_p->u.dirdata.dist_dir_bitmap + i);
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     " i=%d : %02x %02x %02x %02x\n",
                     i, c[3], c[2], c[1], c[0]);
    }           
    gossip_debug(GOSSIP_SERVER_DEBUG, "\n");
    
    gossip_debug(GOSSIP_SERVER_DEBUG, "\t getattr: dirdata handles\n");
            
    for(i = 0; i < attr_p->u.dirdata.dist_dir_attr.dirdata_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "\t\tdirdata server %d: %s.\n",
                     i, PVFS_OID_str(&attr_p->u.dirdata.dirdata_handles[i]));
    }           
 
    /* verify name and handle are not NULL */
    if ((s_op->req->u.crdirent.name == NULL) ||
        (!PVFS_OID_cmp(&s_op->req->u.crdirent.parent_ref.handle,
                       &PVFS_HANDLE_NULL)))
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "  got crdirent for %s (with handle %s) in %s\n",
                 s_op->req->u.crdirent.name,
                 PVFS_OID_str(&s_op->req->u.crdirent.new_ref.handle),
                 PVFS_OID_str(&s_op->req->u.crdirent.parent_ref.handle));

    /* check for invalid characters (ie "/") in name */
    ptr = s_op->req->u.crdirent.name;
    while (*ptr != '\0' && *ptr != '/' )
    {
        ptr++;
    }

    if (*ptr != '\0')
    {
        /* This means that some external code responsible for
         * checking this name - either client-core or usrint or
         * something - has failed in its duty so we log a server
         * error and kick it out
         */
        /* found an invalid character -- report it and send error response */
        gossip_lerr("crdirent: error: invalid character (%s)"
                    "in name (%s); sending error response.\n",
                    ptr, s_op->req->u.crdirent.name);
        /* for parity with linux VFS, allow any character except / in 
         * filenames.   */
        
        js_p->error_code = -PVFS_EINVAL;

         /* Do not zero the scheduled_id, as this operation was
          * scheduled before we checked the filename */
        return SM_ACTION_COMPLETE;
    }

    /* we actually have several copies of the dd_server_index at this point.
     * one computed here, one in the request, one in the dirdata's attributes
     */
    /* make sure the entry belongs to this dirdata bucket */
    /* find the hash value and the dist dir bucket */
    dirdata_hash = PINT_encrypt_dirdata(s_op->req->u.crdirent.name);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "crdirent: encrypt dirent %s into hash value %llu.\n",
                 s_op->req->u.crdirent.name, llu(dirdata_hash));

    dirdata_server_index = PINT_find_dist_dir_bucket(
                                           dirdata_hash,
                                           &attr_p->u.dirdata.dist_dir_attr,
                                           attr_p->u.dirdata.dist_dir_bitmap);

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "crdirent: selecting bucket No.%d from dist_dir_bitmap.\n",
                 dirdata_server_index);

    if(dirdata_server_index != attr_p->u.dirdata.dist_dir_attr.server_no)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "crdirent: error: "
                     "WRONG dirdata object for the dirent! Returning error.\n");

        js_p->error_code = -PVFS_EAGAIN;
        return SM_ACTION_COMPLETE;
    }
    else
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "crdirent: Correct dirdata object!\n");
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/* V3: Need to write backpointer to bucket.
 * This is not related to the directory entry, and probably needs to
 * be done with the creation of the dirdata(bucket) in prelude.
 * The handle is the key. Need to think about how to store related SIDs.
 */

/*
 * Function: crdirent_write_dirent
 *
 * Params:   server_op *s_op, 
 *           job_status_s *js_p
 *
 * Pre:      s_op->u.crdirent.dirent_handle is the directory entry k/v space
 *           s_op->req->u.crdirent.name != NULL
 *           s_op->req->u.crdirent.new_ref.handle != NULL
 *
 * Post:     key/val pair stored
 *
 * Returns:  int
 *
 * Synopsis: We are now ready to store the name/handle/sid data into the k/v
 *           space for this dirdata's directory handles.
 */
static PINT_sm_action crdirent_write_dirent(struct PINT_smcb *smcb,
                                            job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t j_id;
    TROVE_ds_flags keyval_flags;

    /* DUMB ASSERT */
    /*
    assert(PVFS_OID_cmp(&s_op->req->u.crdirent.dirdata_handle,
                        &PVFS_HANDLE_NULL));
     */

    js_p->error_code = 0;

    /* Set up a temporary buffer to store the new handle and SIDs in db */
    /* Copy handle and SIDs in to the new buffer */

    s_op->u.crdirent.keyval_temp_store =
                  (PVFS_ID *)malloc(OSASZ(1, s_op->req->u.crdirent.new_ref.sid_count));

    s_op->u.crdirent.keyval_temp_store[0].oid =
                            s_op->req->u.crdirent.new_ref.handle;

    memcpy(&(s_op->u.crdirent.keyval_temp_store[1]),
           s_op->req->u.crdirent.new_ref.sid_array,
           SASZ(s_op->req->u.crdirent.new_ref.sid_count));

    /* This buffer came from one of two places, either phase two of
     * creating the directory space when we wrote the value back to
     * trove, or from the initial read from trove.
     *
     * WBL - not sure whose comment this is but I don't understand it,
     * maybe it was obviated by changes.  Probably get rid of it.
     */

    /* this is the name for the parent entry */
    s_op->key.buffer_sz = strlen(s_op->req->u.crdirent.name) + 1;
    s_op->key.buffer = s_op->req->u.crdirent.name;

    s_op->val.buffer_sz = OSASZ(1, s_op->req->u.crdirent.new_ref.sid_count);
    s_op->val.buffer = s_op->u.crdirent.keyval_temp_store;

    gossip_debug(GOSSIP_SERVER_DEBUG, "  writing new directory entry "
                 "for %s (handle = %s)\n",
                 s_op->req->u.crdirent.name,
                 PVFS_OID_str(&s_op->req->u.crdirent.new_ref.handle));

    gossip_debug(GOSSIP_SERVER_DEBUG," to dirdata dspace %s\n",
                 PVFS_OID_str(&s_op->req->u.crdirent.parent_attr.u.dir.dirdata_handles[
                               s_op->req->u.crdirent.dd_server_index]));

    keyval_flags = TROVE_SYNC;
        
    /* Specify that we want an error returned if the entry already exists.
     * This allows us to return an EEXIST error back to the client.
     * Does this error cause the HANDLE_COUNT to be incremented?  Need
     * to investigate.
     */
    keyval_flags |= TROVE_NOOVERWRITE;

    /* WBL - I really don't like this - we are automagically updating
     * something in the keyval, and it isn't clear at all where and when
     * this happens - understood that it is a little more efficient.
     * in V3 we keep dirent count in the dspace - we read the dspace
     * first anyway, and write it back anyway so it is no slower than
     * this.  I'm leaving this for the moment, but it needs to go!
     */
    /* Here is the deal - Trove will automatically increment or decrement
     * a value in a record used as a counter.  The Trove operation (in this
     * case a write, but also various flavors of delete) determins that a
     * call to dbpf_keyval_info_op() is warranted, Then that consults these
     * flags to see if TROVE_KEYVAL_HANDLE_COUNT was requested, and if so,
     * reads the counter, modifies it, and writes it.  The trove operation
     * also decides if it is an increment or decrement.  As of V3 (maybe
     * earlier) we have wanted to move this into the dspace record so it is
     * read and written as one - the dspace is read regardless, and usually
     * written, so it could save one or two DB writes.  Not sure how big a
     * deal that is, especially with LMDB.
     */
    /* We also want to keep track of the keyval entries added on this
     * handle, which allows us to get the size of the directory later
     */
    keyval_flags |= TROVE_KEYVAL_HANDLE_COUNT | TROVE_KEYVAL_DIRECTORY_ENTRY;

    ret = job_trove_keyval_write(s_op->req->u.crdirent.parent_ref.fs_id,
                                 s_op->req->u.crdirent.parent_attr.u.dir.dirdata_handles[
                                         s_op->req->u.crdirent.dd_server_index],
                                 &s_op->key,
                                 &s_op->val,
                                 keyval_flags,
                                 NULL,
                                 smcb,
                                 0,
                                 js_p,
                                 &j_id,
                                 server_job_context,
                                 s_op->req->hints);

    return ret;
}

/* What in the world is this?  The name says it is updating a "directory" attr
 * but we don't have a directory attribute here, only a dirdata.  We will need
 * to update the dirdata, but it isn't a good time since we don't know if we
 * must split or now, nor have we even incremented the dirent count and I
 * really don''t know what this UID/GID stuff is about!  This was already 
 * modified too update the dirdata attr, but I'm thinking we lose it
 * altogether for lack of need.
 */
#if 0
static PINT_sm_action crdirent_update_directory_attr(struct PINT_smcb *smcb,
                                                     job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t j_id;
    PVFS_object_attr tmp_attr, *tmp_attr_ptr = &tmp_attr;
    PVFS_object_attr *dirdata_attr = NULL;
    PVFS_ds_attributes *ds_attr = NULL;
    PVFS_uid uid;
    PVFS_gid group_array[PVFS_REQ_LIMIT_GROUPS];
    uint32_t num_groups;

    memset(&tmp_attr, 0, sizeof(PVFS_object_attr));
    dirdata_attr = &s_op->u.crdirent.dirdata_attr;

    /* I don't know why this UID/GID stuff is an issue.  My solution is to make
     * sure that these fields sre corect when an object is made, not when it is
     * used.  Obviously a scrubber could check this stuff.
     */
    /* map owner/group from credential if necessary */
    /* This should always be true due to crdirent_get_dist_dir_attr. */
    if (dirdata_attr->mask & (PVFS_ATTR_COMMON_UID|PVFS_ATTR_COMMON_GID) &&
        (dirdata_attr->owner == PVFS_UID_MAX || dirdata_attr->group == PVFS_GID_MAX))
    {
        js_p->error_code = PINT_map_credential(&s_op->req->u.crdirent.credential,
                                               &uid,
                                               &num_groups,
                                               group_array);

        if (js_p->error_code != 0)
        {
            gossip_err("%s: could not map credential: %d\n", __func__,
                         js_p->error_code);
            return SM_ACTION_COMPLETE;
        }

        /* map owner from credential */
        if ((dirdata_attr->mask & PVFS_ATTR_COMMON_UID) &&
            dirdata_attr->owner == PVFS_UID_MAX)
        {
            dirdata_attr->owner = uid;
        }

        /* map primary group from credential */
        if ((dirdata_attr->mask & PVFS_ATTR_COMMON_GID) &&
            dirdata_attr->group == PVFS_GID_MAX)
        {
            dirdata_attr->group = group_array[0];
        }
    }

    PVFS_object_attr_overwrite_setable(tmp_attr_ptr, dirdata_attr);
    ds_attr = &(s_op->u.crdirent.dirdata_ds_attr);
    PVFS_object_attr_to_ds_attr(tmp_attr_ptr, ds_attr);

    /* update timestamps for the dirdata handle. */
    ret = job_trove_dspace_setattr(s_op->req->u.crdirent.fs_id, 
                                   s_op->req->u.crdirent.dirdata_handle,
                                   ds_attr,
                                   TROVE_SYNC,
                                   smcb, 
                                   0, 
                                   js_p, 
                                   &j_id, 
                                   server_job_context, 
                                   s_op->req->hints);

    gossip_debug(GOSSIP_SERVER_DEBUG, " crdirent: update timestamp, type is %d\n ",
                     ds_attr->type);
    return ret;
}
#endif

/*
 * This state assumes we need to update the CTIME of the DIR who's dirent we just
 * wrote.  In V3 we have a choice, we can update the DIR, which may be local or
 * remote, or we can update DIRDATA which is always local.  This requires a read
 * of all DIRDATAs to get an correct value.  This is slow when reading the CTIME
 * but faster at create time.  For the moment we we update the DIR.
 *
 * CRDIRENT creates a directory entry, which is contained by a DIRDATA, which is a
 * sub object to a DIR.  By creating a directory entry this directory (DIR) has been
 * changed and thus its CTIME and dirent_countmust be updated.  
 * The reference to DIR is passed to the CRDIRENT as the parent_ref.
 *
 * This function checks to see if the metaobject (DIR) for the new dirent is local,
 * and if so initiates an update (by reading) otherwise, reads remotely.  Later state
 * writes back the update.
 * 
 * Is this already done by client?  Yes, but we have removed that.
 * Seems more efficient here.
 */
/* I HATE the use of metdahandle - this is the handle to a DIRECTORY, not a metafile.
 * Yes the DIRECTORY object is the "metadata" of the directory, but it gets confusing
 * so use DIR for directories and META for files.
 */
static PINT_sm_action crdirent_setup_read_parent_dir_attrs(struct PINT_smcb *smcb,
                                                           job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;

    /* check the result of dirent write to keyval */
    if (js_p->error_code != 0)
    {
        return SM_ACTION_COMPLETE;
    }
    /* write if dirent succeeded so increment dirent_count */
    /* note this only counts dirents in THIS dirdata */
    s_op->attr.u.dirdata.dirent_count += 1;

    /* Determine whether the parent dir handle is on the local server. */
    if (PINT_cached_config_server_local(&s_op->req->u.crdirent.parent_ref.sid_array[0]))
    {
        /* local */
        job_id_t tmp_id;

        /* Need to retrieve dspace attributes for the parent directory object.
         * We will then update the timestamp info. */
        gossip_debug(GOSSIP_SERVER_DEBUG, "About to retrieve attributes "
                     "for parent directory handle %s\n",
                     PVFS_OID_str(&s_op->req->u.crdirent.parent_ref.handle));

        memset(&(s_op->u.crdirent.parent_dir_ds_attr),
               0,
               sizeof(PVFS_ds_attributes));

        ret = job_trove_dspace_getattr(s_op->req->u.crdirent.parent_ref.fs_id,
                                       s_op->req->u.crdirent.parent_ref.handle,
                                       smcb,
                                       &(s_op->u.crdirent.parent_dir_ds_attr),
                                       0,
                                       js_p,
                                       &tmp_id,
                                       server_job_context,
                                       s_op->req->hints);

        return ret;
    }
    else
    {
        /* remote */
        gossip_debug(GOSSIP_SERVER_DEBUG, "About to send setattr "
                     "request for directory metadata handle %s\n",
                     PVFS_OID_str(&s_op->req->u.crdirent.parent_ref.handle));
        /* if we get an error somewhere we will not take this jump */
        js_p->error_code = REMOTE_METAHANDLE;

        PINT_sm_msgpair_state *msg_p = NULL;
        PVFS_handle *capability_handles = NULL;
        PVFS_object_attr tmp_attr;

        PINT_msgpair_init(&s_op->msgarray_op);
        msg_p = &s_op->msgarray_op.msgpair;
        PINT_serv_init_msgarray_params(s_op, s_op->req->u.crdirent.fs_id);

        /* If we created a capability in crdirent_update_parent_dir_timestamp
         * we need to clean it up first. */
        PINT_cleanup_capability(&s_op->u.crdirent.capability);

        /* This memory will be freed in either crdirent_cleanup or
         * crdirent_find_split_entries by PINT_cleanup_capability. */
        capability_handles = malloc(sizeof(PVFS_handle));

        if (! capability_handles)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }

        capability_handles[0] = s_op->req->u.crdirent.parent_ref.handle;
        ret = PINT_server_to_server_capability(&s_op->u.crdirent.capability,
                                               s_op->req->u.crdirent.parent_ref.fs_id,
                                               1,
                                               capability_handles);
        if (ret != 0)
        {
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }
        /* The only thing we need to change is CTIME, so all we have to
         * do is set that flag in the representation of the attributes
         * we want to change. */
        memset(&tmp_attr, 0, sizeof(PVFS_object_attr));
        tmp_attr.mask = PVFS_ATTR_COMMON_CTIME; /* set time to remote server time */
        /* update dirent_count on DIR which sums all dirdata for this dir */
        tmp_attr.u.dir.dirent_count = 
            s_op->req->u.crdirent.parent_attr.u.dir.dirent_count + 1;
        tmp_attr.mask |= PVFS_ATTR_DIR_DIRENT_COUNT;

        /* Capability was initialized earlier. */
        PINT_SERVREQ_SETATTR_FILL(msg_p->req,
                                  PVFS_REQ_DIRDATA,
                                  s_op->u.crdirent.capability,
                                  s_op->req->u.crdirent.credential,
                                  s_op->req->u.crdirent.parent_ref.fs_id,
                                  s_op->req->u.crdirent.parent_ref.handle,
                                  s_op->req->u.crdirent.parent_ref.sid_count,
                                  s_op->req->u.crdirent.parent_ref.sid_array,
                                  tmp_attr,
                                  s_op->req->hints);

        msg_p->msgclass = PVFS_IO_METADATA;
        msg_p->msgdir = PVFS_IO_WRITE;
        msg_p->fs_id = s_op->req->u.crdirent.parent_ref.fs_id;
        msg_p->handle = s_op->req->u.crdirent.parent_ref.handle;
        msg_p->sid_count = s_op->req->u.crdirent.parent_ref.sid_count;
        msg_p->sid_index = 0;
        msg_p->sid_array = s_op->req->u.crdirent.parent_ref.sid_array;
        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
        msg_p->comp_fn = NULL;

        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "setting timestamps for directory handle %s\n"
                     "               SID %s\n",
                     PVFS_OID_str(&msg_p->handle),
                     PVFS_SID_str(&s_op->req->u.crdirent.parent_ref.sid_array[0])
                     );

        ret = PVFS_SID_get_addr(&msg_p->svr_addr,
                                &s_op->req->u.crdirent.parent_ref.sid_array[0]);
        if (ret)
        {
            gossip_err("Failed to map dirdata server address\n");
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }

        /* ready to submit the requests */
        PINT_sm_push_frame(smcb, 0, &s_op->msgarray_op);
        return SM_ACTION_COMPLETE;
    }

   return ret;
}

/* Like the last function, this function is part of the system for
 * updating the metadata (DIR) timestamp because we are adding a dirent
 * to it - which is a "change" CTIME.  I think the handle used may be
 * wrong, in any event I'm not clear on it.  WBL
 * THis function writes back the new_ref's dspace if it is local to this node.
 */
/* and it should be dir handle, not parent_dir - meta implies file */
static PINT_sm_action crdirent_complete_read_local_parent_dir_attrs(struct PINT_smcb *smcb,
                                                                    job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t j_id;
    int ret = -1;

    /* PVFS_object_attr tmp_attr, *tmp_attr_ptr = &tmp_attr;
     */
    PVFS_ds_attributes *ds_attr = NULL;

    PVFS_ds_attr_to_object_attr(&s_op->u.crdirent.parent_dir_ds_attr,
                                &s_op->u.crdirent.parent_dir_attr);

    /* WHAT????? What the hell is going on here???? 
     * Why are we re-writing an objects attribute mask?
     */
    /* s_op->u.crdirent.parent_dir_attr.mask = PVFS_ATTR_COMMON_ALL |
                                            PVFS_ATTR_META_ALL;
     */

    /* The only thing we need to change is CTIME, so all we have to
     * do is set that flag in the representation of the attributes
     * we want to change. */
    /* memset(&tmp_attr, 0, sizeof(PVFS_object_attr));
    tmp_attr.mask = PVFS_ATTR_COMMON_CTIME;
     */

    /* This is a crappy way to do this - Much better to have a function
     * that simply processes the time attributes and doesn.t mess with owner,
     * group, etc.  This old function should go!!!
     */
    /* PVFS_object_attr_overwrite_setable(&s_op->u.crdirent.parent_dir_attr,
                                       tmp_attr_ptr);
     */

    /* following mask flag of "CTIME" does not look att this */
    /* s_op->u.crdirent.parent_dir_attr.ctime = PINT_util_get_current_time(); */
    s_op->u.crdirent.parent_dir_attr.mask |= (PVFS_ATTR_COMMON_CTIME |
                                              PVFS_ATTR_DIR_DIRENT_COUNT);
    /* update dirent_count on parent dir - not same as dirdata */
    s_op->u.crdirent.parent_dir_attr.u.dir.dirent_count++;
    ds_attr = &(s_op->u.crdirent.parent_dir_ds_attr);
    PVFS_object_attr_to_ds_attr(&s_op->u.crdirent.parent_dir_attr, ds_attr);

    /* the parent (dir) of the current object (dirdata) is in parent_ref
     */
    ret = job_trove_dspace_setattr(s_op->req->u.crdirent.parent_ref.fs_id,
                                   s_op->req->u.crdirent.parent_ref.handle,
                                   ds_attr,
                                   TROVE_SYNC,
                                   smcb,
                                   0,
                                   js_p,
                                   &j_id,
                                   server_job_context,
                                   s_op->req->hints);

    return ret;
}

#if 0
/*
 * Function: crdirent_get_dirent_count
 */
static PINT_sm_action crdirent_get_dirent_count(struct PINT_smcb *smcb,
                                                job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t tmp_id;

    ret = job_trove_keyval_get_handle_info(s_op->req->u.crdirent.fs_id,
                                           s_op->req->u.crdirent.dirdata_handle,
                                           TROVE_KEYVAL_HANDLE_COUNT,
                                           &s_op->u.crdirent.keyval_handle_info,
                                           smcb,
                                           0,
                                           js_p,
                                           &tmp_id,
                                           server_job_context,
                                           s_op->req->hints);

    return ret;
}
#endif

/*
 * Function: crdirent_check_for_split
 */
static PINT_sm_action crdirent_check_for_split(struct PINT_smcb *smcb,
                                               job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;
    PVFS_object_attr *attr_p = NULL;
    unsigned char *c = NULL;

    PINT_ACCESS_DEBUG(s_op,
                      GOSSIP_ACCESS_DEBUG,
                      "crdirent entry: %s points to %s\n",
                      s_op->req->u.crdirent.name,
                      PVFS_OID_str(&s_op->req->u.crdirent.new_ref.handle));

    /* dirent count is in attrs */
    if (js_p->error_code != 0)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "write of new dirent failed.\n");
        PVFS_perror_gossip("retrieval of dirent count failed",
                           js_p->error_code);
        return SM_ACTION_COMPLETE;
    }

    /* this is done in update_metadata_timestamp don't do it twice */
    /* write of dirent succeeded, so increment dirent_count */
    /* s_op->attr.u.dirdata.dirent_count++; */

    gossip_debug(GOSSIP_SERVER_DEBUG, " dirent count = %d "
                 "split_size =%d, branch_level = %d\n",
                 /* s_op->u.crdirent.keyval_handle_info.count, */
                 s_op->attr.u.dirdata.dirent_count,
                 s_op->attr.u.dirdata.dist_dir_attr.split_size,
                 s_op->attr.u.dirdata.dist_dir_attr.branch_level);

    /* if (s_op->u.crdirent.keyval_handle_info.count >= */
    if (s_op->attr.u.dirdata.dirent_count >=
        s_op->attr.u.dirdata.dist_dir_attr.split_size)
    {
        /* Determine which node will get split entries. */
        s_op->u.crdirent.split_node = PINT_find_dist_dir_split_node(
                                          &s_op->attr.u.dirdata.dist_dir_attr,
                                          s_op->attr.u.dirdata.dist_dir_bitmap);

        if (s_op->u.crdirent.split_node < 0)
        {
            /* No new node can be found. No need to split. */
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         " No new node found for split.\n");
            return SM_ACTION_COMPLETE;
        }

        js_p->error_code = SPLIT_REQUIRED;

        /* Save the current attrs in case we have 
         * to back out due to an error.
         */
        PINT_copy_object_attr(&s_op->u.crdirent.saved_attr, &s_op->attr);

        gossip_debug(GOSSIP_SERVER_DEBUG,
                     " split to node %d, new branch_level = %d\n",
                     s_op->u.crdirent.split_node,
                     s_op->attr.u.dirdata.dist_dir_attr.branch_level);
                     gossip_debug(GOSSIP_SERVER_DEBUG,
                     "crdirent: new dist_dir_bitmap as:\n");

        attr_p = &s_op->attr;
        for(i = attr_p->u.dirdata.dist_dir_attr.bitmap_size - 1; i >= 0 ; i--)
        {
            c = (unsigned char *)(attr_p->u.dirdata.dist_dir_bitmap + i);
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         " i=%d : %02x %02x %02x %02x\n",
                         i, c[3], c[2], c[1], c[0]);
        }
        gossip_debug(GOSSIP_SERVER_DEBUG, "\n");
    }
    return SM_ACTION_COMPLETE;
}

/*
 * Function: crdirent_update_dirdata_attr
 *
 * Write dirdata metadata to dspace, with updated time stamps and dirent
 * count and anything else modified after the crdirent and split if
 * there is one
 */
static PINT_sm_action crdirent_update_dirdata_attr(struct PINT_smcb *smcb,
                                                   job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t j_id;
    PVFS_object_attr *dspace_attr = NULL;
    PVFS_ds_attributes *ds_attr = NULL;

    /* dirdata attributes are in s_op->attr
     * Set Ctime and Mtime
     * If we had a split assume tree_height was updated
     * If we had a split then in the next state write back the bitmap
     */

    /* This contains the attrs read from the dirdata object */
    dspace_attr = &s_op->attr;

    /* This is a buffer for the ds_attrs */
    ds_attr = &(s_op->u.crdirent.dirdata_ds_attr);
    memset(ds_attr, 0, sizeof(PVFS_ds_attributes));

    /* do these need to be updated, or only if no a new object? */
    dspace_attr->ctime = time(NULL);
    dspace_attr->mtime = dspace_attr->ctime;

    /* copy and convert format */
    PVFS_ds_attr_from_object_attr(ds_attr, dspace_attr);

    /* dspace setattr simply writes all attr in ds_attr so any
     * mask effects must be handled before we write
     */
    /* update timestamps for the dirdata handle. */
    ret = job_trove_dspace_setattr(s_op->req->u.crdirent.parent_ref.fs_id,
                                   s_op->req->u.crdirent.parent_attr.u.dir.dirdata_handles[
                                           s_op->req->u.crdirent.dd_server_index],
                                   ds_attr,
                                   TROVE_SYNC,
                                   smcb,
                                   0,
                                   js_p,
                                   &j_id,
                                   server_job_context,
                                   s_op->req->hints);

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 " crdirent: update timestamp, type is %d\n ",
                 ds_attr->type);
    return ret;
}

/*
 * Function: crdirent_cleanup
 */
static PINT_sm_action crdirent_cleanup(struct PINT_smcb *smcb,
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;

    if (s_op->u.crdirent.read_all_directory_entries)
    {
        if (s_op->u.crdirent.entries_key_a)
        {
            free(s_op->u.crdirent.entries_key_a);
            s_op->u.crdirent.entries_key_a = NULL;
            s_op->u.crdirent.entries_val_a = NULL;
            s_op->u.crdirent.read_all_directory_entries = 0;
        }
    }
    if (s_op->free_val)
    {
       free(s_op->val.buffer);
    }
    if (s_op->u.crdirent.keyval_temp_store)
    {
        free(s_op->u.crdirent.keyval_temp_store);
    }

    memset(&(s_op->key),0,sizeof(s_op->key));
    memset(&(s_op->val),0,sizeof(s_op->val));

    for (i = 0; i < s_op->keyval_count; i++)
    {
        if (s_op->val_a && s_op->val_a[i].buffer && s_op->free_val)
        {
            free(s_op->val_a[i].buffer);
        }
    }
    if (s_op->val_a)
    {
        free(s_op->val_a);
        s_op->val_a = NULL;
    }
    if (s_op->key_a)
    {
        free(s_op->key_a);
        s_op->key_a = NULL;
    }
    if (s_op->error_a)
    {
       free(s_op->error_a);
       s_op->error_a = NULL;
    }
    s_op->free_val = 0;

    PINT_free_object_attr(&s_op->attr);
    PINT_free_object_attr(&s_op->u.crdirent.saved_attr);

    if (s_op->u.crdirent.entry_handles)
    {
        free(s_op->u.crdirent.entry_handles);
    }
    if (s_op->u.crdirent.entry_names)
    {
        free(s_op->u.crdirent.entry_names);
    }
    if (s_op->u.crdirent.msg_boundaries)
    {
        free(s_op->u.crdirent.msg_boundaries);
    }
    if (s_op->u.crdirent.split_status)
    {
        free(s_op->u.crdirent.split_status);
    }
    if (s_op->u.crdirent.dist)
    {
        PINT_dist_free(s_op->u.crdirent.dist);
    }
    if (s_op->u.crdirent.remote_dirdata_handles)
    {
        free(s_op->u.crdirent.remote_dirdata_handles);
    }

    PINT_cleanup_capability(&s_op->u.crdirent.capability);

    return(server_state_machine_complete(smcb));
}

/*
 * Function: perm_crdirent
 */
static int perm_crdirent(PINT_server_op *s_op)
{
    int ret;

    if (s_op->req->capability.op_mask & PINT_CAP_WRITE && 
        s_op->req->capability.op_mask & PINT_CAP_EXEC)
    {
        ret = 0;
    }
    else
    {
        ret = -PVFS_EACCES;
    }

    return ret;
}

static int PINT_get_object_ref_crdirent(struct PVFS_server_req *req,
                                        PVFS_fs_id *fs_id,
                                        PVFS_handle *handle) 
{                                    
    *fs_id = req->u.crdirent.parent_ref.fs_id; 
    *handle = req->u.crdirent.parent_attr.u.dir.dirdata_handles[
                      req->u.crdirent.dd_server_index];
    return 0;                       
}

static void crdirent_get_ctrl(struct PVFS_server_req *req,
                              struct PINT_server_req_ctrl *ctrl)
{
   /* this sets up a standard replication */
   /* generates a request to each of sid_count SIDs */
   /* all with the same UUID */

   /* We are replicating the dirdata information for a 
    * directory entry
    */

   ctrl->fs_id     = req->u.crdirent.parent_ref.fs_id;
   ctrl->handles   = &req->u.crdirent.parent_attr.u.dir.dirdata_handles[
                              req->u.crdirent.dd_server_index];
   ctrl->count     = 1; /* is this right? need to understand better */
   ctrl->sids      = &req->u.crdirent.parent_attr.u.dir.dirdata_sids[
                              req->u.crdirent.dd_sid_index];
   ctrl->sid_count = req->u.crdirent.parent_attr.meta_sid_count;
}

PINT_GET_CREDENTIAL_DEFINE(crdirent);

struct PINT_server_req_params pvfs2_crdirent_params =
{
    .string_name    = "crdirent",
    .perm           = perm_crdirent,
    .access_type    = PINT_server_req_modify,
    .sched_policy   = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_crdirent,
    .get_credential = PINT_get_credential_crdirent,
    .get_ctrl       = crdirent_get_ctrl,
    .state_machine  = &pvfs2_crdirent_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
