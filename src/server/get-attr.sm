/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 *
 * Changes by Acxiom Corporation to add dirent_count field to attributes
 * Copyright Â© Acxiom Corporation, 2005.
 */

/* pvfs2_get_attr_sm
 *
 * This state machine handles incoming server getattr operations.  These
 * are the operations sent by PVFS_sys_getattr() among others.
 *
 * The pvfs2_prelude_sm is responsible for reading the actual metadata
 * to begin with, because it does this as part of the permission checking
 * process.
 */

#include <string.h>
#include <assert.h>

#include "pvfs2-config.h"
#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-types-debug.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pvfs2-internal.h"
#include "pint-cached-config.h"
#include "pint-security.h"
#include "security-util.h"
#include "pint-uid-map.h"
#include "check.h"
#include "capcache.h"

/* this was defined as a handle const - we have those in pvfs2-handle.h */
/* static uint64_t UINT64_HIGH = 0xffffffffffffffffULL; */

#if defined(ENABLE_SECURITY_KEY) || defined(ENABLE_SECURITY_CERT)
#define ENABLE_SECURITY_MODE
#endif

/* New facility for dealing with keyval buffers.
 * Defined in pvfs2-server.c/h
 */

#define KEEP_BUFFER(buf)                          \
    keep_keyval_buffers(s_op, buf);


/* This was moved to src/server/pvfs2-server.c so it is
 * visible across the server code
 */
#if 0
/* These are defined in src/common/misc/pvfs2-internal.h
 * This table SHOULD be defined using macros not the strings
 * See Trove_Common_Keys in src/server/pvfs2-server.c
 * This should be fixed as soon as possible
 */

PINT_server_trove_keys_s Trove_Special_Keys[] =
{
    {"user.pvfs2.dist_name"     , SPECIAL_DIST_NAME_KEYLEN},
    {"user.pvfs2.dist_params"   , SPECIAL_DIST_PARAMS_KEYLEN},
    {"user.pvfs2.num_dfiles"    , SPECIAL_NUM_DFILES_KEYLEN},
    {"user.pvfs2.layout"        , SPECIAL_LAYOUT_KEYLEN},
    {"user.pvfs2.server_list"   , SPECIAL_SERVER_LIST_KEYLEN},
    {"user.pvfs2.meta_hint"     , SPECIAL_METAFILE_HINT_KEYLEN},
    {"user.pvfs2.mirror.copies" , SPECIAL_MIRROR_COPIES_KEYLEN},
    {"user.pvfs2.mirror.handles", SPECIAL_MIRROR_HANDLES_KEYLEN},
    {"user.pvfs2.mirror.status" , SPECIAL_MIRROR_STATUS_KEYLEN},
};
#endif

enum
{
    STATE_METAFILE   = 7,
    STATE_SYMLINK    = 9,
    STATE_DIR        = 10,
    STATE_DIR_HINT   = 11,
    STATE_DONE       = 12,
    SKIP_NEXT_STATE  = 13,
    STATE_CAPABILITY = 14,
    STATE_DIRDATA    = 15,
    STATE_DATA_SIZE  = 16,
};

static void free_nested_getattr_data(struct PINT_server_op *s_op);

%%

nested machine pvfs2_get_attr_work_sm
{
    state verify_attribs
    {
        run getattr_verify_attribs;
        STATE_SYMLINK => read_symlink_keyvals;
        STATE_METAFILE => read_metafile_keyvals;
        STATE_DIR => read_directory_keyvals;
        default => setup_resp;
        /* STATE_DIR => get_dist_dir_attr; */
        /* STATE_DIRDATA => get_dirent_count; */
    }

/* SYMLINK */

    state read_symlink_keyvals
    {
        run getattr_read_symlink_keyvals;
        default => check_if_capability_required;
    }

/* METAFILE */

    state read_metafile_keyvals
    {
        run getattr_read_metafile_keyvals;
        success => metafile_keyvals_verify;
        default => check_if_capability_required;
    }

    state metafile_keyvals_verify
    {
        run getattr_metafile_keyvals_verify;
        default => check_if_capability_required;
    }

/* DIRECTORY */

    state read_directory_keyvals
    {
        run getattr_read_directory_keyvals;
        success => get_dir_hint;
        default => check_if_capability_required;
    }

    state get_dir_hint
    {
        run getattr_get_dir_hint;
        STATE_DONE => check_if_capability_required;
        default => interpret_dir_hint;
    }

    state interpret_dir_hint
    {
        run getattr_interpret_dir_hint;
        default => check_if_capability_required;
    }

/* PERMISSIONS */

    state check_if_capability_required
    {
        run getattr_check_if_capability_required;
        STATE_CAPABILITY => read_acl;
        default => setup_resp;
    }

    state read_acl
    {
        run getattr_read_acl;
        default => create_capability;
    }

    state create_capability
    {
        run getattr_create_capability;
        default => setup_resp;
    }

    state setup_resp
    {
        run getattr_setup_resp;
        default => return;
    }
}

nested machine pvfs2_get_attr_with_prelude_sm
{
    state init
    {
        run getattr_with_prelude_init;
        default => prelude;
    }

    state prelude
    {
        jump pvfs2_prelude_sm;
        success => setup_op;
        default => return;
    }

    state setup_op
    {
        run getattr_setup_op;
        default => do_work;
    }

    state do_work
    {
        jump pvfs2_get_attr_work_sm;
        default => return;
    }
}

nested machine pvfs2_get_attr_sm
{
    state work
    {
        jump pvfs2_get_attr_with_prelude_sm;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run getattr_cleanup;
        default => terminate;
    }
}

%%



/* getattr_verify_attribs()
 *
 * We initialize the attribute mask that will be returned in this
 * function.  This mask can be augmented in some of the other states.
 */
static PINT_sm_action getattr_verify_attribs(struct PINT_smcb *smcb,
                                             job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *respattr = NULL;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    js_p->error_code = 0;

    /*
     * explicitly copy basic attributes structure (read in from the
     * prelude.sm for the matching dspace) into response to be sent
     * back to the client.  this is mostly for readability here to be
     * sure we know which fields are valid in the response at this
     * point. - NOW done in bulk because it is much more likely that we
     * fail to add new fields than have a hard time understanding the
     * fields.
    */
    respattr = &s_op->resp.u.getattr.attr;
    memset(respattr, 0, sizeof(PVFS_object_attr));

    /* We are using this routine (which normally would be hidden) because
     * the attr we are copying from was just read from dspace and it has
     * none of its veriable length fields yet.  If we try  to copy the
     * var fields we will get a seg fault, so only copy the fixed size
     * fields.
     */
    PINT_copy_object_attr_fixed(respattr, &s_op->attr);

    /* this apparently needs a special computation */
    /* respattr->mtime = PINT_util_mkversion_time(s_op->attr.mtime); */
    /* PINT_coy_object_attr_fixed should do this now */
    /* respattr->mtime = s_op->attr.mtime;  */
#if 0
    if (respattr->mtime == 0)
    {
        /*
         * this is a compatibility hack to allow existing storage
         * spaces to be automagically converted to this versioned time
         * on-disk format slowly over time and doing the right thing in
         * the meantime
         */
        respattr->mtime = s_op->attr.mtime;

        gossip_debug(GOSSIP_GETATTR_DEBUG, " No version found!  Using "
                     "mtime %llu\n", llu(respattr->mtime));
    }
    else
    {
        gossip_debug(
            GOSSIP_GETATTR_DEBUG, " VERSION is %llu, mtime is %llu\n",
            llu(s_op->attr.mtime), llu(respattr->mtime));
    }
#endif

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "+  _DSPACE_ retrieved attrs:\n"
                 "\t\t[Type = %s(%d),\n"
                 "\t\tfs_id:%d,\n"
                 "\t\tOID: %s,\n"
                 "\t\tmask = 0x%lx, owner = %d,\n"
                 "\t\tgroup = %d, perms = %o,\n"
                 "\t\tatime = %llu, mtime = %llu,\n"
                 "\t\tctime = %llu, ntime = %llu,\n"
                 "\t\tmeta_sid_count = %d]\n",
                 PVFS_ds_type_to_string(respattr->objtype),
                 respattr->objtype,
                 s_op->ds_attr.fs_id,
                 PVFS_OID_str(&s_op->ds_attr.handle),
                 respattr->mask,
                 respattr->owner,
                 respattr->group,
                 respattr->perms,
                 llu(respattr->atime),
                 llu(respattr->mtime),
                 llu(respattr->ctime),
                 llu(respattr->ntime),
                 respattr->meta_sid_count);

    /*
     * weed out the attr mask of the response based on what the client
     * request asked for.  also, check if we need to retrieve more
     * information before returning the response to the client (by
     * guiding the state machine to get it).
     *
     * we can safely do this now that we have the type of the object
     * (read in from the dspace, not stored in the respattr), and we
     * have the original client request attr mask
     * (s_op->u.getattr.attrmask).
     */
    switch(respattr->objtype)
    {
        case PVFS_TYPE_METAFILE:
            PINT_ACCESS_DEBUG(s_op, GOSSIP_GETATTR_DEBUG, "type: metafile\n");
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "  Req handle %s refers to a metafile\n",
                         PVFS_OID_str(&s_op->u.getattr.handle));

    #if 0
            //respattr->u.meta.dfile_count = s_op->attr.u.meta.dfile_count;
            //respattr->u.meta.dist_size = s_op->attr.u.meta.dist_size;
            if (s_op->u.getattr.attrmask & PVFS_ATTR_META_DFILES)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " dspace has dfile_count of %d\n",
                             respattr->u.meta.dfile_count);
                respattr->mask |= PVFS_ATTR_META_DFILES;
            }
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG, " client doesn't want "
                             "dfile info, clearing response attr mask\n");
                respattr->mask &= ~PVFS_ATTR_META_DFILES;
            }

            if (s_op->u.getattr.attrmask & PVFS_ATTR_META_DIST)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " dspace has dist size of %d\n",
                             respattr->u.meta.dist_size);

                respattr->mask |= PVFS_ATTR_META_DIST;
            }
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG, " client doesn't want "
                             "dist info, clearing response attr mask\n");

                respattr->mask &= ~PVFS_ATTR_META_DIST;
            }

            if (s_op->u.getattr.attrmask & PVFS_ATTR_META_MIRROR_DFILES)
            {
               gossip_debug(GOSSIP_GETATTR_DEBUG,"client wants mirrored "
                                                 "handles.\n");
               respattr->mask |= PVFS_ATTR_META_MIRROR_DFILES;
               //respattr->u.meta.mirror_copies_count = 0;
               //respattr->u.meta.mirror_dfile_array  = NULL;
            }
            else
            {
               gossip_debug(GOSSIP_GETATTR_DEBUG,"client doesn't want "
                                                 "mirrored handles.\n");
               respattr->mask &= ~(PVFS_ATTR_META_MIRROR_DFILES);
            }
    #endif


            gossip_debug(
                GOSSIP_GETATTR_DEBUG,
                "\n\t\t[dfile_count = %d, sid_count = %d,\n"
                "\t\tdist_size = %d, mirror_mode = %d\n"
                "\t\tfile_size = %d, flags = %d]\n",
                (int)respattr->u.meta.dfile_count,
                (int)respattr->u.meta.sid_count,
                (int)respattr->u.meta.dist_size,
                (int)respattr->u.meta.mirror_mode,
                (int)respattr->u.meta.size,
                (int)respattr->u.meta.flags);

            /* respattr->mask |= PVFS_ATTR_META_ALL; */
            js_p->error_code = STATE_METAFILE;
            break;

        case PVFS_TYPE_DATAFILE:
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: datafile\n");
            /*
             * note: the prelude already retrieved the size for us, so
             * there's no special action that needs to be taken if we have
             * a datafile here (other than adjusting our mask to include
             * the data information and copying the retrieved size from the
             * ds_attribute the prelude used)
             */
            /* size should have been copied, if not fix in copy routine */
            //respattr->u.data.size = s_op->ds_attr.u.datafile.b_size;

            gossip_debug(GOSSIP_GETATTR_DEBUG, "  handle %s refers to "
                         "a datafile (size = %lld).\n",
                         PVFS_OID_str(&s_op->u.getattr.handle),
                         lld(respattr->u.data.size));

            /* respattr->mask |= PVFS_ATTR_DATA_ALL; */
            js_p->error_code = 0;
            break;


        case PVFS_TYPE_DIRECTORY:
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: directory\n");

            /* We need some of this error checking back, but the bit
             * flipping going on does not seem right.  Need a careful
             * review of this.
             */
#if 0
            /* check for Distdir struct */
            if (s_op->u.getattr.attrmask & PVFS_ATTR_DISTDIR_ATTR)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " getattr: distdir_struct needed.\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
                respattr->mask |= PVFS_ATTR_DISTDIR_ATTR;
                js_p->error_code = STATE_DIR;
            }   
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " getattr: distdir_struct not needed.\n");
                js_p->error_code = 0;
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
            }   

            /* Check for Dirdata handles */
            if (s_op->u.getattr.attrmask & PVFS_ATTR_DIR_DIRDATA)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dirdata_handles needed.\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
                respattr->mask |= PVFS_ATTR_DIR_DIRDATA;
                js_p->error_code = STATE_DIR;
            }
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dirdata_handles not needed\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
            }

#if 0  
  /* Becky:  removing check for dirent_count.  ASSUMPTION:for a directory type, at most, we
   * return the bitmap and dirdata handles from keyval db along with data from the 
   * PVFS_TYPE_DIRECTORY dspace record.  dirent_count is only retrieved when we
   * are processing a PVFS_TYPE_DIRDATA dspace record.
   */
            /* Check for Dirent Count */
            if (s_op->u.getattr.attrmask & PVFS_ATTR_DIR_DIRENT_COUNT)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dirent_count needed.\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
                respattr->mask |= PVFS_ATTR_DIR_DIRENT_COUNT;
                js_p->error_code = STATE_DIR;
            }
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dirent_count not needed\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
            }

#endif

            /* check fir Dir Hints */
            if (s_op->u.getattr.attrmask & PVFS_ATTR_DIR_HINT)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dir hint needed.\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
                respattr->mask |= PVFS_ATTR_DIR_HINT;
                js_p->error_code = STATE_DIR;
            }
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dir hint not needed\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
            }
#endif
            gossip_debug(
                GOSSIP_GETATTR_DEBUG,
                "\n\t\t[tree_height = %d\n"
                "\t\tdirdata_min = %d\n"
                "\t\tdirdata_max = %d\n"
                "\t\tdirdata_count = %d\n"
                "\t\tsid_count = %d\n"
                "\t\tbitmap_size = %d\n"
                "\t\tsplit_size = %d\n"
                "\t\tserver_no= %d\n"
                "\t\tbranch_level = %d\n"
                "\t\tdirent_count= %d]\n",
                (int)respattr->u.dir.dist_dir_attr.tree_height,
                (int)respattr->u.dir.dist_dir_attr.dirdata_min,
                (int)respattr->u.dir.dist_dir_attr.dirdata_max,
                (int)respattr->u.dir.dist_dir_attr.dirdata_count,
                (int)respattr->u.dir.dist_dir_attr.sid_count,
                (int)respattr->u.dir.dist_dir_attr.bitmap_size,
                (int)respattr->u.dir.dist_dir_attr.split_size,
                (int)respattr->u.dir.dist_dir_attr.server_no,
                (int)respattr->u.dir.dist_dir_attr.branch_level,
                (int)respattr->u.dir.dirent_count);

            /* respattr->mask |= PVFS_ATTR_DIR_ALL; */
            js_p->error_code = STATE_DIR;
            break;

        case PVFS_TYPE_DIRDATA:
#if 0
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: dirdata\n");
            if (s_op->u.getattr.attrmask & PVFS_ATTR_DIR_DIRENT_COUNT)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " getattr: dirent_count needed.\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
                respattr->mask |= PVFS_ATTR_DIR_DIRENT_COUNT;
         
                /* to prevent encoding of the bitmap, handles, and sids 
                 * when all we want is the dirent-count. NOTE: (1)By 
                 * default, prelude retrieves these values for 
                 * PVFS_TYPE_DIRDATA handles. (2)The most up-to-date 
                 * value for dirent-count is kept in the PVFS_TYPE_DIRDATA 
                 * dspace record.
                 */
                respattr->u.dirdata.dist_dir_attr.bitmap_size  =0;
                respattr->u.dirdata.dist_dir_attr.dirdata_count=0;
                respattr->u.dirdata.dist_dir_attr.sid_count    =0;
                js_p->error_code = 0;
            }   
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " getattr: dirent_count not needed.\n");
                js_p->error_code = 0;
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
            }   
/*
            gossip_debug(
                GOSSIP_GETATTR_DEBUG, "  handle %s refers to "
                "a dirdata object. doing nothing special\n",
                PVFS_OID_str(&s_op->u.getattr.handle));
            assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
*/
#endif
            gossip_debug(
                GOSSIP_GETATTR_DEBUG,
                "\t\ttree_height = %d\n"
                "\t\tdirdata_min = %d\n"
                "\t\tdirdata_max = %d\n"
                "\t\tdirdata_count = %d\n"
                "\t\tsid_count = %d\n"
                "\t\tbitmap_size = %d\n"
                "\t\tsplit_size = %d\n"
                "\t\tserver_no= %d\n"
                "\t\tbranch_level = %d\n"
                "\t\tdirent_count= %d\n",
                (int)respattr->u.dirdata.dist_dir_attr.tree_height,
                (int)respattr->u.dirdata.dist_dir_attr.dirdata_min,
                (int)respattr->u.dirdata.dist_dir_attr.dirdata_max,
                (int)respattr->u.dirdata.dist_dir_attr.dirdata_count,
                (int)respattr->u.dirdata.dist_dir_attr.sid_count,
                (int)respattr->u.dirdata.dist_dir_attr.bitmap_size,
                (int)respattr->u.dirdata.dist_dir_attr.split_size,
                (int)respattr->u.dirdata.dist_dir_attr.server_no,
                (int)respattr->u.dirdata.dist_dir_attr.branch_level,
                (int)respattr->u.dirdata.dirent_count);
            respattr->mask |= PVFS_ATTR_DIRDATA_ALL;
            js_p->error_code = 0;
            break;


        case PVFS_TYPE_SYMLINK:
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: symlink\n");
            gossip_debug(
                GOSSIP_GETATTR_DEBUG, "  handle %s refers to a symlink.\n",
                PVFS_OID_str(&s_op->u.getattr.handle));

            /*
              we'll definitely have to fetch the symlink target in this
              case, as the prelude will never retrieve it for us
            */

            /* respattr->mask = PVFS_ATTR_SYMLNK_ALL; */
            js_p->error_code = STATE_SYMLINK;
            break;


        case PVFS_TYPE_INTERNAL:
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: internal\n");
            /* nothing interesting to add; this is meaningless to a client */
            break;


        default:
            /* if we don't understand the object type, then it probably indicates
             * a bug or some data corruption.  All trove objects should have a
             * type set.
             */
            gossip_err(
                "Error: got unknown type (%d) when verifying attributes for "
                "handle %s.\n", 
                respattr->objtype, PVFS_OID_str(&s_op->u.getattr.handle));
            js_p->error_code = -PVFS_ENOENT;
            break;
    }/* end switch on object type */

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_read_symlink_keyvals(struct PINT_smcb *smcb,
                                                   job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    int keyval_count = 0;
    job_id_t j_id;
    PVFS_object_attr *respattr = &(s_op->resp.u.getattr.attr);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    if (!(s_op->u.getattr.attrmask & PVFS_ATTR_SYMLNK_TARGET))
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG, "skipping symlink target read\n");
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    /*
     *  optimistically add mask value to indicate the symlink target is
     *  filled (error_code is checked in next state)
     */

    respattr->mask |= PVFS_ATTR_SYMLNK_TARGET;

    respattr->u.sym.target_path_len = PVFS_NAME_MAX;
    respattr->u.sym.target_path = malloc(respattr->u.sym.target_path_len);

    if (!respattr->u.sym.target_path)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    free_keyval_buffers(s_op);

    keyval_count = 2; /* symlink target and parent */

    s_op->key_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->key_a)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->key_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    s_op->val_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->val_a)
    {
        free(s_op->key_a);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->val_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    s_op->error_a = malloc(sizeof(PVFS_error) * keyval_count);
    if(!s_op->error_a)
    {
        free(s_op->error_a);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->error_a, (sizeof(PVFS_error) * keyval_count));

    /* this is wrong, is it needed somewhere? */
    /* respattr->meta_sid_count = OSASZ(1, s_op->req->u.mkdir.sid_count); */

    /* this is freed with the attr struct */
    respattr->parent         = malloc(respattr->meta_sid_count);
    respattr->parent_sids    = (PVFS_SID *)(respattr->parent + 1);

    /*------------------------------------------------------------------*/

    s_op->key_a[0].buffer_sz = Trove_Common_Keys[SYMLINK_TARGET_KEY].size;
    s_op->key_a[0].buffer    = Trove_Common_Keys[SYMLINK_TARGET_KEY].key;

    s_op->val_a[0].buffer_sz = respattr->u.sym.target_path_len;
    s_op->val_a[0].buffer    = respattr->u.sym.target_path;

    keep_keyval_buffers(s_op, 0);

    /*------------------------------------------------------------------*/

    s_op->key_a[1].buffer_sz = Trove_Common_Keys[OBJECT_PARENT_KEY].size;
    s_op->key_a[1].buffer    = Trove_Common_Keys[OBJECT_PARENT_KEY].key;

    s_op->val_a[1].buffer_sz = OSASZ(1, respattr->meta_sid_count);
    s_op->val_a[1].buffer    = respattr->parent;

    keep_keyval_buffers(s_op, 1);

    /*------------------------------------------------------------------*/

    ret = job_trove_keyval_read_list(s_op->u.getattr.fs_id,
                                     s_op->u.getattr.handle,
                                     s_op->key_a,
                                     s_op->val_a,
                                     s_op->error_a,
                                     keyval_count,
                                     0,
                                     NULL,
                                     smcb,
                                     0,
                                     js_p,
                                     &j_id,
                                     server_job_context,
                                     s_op->req->hints);

    return ret;
}

#if 0

static PINT_sm_action getattr_read_metafile_hint(
            struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;
    char *buf = NULL;

    assert(s_op->attr.objtype == PVFS_TYPE_METAFILE);
    buf = (char *) calloc(sizeof(uint32_t) + 1, 1);
    if (buf == NULL) 
    {
        js_p->error_code = -PVFS_ENOMEM;
        /*If we hit an error the DIST & DFILES are no longer valid*/
        s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_DIST;
        s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_DFILES;
        s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_MIRROR_DFILES;
        return 1;
    }

    js_p->error_code = 0;

    free_keyval_buffers(s_op);

    s_op->key.buffer = Trove_Special_Keys[METAFILE_HINT_KEY].key;
    s_op->key.buffer_sz = Trove_Special_Keys[METAFILE_HINT_KEY].size;

    s_op->val.buffer = buf;
    s_op->val.buffer_sz = sizeof(s_op->resp.u.getattr.attr.u.meta.hint) + 1;

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "  reading metafile hint (coll_id = %d, "
                 "handle = %s, key = %s (%d), val_buf = %p (%d))\n",
                 s_op->u.getattr.fs_id,
                 PVFS_OID_str(&s_op->u.getattr.handle),
                 (char *)s_op->key.buffer,
                 s_op->key.buffer_sz, s_op->val.buffer,
                 s_op->val.buffer_sz);

    ret = job_trove_keyval_read(s_op->u.getattr.fs_id,
                                s_op->u.getattr.handle,
                                &s_op->key,
                                &s_op->val,
                                0,
                                NULL,
                                smcb,
                                0,
                                js_p,
                                &i,
                                server_job_context,
                                s_op->req->hints);

    return ret;
}

static PINT_sm_action getattr_interpret_metafile_hint(
        PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *resp_attr = NULL;
    PVFS_metafile_attr *meta = &(s_op->resp.u.getattr.attr.u.meta); 
    resp_attr = &s_op->resp.u.getattr.attr;

    assert(resp_attr->objtype == PVFS_TYPE_METAFILE);

    if (js_p->error_code == 0 || js_p->error_code == -TROVE_ENOENT)
    {
        if (js_p->error_code == 0)
        {
            memcpy(&(meta->hint), s_op->val.buffer, sizeof(meta->hint));
        }
        if ((resp_attr->mask & PVFS_ATTR_META_DFILES) ||
            (resp_attr->mask & PVFS_ATTR_META_DIST)   ||
            (resp_attr->mask & PVFS_ATTR_META_MIRROR_DFILES))
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, " * client wants extra "
                         "meta info, about to retrieve it now\n");
            js_p->error_code = STATE_METAFILE;
            if ( (resp_attr->mask  & PVFS_ATTR_META_MIRROR_DFILES) && 
                !(meta->hint.flags & PVFS_MIRROR_FL) ) 
                  resp_attr->mask &= ~(PVFS_ATTR_META_MIRROR_DFILES);
        }
        else
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, " * client doesn't want "
                         "extra meta info, preparing response now\n");
            js_p->error_code = 0;
        }
    }
    else
    {
        /*If we hit an error the DIST & DFILES are no longer valid*/
        resp_attr->mask &= ~PVFS_ATTR_META_DIST;
        resp_attr->mask &= ~PVFS_ATTR_META_DFILES;
        resp_attr->mask &= ~PVFS_ATTR_META_MIRROR_DFILES;
    }
    return SM_ACTION_COMPLETE;
}

#endif

/* V3 rename ... _read_datafile_handles_ ... */
static PINT_sm_action getattr_read_metafile_keyvals(struct PINT_smcb *smcb,
                                                    job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    int dfile_count = 0, sid_count = 0;
    int keyval_count = 0;
    job_id_t j_id;
    PVFS_object_attr *respattr;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    /* set up some convienience variables */

    respattr = &(s_op->resp.u.getattr.attr);

    assert(s_op->attr.objtype == PVFS_TYPE_METAFILE);

    js_p->error_code = 0;

    dfile_count = respattr->u.meta.dfile_count;
    sid_count = respattr->u.meta.sid_count;

    /* Do some error checking */

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 " response has dfile_count %d sid_count %d\n",
                 dfile_count, sid_count);

    /* verify that the retrieved dfile count is sane */
    if (!PVFS_REQ_LIMIT_DFILE_COUNT_IS_VALID(dfile_count))
    {
        gossip_err("The requested dfile count of %d is invalid; "
                   "aborting operation.\n", dfile_count);
        gossip_err(
            "+ attrs read from dspace: (owner = %d, group = %d, "
            "perms = %o, type = %d\n   atime = %lld, mtime = %lld, "
            "ctime = %lld |\n   dfile_count = %d | dist_size = %d)\n",
            respattr->owner, respattr->group, respattr->perms,
            respattr->objtype, 
            lld(respattr->atime), lld(respattr->mtime), lld(respattr->ctime),
            (int)respattr->u.meta.dfile_count,
            (int)respattr->u.meta.dist_size);

        gossip_err("handle: %s, fsid: %d.\n",
            PVFS_OID_str(&s_op->u.getattr.handle),
            (int)s_op->u.getattr.fs_id);

        /* If we hit an error the DIST & DFILES are no longer valid */
        respattr->mask &= ~PVFS_ATTR_META_DIST;
        respattr->mask &= ~PVFS_ATTR_META_DFILES;
        respattr->mask &= ~PVFS_ATTR_META_MIRROR_MODE;
        
        js_p->error_code = -PVFS_EOVERFLOW;
        return SM_ACTION_COMPLETE;
    }

    /*
     * there *should* be some distribution information.  if not, dump
     * which handle is busted and assertion die for now while we're not
     * handling this kind of error
     */
    if (s_op->resp.u.getattr.attr.u.meta.dist_size < 1)
    {
        gossip_err("Cannot Read Dist!  Got an invalid dist size for "
                   "handle %s,%d\n",
                   PVFS_OID_str(&s_op->u.getattr.handle),
                   s_op->u.getattr.fs_id);
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }
    assert(s_op->resp.u.getattr.attr.u.meta.dist_size > 0);

    /* start setting up to read keyvals */

    free_keyval_buffers(s_op);
    keyval_count = 3; /* dfile handles, dist, parent */

    s_op->key_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->key_a)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->key_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    s_op->val_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->val_a)
    {
        free(s_op->key_a);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->val_a, (sizeof(PVFS_ds_keyval) * keyval_count));
    
    s_op->error_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->error_a)
    {
        free(s_op->error_a);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->error_a, (sizeof(PVFS_error) * keyval_count));

    /* this will get cleaned up with attr structure */
    respattr->u.meta.dfile_array = malloc(OSASZ(dfile_count, sid_count));
    if (!respattr->u.meta.dfile_array)
    {
        gossip_err("Cannot allocate dfile array of count %d with sid_count:"
                   " %d\n", dfile_count, sid_count);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* We set the sid_array to the appropriate place after the dfile_array */
    respattr->u.meta.sid_array = 
             (PVFS_SID *)&respattr->u.meta.dfile_array[dfile_count];

    /* this will get cleaned up with attr structure */
    respattr->u.meta.dist = malloc(s_op->val_a[1].buffer_sz);
    if (respattr->u.meta.dist)
    {
        gossip_err("Cannot allocate dist of size %d\n",
                   s_op->val_a[1].buffer_sz);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* this will get cleaned up with attr structure */
    respattr->parent = malloc(OSASZ(1, respattr->meta_sid_count));
    if (respattr->u.meta.dist)
    {
        gossip_err("Cannot allocate parent buffer of size %d\n",
                   s_op->val_a[1].buffer_sz);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

/*---------------------------------------------------------------------------*/

    s_op->key_a[0].buffer_sz = Trove_Common_Keys[METAFILE_HANDLES_KEY].size;
    s_op->key_a[0].buffer    = Trove_Common_Keys[METAFILE_HANDLES_KEY].key;

    s_op->val_a[0].buffer_sz = OSASZ(dfile_count, sid_count);
    s_op->val_a[0].buffer    = respattr->u.meta.dfile_array;

    keep_keyval_buffers(s_op, 0);

/*---------------------------------------------------------------------------*/

    s_op->key_a[1].buffer_sz = Trove_Common_Keys[METAFILE_DIST_KEY].size;
    s_op->key_a[1].buffer    = Trove_Common_Keys[METAFILE_DIST_KEY].key;

    s_op->val_a[1].buffer_sz = s_op->resp.u.getattr.attr.u.meta.dist_size; 
    s_op->val_a[1].buffer    = respattr->u.meta.dist;

    keep_keyval_buffers(s_op, 1);

/*---------------------------------------------------------------------------*/

    s_op->key_a[2].buffer_sz = Trove_Common_Keys[OBJECT_PARENT_KEY].size;
    s_op->key_a[2].buffer    = Trove_Common_Keys[OBJECT_PARENT_KEY].key;

    s_op->val_a[2].buffer_sz = OSASZ(1, respattr->meta_sid_count);
    s_op->val_a[2].buffer    = respattr->parent;

    keep_keyval_buffers(s_op, 2);

/*---------------------------------------------------------------------------*/

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "  reading %d metadata keyvals (coll_id = %d, handle = %s\n"
                 "        key[0] = %s (%d) val_buf[0] = %p (%d))\n"
                 "        key[1] = %s (%d) val_buf[1] = %p (%d))\n"
                 "        key[2] = %s (%d) val_buf[2] = %p (%d))\n" ,
                 dfile_count, s_op->u.getattr.fs_id,
                 PVFS_OID_str(&s_op->u.getattr.handle),
                 (char *)s_op->key_a[0].buffer, s_op->key_a[0].buffer_sz, 
                 s_op->val_a[0].buffer, s_op->val_a[0].buffer_sz,
                 (char *)s_op->key_a[1].buffer, s_op->key_a[1].buffer_sz, 
                 s_op->val_a[1].buffer, s_op->val_a[1].buffer_sz,
                 (char *)s_op->key_a[2].buffer, s_op->key_a[2].buffer_sz, 
                 s_op->val_a[2].buffer, s_op->val_a[2].buffer_sz);

    ret = job_trove_keyval_read_list(s_op->u.getattr.fs_id
                                    ,s_op->u.getattr.handle
                                    ,s_op->key_a
                                    ,s_op->val_a
                                    ,s_op->error_a
                                    ,keyval_count
                                    ,0
                                    ,NULL
                                    ,smcb
                                    ,0
                                    ,js_p
                                    ,&j_id
                                    ,server_job_context
                                    ,s_op->req->hints);

    return ret;
}

static PINT_sm_action getattr_metafile_keyvals_verify(struct PINT_smcb *smcb,
                                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    if ((js_p->error_code == 0) &&
        (s_op->u.getattr.attrmask & PVFS_ATTR_META_DFILES))
    {
        /* successfully read datafile key; make sure we got something valid */
        if (s_op->val_a[0].read_sz != s_op->val_a[0].buffer_sz)
        {
            gossip_err("Error: %s key found val size: %d when expecting val size: %d\n",
                       Trove_Common_Keys[METAFILE_HANDLES_KEY].key,
                       s_op->val_a[0].read_sz, s_op->val_a[0].buffer_sz);

            /* clear bitmask to prevent double free between setup_resp and
             * PINT_free_object_attr()
             */
            s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_DFILES;
            s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_DIST;
            s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_MIRROR_MODE;

            js_p->error_code = -PVFS_EIO;
            return SM_ACTION_COMPLETE;
        }
    }

    if (s_op->u.getattr.attrmask & PVFS_ATTR_META_DIST)
    {
        /* successfully read dist key; make sure we got something valid */
        if (s_op->val_a[1].read_sz != s_op->val_a[1].buffer_sz)
        {
            gossip_err("Error: %s key found val size: %d when expecting val size: %d\n",
                       Trove_Common_Keys[METAFILE_DIST_KEY].key,
                       s_op->val_a[1].read_sz, s_op->val_a[1].buffer_sz);

            /* clear bitmask to prevent double free between setup_resp and
             * PINT_free_object_attr()
             */
            s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_DIST;

            js_p->error_code = -PVFS_EIO;
            return SM_ACTION_COMPLETE;
        }

        assert(s_op->val_a[1].buffer);
        PINT_dist_decode(&s_op->resp.u.getattr.attr.u.meta.dist, s_op->val_a[1].buffer);

        if(s_op->resp.u.getattr.attr.u.meta.dist == NULL)
        {
            gossip_err("Found dist of 0 for handle %s,%d\n",
                       PVFS_OID_str(&s_op->u.getattr.handle), s_op->u.getattr.fs_id);
            PVFS_perror("Metafile interpret_metafile_distribution", js_p->error_code);
            js_p->error_code = -PVFS_EIO;
            return SM_ACTION_COMPLETE;
        }
    }

    /* otherwise deliberately preserve existing error code */
    return SM_ACTION_COMPLETE;
}

#if 0
static PINT_sm_action getattr_read_metafile_distribution(
        struct PINT_smcb *smcb,
        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    assert(s_op->attr.objtype == PVFS_TYPE_METAFILE);

    js_p->error_code = 0;

    free_keyval_buffers(s_op);

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

    ret = job_trove_keyval_read(s_op->u.getattr.fs_id,
                                s_op->u.getattr.handle,
                                &(s_op->key),
                                &(s_op->val),
                                0,
                                NULL,
                                smcb,
                                0,
                                js_p,
                                &i,
                                server_job_context,
                                s_op->req->hints);

    return ret;
}

/* interpret_metafile_distribution()
 *
 * capture and encode results of reading distribution
 */
static PINT_sm_action interpret_metafile_distribution(struct PINT_smcb *smcb,
                                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *respattr = &(s_op->resp.u.getattr.attr);
    
    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    if (js_p->error_code < 0)
    {
        return SM_ACTION_COMPLETE;
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}
#endif

static PINT_sm_action getattr_read_directory_keyvals(struct PINT_smcb *smcb,
                                                     job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    job_id_t tmp_id;
    PVFS_object_attr *attr;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    attr = &s_op->resp.u.getattr.attr;

    /* This thinks we just read dist_dir_attr from keyval
     * We don't do that any more, but we may have just
     * read something we should check.  If not, we should
     * remove this whole thing.
     */
    if (js_p->error_code == -TROVE_ENOENT)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "getattr: no DIRECTORY dspace present!!\n");
        attr->u.dir.dist_dir_bitmap = NULL;
        attr->u.dir.dirdata_handles = NULL;
        attr->parent = NULL;
        return SM_ACTION_COMPLETE;
    }

    /* these correct values are in the database, but not in the
     * buffer after we read and convert the attributes.  Fix it!!!
     */
    /* this code is just for early V3 work, it should be removed */
    //attr->u.dir.dist_dir_attr.dirdata_count = 1;
    //attr->u.dir.dist_dir_attr.bitmap_size   = 1;
    //attr->meta_sid_count = 1;

    /* this should not assert, but error and drop the request
     * so the server doesn't die.  We should be building with NDEBUG
     * for real installations.  Probably just good error messages
     * are best.
     */
    assert(attr->u.dir.dist_dir_attr.dirdata_count > 0);
    assert(attr->u.dir.dist_dir_attr.bitmap_size > 0);
    assert(attr->meta_sid_count > 0);

    /* just printed all the following in getattr_validate */
#if 0
    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "getattr: get dist-dir-attr for dir meta handle %s "
                 "with tree_height=%d, dirdata_count=%d, bitmap_size=%d, "
                 "split_size=%d, server_no=%d and branch_level=%d\n",
                 PVFS_OID_str(&s_op->u.getattr.handle),
                 attr->u.dir.dist_dir_attr.tree_height,
                 attr->u.dir.dist_dir_attr.dirdata_count,
                 attr->u.dir.dist_dir_attr.bitmap_size,
                 attr->u.dir.dist_dir_attr.split_size,
                 attr->u.dir.dist_dir_attr.server_no,
                 attr->u.dir.dist_dir_attr.branch_level);
#endif

    /******************************
     * This starts to make sense
     * about here, the stuff above
     * other than error checking
     * should be removed I think
     * error checking ought to be in
     * the validate routine I think
     ******************************
     */

    /* allocate space for bitmap, dirdata OIDS and OIDS, parent OID and SIDS */
    attr->u.dir.dist_dir_bitmap =
                malloc(attr->u.dir.dist_dir_attr.bitmap_size *
                             sizeof(PVFS_dist_dir_bitmap_basetype));

    attr->u.dir.dirdata_handles =
                (PVFS_OID *)malloc(OSASZ(attr->u.dir.dist_dir_attr.dirdata_count, 
                                          attr->u.dir.dist_dir_attr.sid_count));
    
    attr->u.dir.dirdata_sids = (PVFS_SID *)(attr->u.dir.dirdata_handles +
                               attr->u.dir.dist_dir_attr.dirdata_count);

    attr->parent = (PVFS_OID *)malloc(OSASZ(1, attr->meta_sid_count));

    attr->parent_sids = (PVFS_SID *)(attr->parent + 1);

    /* check for malloc failure */
    if(!attr->u.dir.dist_dir_bitmap || 
       !attr->u.dir.dirdata_handles ||
       !attr->parent)
    {
        free(attr->u.dir.dist_dir_bitmap);
        free(attr->u.dir.dirdata_handles);
        free(attr->parent);
        attr->u.dir.dist_dir_bitmap = NULL;
        attr->u.dir.dirdata_handles = NULL;
        attr->u.dir.dirdata_sids = NULL;
        attr->parent = NULL;
        attr->parent_sids = NULL;
        js_p->error_code = -PVFS_ENOMEM;
        gossip_err("Failed to allocate memory in getattr(dir)\n");
        return SM_ACTION_COMPLETE;
    }

    /* total 3 keyvals, DIST_DIRDATA_BITMAP, DIST_DIRDATA_HANDLES, OBJECT_PARENT  */

    free_keyval_buffers(s_op);

    /* allocate space for keys and values */
    s_op->keyval_count = 3;
    s_op->key_a = s_op->val_a = NULL;
    s_op->error_a = NULL;

    s_op->key_a = calloc(s_op->keyval_count, sizeof(PVFS_ds_keyval));
    s_op->val_a = calloc(s_op->keyval_count, sizeof(PVFS_ds_keyval));
    s_op->error_a = calloc(s_op->keyval_count, sizeof(PVFS_error));

    if(! s_op->key_a || ! s_op->val_a || ! s_op->error_a)
    {
        gossip_lerr("Cannot allocate memory for key/val/error.\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /*----------------------------------------------------------------------------*/

    s_op->key_a[0].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].size;
    s_op->key_a[0].buffer    = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].key;

    s_op->val_a[0].buffer_sz = attr->u.dir.dist_dir_attr.bitmap_size *
                                       sizeof(PVFS_dist_dir_bitmap_basetype);
    s_op->val_a[0].buffer    = attr->u.dir.dist_dir_bitmap;

    keep_keyval_buffers(s_op, 0);

    /*----------------------------------------------------------------------------*/

    s_op->key_a[1].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].size;
    s_op->key_a[1].buffer    = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].key;

    s_op->val_a[1].buffer_sz = OSASZ(attr->u.dir.dist_dir_attr.dirdata_count, 
                                     attr->u.dir.dist_dir_attr.sid_count);
    s_op->val_a[1].buffer    = attr->u.dir.dirdata_handles;

    keep_keyval_buffers(s_op, 1);

    /*----------------------------------------------------------------------------*/

    s_op->key_a[2].buffer_sz = Trove_Common_Keys[OBJECT_PARENT_KEY].size;
    s_op->key_a[2].buffer    = Trove_Common_Keys[OBJECT_PARENT_KEY].key;

    s_op->val_a[2].buffer_sz = OSASZ(1, attr->meta_sid_count);
    s_op->val_a[2].buffer    = attr->parent;

    keep_keyval_buffers(s_op, 2);
    /*----------------------------------------------------------------------------*/

    js_p->error_code = 0;
    ret = job_trove_keyval_read_list(s_op->u.getattr.fs_id,
                                     s_op->u.getattr.handle,
                                     s_op->key_a,
                                     s_op->val_a,
                                     s_op->error_a,
                                     s_op->keyval_count,
                                     0,
                                     NULL,
                                     smcb,
                                     0,
                                     js_p,
                                     &tmp_id,
                                     server_job_context,
                                     s_op->req->hints);

    return ret;
}

static PINT_sm_action getattr_get_dir_hint(struct PINT_smcb *smcb,
                                           job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret, i;
    job_id_t tmp_id;
    PVFS_object_attr *attr_p;
    unsigned char *c;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    /*
     * Check for return of last database (keyval) read
     * and debugging of results
     */

    /* check for ENOENT */
    if (js_p->error_code != 0)
    {
        if (js_p->error_code == -TROVE_ENOENT)
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, "getattr: no standard keyvals present,"
                                               " not getting DIR_HINTS! \n");
        }
        else
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, "Error returned from previous state (%d)"
                                               " skipping to next state\n",
                                               js_p->error_code);
        }
        return SM_ACTION_COMPLETE;
    }

    attr_p = &s_op->resp.u.getattr.attr;

    /* gossip bitmap */
    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "getattr: dist_dir_bitmap as:\n");

    for(i = attr_p->u.dir.dist_dir_attr.bitmap_size - 1; i >= 0 ; i--)
    {
        c = (unsigned char *)(attr_p->u.dir.dist_dir_bitmap + i);
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     " i=%d : %02x %02x %02x %02x\n",
                     i, c[3], c[2], c[1], c[0]);
    }

    /* gossip handles */
    gossip_debug(GOSSIP_GETATTR_DEBUG, "\n");

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "\t getattr: dirdata handles array of directory %s.\n",
                 PVFS_OID_str(&s_op->u.getattr.handle));

    for(i = 0; i < attr_p->u.dir.dist_dir_attr.dirdata_count; i++)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "\t\tdirdata server %d: %s.\n",
                     i, PVFS_OID_str(&attr_p->u.dir.dirdata_handles[i]));
    }

    /*
     * Start to get DIR HINTS
     */

    /* NOTE: memory allocations are released in the getattr_cleanup()
     * function 
     */

    gossip_debug(GOSSIP_SERVER_DEBUG, "  trying to getxattr of %s,%s,%s "
                 "of dir handle (coll_id = %d, handle = %s\n",
                 Trove_Special_Keys[DIST_NAME_KEY].key,
                 Trove_Special_Keys[DIST_PARAMS_KEY].key, 
                 Trove_Special_Keys[DEFAULT_NUM_DFILES_KEY].key,
                 s_op->u.getattr.fs_id,
                 PVFS_OID_str(&s_op->u.getattr.handle));

    /* malloc space for distribution parameters */
    s_op->resp.u.getattr.attr.u.dir.hint.dist_params = 
                    (char *) calloc(1, PVFS_REQ_LIMIT_DIST_BYTES);

    if (!s_op->resp.u.getattr.attr.u.dir.hint.dist_params)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->resp.u.getattr.attr.u.dir.hint.dist_params_len = 
                    PVFS_REQ_LIMIT_DIST_BYTES;

    /* malloc space for distribution name */
    s_op->resp.u.getattr.attr.u.dir.hint.dist_name = 
            (char *) calloc(1, PVFS_REQ_LIMIT_DIST_NAME);

    if (!s_op->resp.u.getattr.attr.u.dir.hint.dist_name)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->resp.u.getattr.attr.u.dir.hint.dist_name_len = 
                    PVFS_REQ_LIMIT_DIST_NAME;

    /* malloc space for layout and server list */
    s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.servers =
            (char *) calloc(1, PVFS_REQ_LIMIT_LAYOUT);
    if (!s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.servers)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.bufsize =
            PVFS_REQ_LIMIT_LAYOUT;
    s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.count = 0;

    free_keyval_buffers(s_op);

    /* Note NUM Special Keys is the number of user space attributes we
     * automatically read with get-attr - we know what they are so we
     * set up specifically for them.  Not sure why this is done with a
     * for loop below
     */
        
    /* allocate key, val, and error buffers */
    s_op->key_a = (PVFS_ds_keyval *) calloc(NUM_SPECIAL_KEYS, sizeof(PVFS_ds_keyval));
    if (s_op->key_a == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->val_a = (PVFS_ds_keyval *) calloc(NUM_SPECIAL_KEYS, sizeof(PVFS_ds_keyval));
    if (s_op->val_a == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->error_a = (PVFS_error*)calloc(NUM_SPECIAL_KEYS, sizeof(PVFS_error));
    if (s_op->error_a == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* set up key and val buffers */
    s_op->keyval_count = NUM_SPECIAL_KEYS;

    for (i = 0; i < NUM_SPECIAL_KEYS; i++)
    {
        s_op->key_a[i].buffer = Trove_Special_Keys[i].key;
        s_op->key_a[i].buffer_sz = Trove_Special_Keys[i].size;

        if (i == DEFAULT_NUM_DFILES_KEY)
        {
            s_op->val_a[i].buffer = (char *) calloc(1, 16);
            if (s_op->val_a[i].buffer == NULL)
            {
                js_p->error_code = -PVFS_ENOMEM;
                return SM_ACTION_COMPLETE;
            }
            s_op->val_a[i].buffer_sz = 16;
        }
        else if (i == DIST_PARAMS_KEY)
        {
            s_op->val_a[i].buffer =
                        s_op->resp.u.getattr.attr.u.dir.hint.dist_params;
            s_op->val_a[i].buffer_sz =
                        s_op->resp.u.getattr.attr.u.dir.hint.dist_params_len;
            KEEP_BUFFER(DIST_PARAMS_KEY);
            KEEP_BUFFER(DIST_PARAMS_KEY);
        }
        else if (i == DIST_NAME_KEY)
        {
            s_op->val_a[i].buffer =
                        s_op->resp.u.getattr.attr.u.dir.hint.dist_name;
            s_op->val_a[i].buffer_sz =
                        s_op->resp.u.getattr.attr.u.dir.hint.dist_name_len;
            KEEP_BUFFER(DIST_NAME_KEY);
            KEEP_BUFFER(DIST_NAME_KEY);
        }
        else if (i == LAYOUT_KEY)
        {
            s_op->val_a[i].buffer = (char *) calloc(1, 16);
            if (s_op->val_a[i].buffer == NULL)
            {
                js_p->error_code = -PVFS_ENOMEM;
                return SM_ACTION_COMPLETE;
            }
            s_op->val_a[i].buffer_sz = 16;
        }
        else if (i == SERVER_LIST_KEY)
        {
            s_op->val_a[i].buffer =
                s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.servers;
            s_op->val_a[i].buffer_sz =
                s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.bufsize;
            KEEP_BUFFER(SERVER_LIST_KEY);
        }
    }

    /* read key val pairs */
    js_p->error_code = 0;
    ret = job_trove_keyval_read_list(s_op->u.getattr.fs_id, 
                                     s_op->u.getattr.handle,
                                     s_op->key_a,
                                     s_op->val_a,
                                     s_op->error_a,
                                     NUM_SPECIAL_KEYS,
                                     0,
                                     NULL,
                                     smcb,
                                     0,
                                     js_p,
                                     &tmp_id,
                                     server_job_context,
                                     s_op->req->hints);

    return ret;
}

static PINT_sm_action getattr_interpret_dir_hint(struct PINT_smcb *smcb,
                                                 job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    if (js_p->error_code != 0 && js_p->error_code != -TROVE_ENOENT)
    {
        /* if we failed to get any of the keys, and the error code is due to
         * something other than the keys simply not being present, then
         * propagate the error.
         */
        gossip_debug(GOSSIP_GETATTR_DEBUG, "Error returned from previous state (%d)"
                                           "skipping to next state\n", js_p->error_code);
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_SERVER_DEBUG, 
        "getattr: job status code = %d (may be ENOENT - OK)\n", js_p->error_code);

    if (s_op->val_a && s_op->key_a)
    {

        if (s_op->error_a[DIST_NAME_KEY] == 0)
        {
            gossip_debug(GOSSIP_SERVER_DEBUG, 
                "val_a[DIST_NAME_KEY] %p read_sz = %d dist_name = %s\n", 
                s_op->val_a[DIST_NAME_KEY].buffer, 
                s_op->val_a[DIST_NAME_KEY].read_sz,
                (char *)s_op->val_a[DIST_NAME_KEY].buffer);

            s_op->resp.u.getattr.attr.u.dir.hint.dist_name_len = 
                            s_op->val_a[DIST_NAME_KEY].read_sz;
        }
        else
        {
            s_op->resp.u.getattr.attr.u.dir.hint.dist_name_len = 0;
        }            

        if (s_op->error_a[DIST_PARAMS_KEY] == 0)
        {
            gossip_debug(GOSSIP_SERVER_DEBUG, 
                "val_a[DIST_PARAMS_KEY] %p read_sz = %d dist_params = %s\n", 
                s_op->val_a[DIST_PARAMS_KEY].buffer, 
                s_op->val_a[DIST_PARAMS_KEY].read_sz,
                (char *)s_op->val_a[DIST_PARAMS_KEY].buffer);

            s_op->resp.u.getattr.attr.u.dir.hint.dist_params_len = 
                            s_op->val_a[DIST_PARAMS_KEY].read_sz;
        }
        else
        {
            s_op->resp.u.getattr.attr.u.dir.hint.dist_params_len = 0;
        }

        if (s_op->error_a[DEFAULT_NUM_DFILES_KEY] == 0)
        {
            long int dfile_count = 0;
            char *endptr = NULL;
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "val_a[DEFAULT_NUM_DFILES_KEY] %p read_sz = %d\n", 
                         s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer, 
                         s_op->val_a[DEFAULT_NUM_DFILES_KEY].read_sz);

            dfile_count = strtol(s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer,
                                 &endptr,
                                 10);

            if (*endptr != '\0' || dfile_count < 0)
            {
                dfile_count = 0;
            }
            s_op->resp.u.getattr.attr.u.dir.hint.dfile_count = dfile_count;
        }
/* commented out in trunk, not sure why WBL */
#if 0
        if(s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer)
        {
            free(s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer);
            s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer = NULL;
            s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer_sz = 0;
        }
#endif
        if (s_op->error_a[LAYOUT_KEY] == 0)
        {
            long int layout;
            char *endptr = NULL;

            layout = strtol(s_op->val_a[LAYOUT_KEY].buffer,
                            &endptr, 
                            10);

            if (*endptr != '\0' ||
                layout < PVFS_SYS_LAYOUT_NULL ||
                layout > PVFS_SYS_LAYOUT_MAX)
            {
                layout = PVFS_SYS_LAYOUT_NULL;
            }
            s_op->resp.u.getattr.attr.u.dir.hint.layout.algorithm = layout;
        }
        else
        {
            s_op->resp.u.getattr.attr.u.dir.hint.layout.algorithm =
                    PVFS_SYS_LAYOUT_NULL;
        }

        if ((s_op->error_a[SERVER_LIST_KEY] == 0) &&
            (s_op->val_a[SERVER_LIST_KEY].read_sz >= 6))
        {
            /* no error, so set the count from the list */
            /* list should be in the buffer of the k/v read */
            s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.count = 
                    strtol(s_op->val_a[SERVER_LIST_KEY].buffer,
                    NULL,
                    10);
            /* WBL
             * should this be s_op->val_a[SERVER_LIST_KEY].read_sz ? 
             * instead of strlen(buffer) and if not, should it be
             * strlen + 1 ? */
            s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.bufsize = 
                    strlen(s_op->val_a[SERVER_LIST_KEY].buffer) + 1;
            /* force the dfile_count */
            s_op->resp.u.getattr.attr.u.dir.hint.dfile_count = 
                  s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.count;
        }
        else
        {
            s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.count = 0;
            s_op->resp.u.getattr.attr.u.dir.hint.layout.server_list.bufsize = 0;
        }            

        /* s_op->free_val = 1; free everything that is not KEEP_BUF */
        free_keyval_buffers(s_op);

        gossip_debug(GOSSIP_SERVER_DEBUG, "getattr: dir hint dfile_count: %d\n",
            s_op->resp.u.getattr.attr.u.dir.hint.dfile_count);

        js_p->error_code = 0;
    }/* end if val_a and key_a */
    return SM_ACTION_COMPLETE;
}

/* check_if_capability_required
 *
 * Branch point for capability creation.
 */
static PINT_sm_action getattr_check_if_capability_required(
                                                  struct PINT_smcb *smcb,
                                                  job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    /* errors fall through */
    if (js_p->error_code < 0)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG, "Error returned from previous state (%d)"
                                           "skipping to next state\n", js_p->error_code);
        return SM_ACTION_COMPLETE;
    }

    if (s_op->u.getattr.attrmask & PVFS_ATTR_CAPABILITY)
    {
        js_p->error_code = STATE_CAPABILITY;
    }
    else
    {
        js_p->error_code = 0;
    }

    return SM_ACTION_COMPLETE;
}

/* getattr_read_acl
 * 
 * Reads any ACL data from Trove if a capability is requested.
 */
static PINT_sm_action getattr_read_acl(struct PINT_smcb *smcb,
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t tmp_id;
    int ret;

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (getattr sm) state: getattr_read_acl\n",
                 s_op, PINT_map_server_op_to_string(s_op->req->op));

    assert(s_op->u.getattr.attrmask & PVFS_ATTR_CAPABILITY);

    /* clear the state transition flag */
    if (js_p->error_code > 0)
    {
        js_p->error_code = 0;
    }

    free_keyval_buffers(s_op);

    s_op->key.buffer = "system.posix_acl_access";
    s_op->key.buffer_sz = strlen(s_op->key.buffer) + 1;
    s_op->val.buffer = malloc(PVFS_REQ_LIMIT_VAL_LEN);
    if (!s_op->val.buffer)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    s_op->val.buffer_sz = PVFS_REQ_LIMIT_VAL_LEN;
    
    gossip_debug(GOSSIP_PERMISSIONS_DEBUG, "About to retrieve acl keyvals "
                     "for handle %s\n", PVFS_OID_str(&s_op->target_handle));

    ret = job_trove_keyval_read(s_op->u.getattr.fs_id,
                                s_op->u.getattr.handle,
                                &s_op->key,
                                &s_op->val,
                                0,
                                NULL,
                                smcb,
                                0,
                                js_p,
                                &tmp_id,
                                server_job_context,
                                s_op->req->hints);

    return ret;
}

/* getattr_create_capability
 *
 * Creates and fills in a capability object with the appropriate
 * operation mask for the given object.
 */
static PINT_sm_action getattr_create_capability(struct PINT_smcb *smcb,
                                                job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *respattr = &(s_op->resp.u.getattr.attr);
    struct server_configuration_s *config;
    void *acl_buf;
    size_t acl_size;
    int ret;
    PVFS_uid uid;
    uint32_t num_groups;
    PVFS_gid group_array[PVFS_REQ_LIMIT_GROUPS];
#ifdef ENABLE_CAPCACHE
    int insert_flag = 1;
#endif

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    if (js_p->error_code == -TROVE_ENOENT)
    {
        acl_buf = NULL;
        acl_size = 0;
        js_p->error_code = 0;
    }
    else if (js_p->error_code < 0)
    {
        /* let fatal errors fall through */
        return SM_ACTION_COMPLETE;
    }
    else
    {
        acl_buf = s_op->val.buffer;
        acl_size = s_op->val.read_sz;
    }

    ret = PINT_init_capability(&respattr->capability);
    if (ret < 0)
    {
        gossip_debug((GOSSIP_GETATTR_SECURITY_DEBUG),
                     "getattr: capability init failed\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    respattr->capability.num_handles = 1;

    /* if this is a metadata allocate room for dfile handles */
    if (respattr->objtype == PVFS_TYPE_METAFILE)
    {
        respattr->capability.num_handles += respattr->u.meta.dfile_count;
    }

    /* if this is a directory allocate room for dirdata handles */
    if (respattr->objtype == PVFS_TYPE_DIRECTORY)
    {
        respattr->capability.num_handles +=
                             respattr->u.dir.dist_dir_attr.dirdata_count;
    }

    /* if there are extra handles allocate them here */
    respattr->capability.handle_array = 
            calloc(respattr->capability.num_handles, sizeof(PVFS_handle));

    if (!respattr->capability.handle_array)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    respattr->capability.handle_array[0] = s_op->u.getattr.handle;

    /* if this is a metadata copy dfile handles into place */
    if (respattr->objtype == PVFS_TYPE_METAFILE)
    {
        /* copy datafile handles after the metafile handle */
        memcpy((respattr->capability.handle_array + 1),
               respattr->u.meta.dfile_array,
               respattr->u.meta.dfile_count * sizeof(PVFS_handle));
    }

    /* if this is a directory copy dirdata handles into place */
    if (respattr->objtype == PVFS_TYPE_DIRECTORY)
    {
        /* copy datafile handles after the directory handle */
        memcpy((respattr->capability.handle_array + 1),
               respattr->u.dir.dirdata_handles,
               respattr->u.dir.dist_dir_attr.dirdata_count *
                                             sizeof(PVFS_handle));
    }

    /* map credential based on credential certificate */
    ret = PINT_map_credential(&s_op->u.getattr.credential, 
                              &uid, 
                              &num_groups,
                              group_array);
    if (ret != 0)
    {
        PINT_cleanup_capability(&respattr->capability);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

#ifdef ENABLE_SECURITY_MODE
    /* no capabilities for unsigned credential; some operations
       still allowed */
    if (!IS_UNSIGNED_CRED(&s_op->u.getattr.credential))
    {
#endif
    /* generate permissions mask based on uid and (optional) ACLs */
    ret = PINT_get_capabilities(acl_buf,
                                acl_size,
                                uid,
                                group_array,
                                num_groups,
                                respattr,
                                &respattr->capability.op_mask);
    if (ret < 0)
    {
        PINT_cleanup_capability(&respattr->capability);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }
#ifdef ENABLE_SECURITY_MODE
    } /* if */
#endif
    
    respattr->capability.fsid = s_op->u.getattr.fs_id;

    config = PINT_server_config_mgr_get_config();
    respattr->capability.issuer = 
        (char *) malloc(strlen(config->server_alias) + 3);
    if (respattr->capability.issuer == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    strcpy(respattr->capability.issuer, "S:");
    strcat(respattr->capability.issuer, config->server_alias);

#if defined(ENABLE_CAPCACHE) && defined(ENABLE_SECURITY_MODE)
    /* if capability fields match cached capability, use
       signature from that capability */
    ret = PINT_capcache_quick_sign(&respattr->capability);
    if (ret != 0)
    {
        ret = PINT_sign_capability(&respattr->capability,NULL);        
    }
    else
    {
        /* no need to insert capability into cache */
        insert_flag = 0;
    }
#else
    ret = PINT_sign_capability(&respattr->capability,NULL);
#endif

    if (ret < 0)
    {
        gossip_debug((GOSSIP_GETATTR_SECURITY_DEBUG),
                     "getattr: failed to sign capability\n");
        PINT_cleanup_capability(&respattr->capability);
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }
                                 
    respattr->mask |= PVFS_ATTR_CAPABILITY;

    PINT_debug_credential(&s_op->u.getattr.credential, 
                          "getattr: using credential",
                          uid, num_groups, group_array);

    PINT_debug_capability(&respattr->capability, "Created");

#ifdef ENABLE_CAPCACHE
    /* Cache the new capability */
    if (insert_flag)
    {
        ret = PINT_capcache_insert(&respattr->capability);
        if (ret < 0)
        {
            /* issue a warning */
            gossip_err("Warning: could not cache capability\n");
        }
    }
#endif /* ENABLE_CAPCACHE */

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_setup_resp(struct PINT_smcb *smcb,
                                         job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *respattr = &(s_op->resp.u.getattr.attr);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "  getattr_setup_resp: error_code = %d\n",
                 js_p->error_code);
    if (js_p->error_code > 0)
    {
        /* if we reach this state with a positive error code it means that
         * nothing is wrong; we just used one of the explicit STATE_*
         * transitions
         */
        js_p->error_code = 0;
    }
    if (js_p->error_code < 0)
    {
        free_nested_getattr_data(s_op);
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "Handle %s \n\t\t"
                 "retrieved attrs: \n\t\t[type = %d, owner = %d, group = %d, \n\t\t"
                 "perms = %o, \n\t\t"
                 "atime = %llu, mtime = %llu, ctime = %llu, ntime = %llu, \n\t\t"
                 "dist_size = %d, dirent_count = %d]\n",
                 PVFS_OID_str(&s_op->u.getattr.handle), respattr->objtype,
                 respattr->owner, respattr->group, respattr->perms,
                 llu(respattr->atime), llu(respattr->mtime),
                 llu(respattr->ctime), llu(respattr->ntime),
                 (int)respattr->u.meta.dist_size,
                 (int)respattr->u.dir.dirent_count);

    switch (respattr->objtype)
    {
    case PVFS_TYPE_METAFILE :
        if (respattr->u.meta.dfile_count)
        {
            assert(respattr->u.meta.dfile_array);
        }
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning %d datafile handles\n",
                     respattr->u.meta.dfile_count);
        /* we have already gathered the dist field in an earlier state */
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning dist size of %d\n",
                     respattr->u.meta.dist_size);
        break;
    case PVFS_TYPE_DIRDATA :
        /* why do we zero these fields? */
        respattr->u.dirdata.dist_dir_attr.bitmap_size = 0;
        respattr->u.dirdata.dist_dir_attr.dirdata_count = 0;
        respattr->u.dirdata.dist_dir_attr.sid_count = 0;
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning dirent count of %lld\n",
                     lld(respattr->u.dirdata.dirent_count));
        break;
    case PVFS_TYPE_DATAFILE :
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning data size of %lld\n",
                     lld(respattr->u.data.size));
        break;
    case PVFS_TYPE_SYMLINK :
        if (js_p->error_code == 0)
        {
            assert(respattr->u.sym.target_path);
            assert(respattr->u.sym.target_path_len);
            /*
              adjust target path len down to actual size ; always
              include the null termination char in the target_path_len
            */
            respattr->u.sym.target_path_len =
                            (strlen(respattr->u.sym.target_path) + 1);

            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "  also returning link target of %s (len %d)\n",
                         respattr->u.sym.target_path,
                         respattr->u.sym.target_path_len);
        }
        else
        {
            gossip_err("Failed to retrieve symlink target path for "
                       "handle %s,%d\n",
                       PVFS_OID_str(&s_op->u.getattr.handle),
                       s_op->u.getattr.fs_id);
            PVFS_perror("Symlink retrieval failure",js_p->error_code);

            free_nested_getattr_data(s_op);
            js_p->error_code = -PVFS_EINVAL;
            return SM_ACTION_COMPLETE;
        }
        break;
    case PVFS_TYPE_DIRECTORY :
    {
        uint32_t dd_count_i;
        int bcount;
        unsigned char *c;

        /* !!! may change later */
        gossip_debug(GOSSIP_GETATTR_DEBUG, " SERVER RETURNING DIR:\n"
                     "\t\tdirent_count           = %llu \n"
                     "\t\tdirdata_max            = %d \n"
                     "\t\tdirdata_min            = %d \n"
                     "\t\tdirdata_count          = %d \n"
                     "\t\tsid_count              = %d \n"
                     "\t\ttree_height            = %d \n"
                     "\t\tbitmap_size            = %d \n"
                     "\t\tsplit_size             = %d \n"
                     "\t\tdfile_count(hint)      = %d \n"
                     "\t\tdist_name_len(hint)    = %d \n"
                     "\t\tdist_params_len(hint)  = %d \n",
                     llu(respattr->u.dir.dirent_count),
                     respattr->u.dir.dist_dir_attr.dirdata_max,
                     respattr->u.dir.dist_dir_attr.dirdata_min,
                     respattr->u.dir.dist_dir_attr.dirdata_count,
                     respattr->u.dir.dist_dir_attr.sid_count,
                     respattr->u.dir.dist_dir_attr.tree_height,
                     respattr->u.dir.dist_dir_attr.bitmap_size,
                     respattr->u.dir.dist_dir_attr.split_size,
                     respattr->u.dir.hint.dfile_count,
                     respattr->u.dir.hint.dist_name_len,
                     respattr->u.dir.hint.dist_params_len);

        /* gossip bitmap */
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     " server returning dist_dir_bitmap as:\n");

        for(bcount = respattr->u.dir.dist_dir_attr.bitmap_size - 1;
            bcount >= 0 ;
            bcount--)
        {
            c = (unsigned char *)(respattr->u.dir.dist_dir_bitmap + bcount);
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         " i=%d : %02x %02x %02x %02x\n",
                         bcount, c[3], c[2], c[1], c[0]);
        }

        gossip_debug(GOSSIP_GETATTR_DEBUG, "\n");

        for (dd_count_i = 0;
             dd_count_i < respattr->u.dir.dist_dir_attr.dirdata_count;
             dd_count_i++)
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "    dirdata_handle[%d] = %s\n", dd_count_i,
                         PVFS_OID_str(&respattr->u.dir.dirdata_handles[dd_count_i]));
        }
    }
    break;
    default :
    break;
    }

    if (respattr->mask & PVFS_ATTR_CAPABILITY)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning capability with mask %#x\n",
                     respattr->capability.op_mask);
    }

    gossip_debug(GOSSIP_GETATTR_DEBUG,"@ End %s attributes: sending "
                 "status %d (error = %d)\n",
                 PINT_util_get_object_type(respattr->objtype),
                 s_op->resp.status, js_p->error_code);

#if 1
    gossip_debug(GOSSIP_GETATTR_DEBUG, "returning attrmask\n");
    PINT_attrmask_print(GOSSIP_GETATTR_DEBUG,
                        s_op->resp.u.getattr.attr.mask);
#endif

    free_nested_getattr_data(s_op);
    return SM_ACTION_COMPLETE;
}

static void free_nested_getattr_data(struct PINT_server_op *s_op)
{
    /* free up anything that was set up specifically by this nested machine */
    free_keyval_buffers(s_op);

    if (s_op->u.getattr.mirror_dfile_status_array)
    {
        free(s_op->u.getattr.mirror_dfile_status_array);
        s_op->u.getattr.mirror_dfile_status_array = NULL;
    }

    return;
}

static PINT_sm_action getattr_with_prelude_init(struct PINT_smcb *smcb,
                                                job_status_s *js_p)
{
    PINT_perf_count(PINT_server_pc, PINT_PERF_GETATTR, 1, PINT_PERF_ADD);

    js_p->error_code = 0;    
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_setup_op(struct PINT_smcb *smcb,
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    memset(&s_op->resp.u.getattr.attr, 0, sizeof(PVFS_object_attr));
    s_op->resp.op = s_op->req->op;

    s_op->u.getattr.handle                    = s_op->req->u.getattr.handle;
    s_op->u.getattr.fs_id                     = s_op->req->u.getattr.fs_id;
    s_op->u.getattr.attrmask                  = s_op->req->u.getattr.attrmask;
    s_op->u.getattr.credential                = s_op->req->u.getattr.credential;
#if 0
    s_op->u.getattr.mirror_dfile_status_array = NULL;
#endif
    DEBUG_attr_mask(s_op->req->u.getattr.attrmask);

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_cleanup(struct PINT_smcb *smcb,
                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_GETATTR_DEBUG, "(%p) %s\n", s_op, __func__);

    PINT_perf_timer_end(PINT_server_tpc, PINT_PERF_TGETATTR, &s_op->start_time);
    getattr_free(s_op);
    return(server_state_machine_complete(smcb));
}

/*
 * Function: getattr_free
 *
 * Params:   server_op *s_op,
 *
 * Returns:  N/A
 *
 * Synopsis: free memory - can be called from outside this source file.
 *
 */
void getattr_free(struct PINT_server_op *s_op)
{
    free_keyval_buffers(s_op);

    PINT_free_object_attr(&s_op->resp.u.getattr.attr);
}

static int perm_getattr(PINT_server_op *s_op)
{
    int ret;

    ret = 0;

    return ret;
}

PINT_GET_OBJECT_REF_DEFINE(getattr);
PINT_GET_CREDENTIAL_DEFINE(getattr);

struct PINT_server_req_params pvfs2_get_attr_params =
{
    .string_name = "getattr",
    .perm = perm_getattr,
    .access_type = PINT_server_req_readonly,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_getattr,
    .get_credential = PINT_get_credential_getattr,
    .state_machine = &pvfs2_get_attr_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

