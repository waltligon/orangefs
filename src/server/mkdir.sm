/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */


#include <string.h>
#include <assert.h>

#include "pvfs2-config.h"
#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-util.h"
#include "pint-perf-counter.h"
#include "pvfs2-internal.h"
#include "pint-util.h"
#include "pint-security.h"
#include "pint-cached-config.h"
#include "pvfs2-dist-basic.h"
#include "dist-dir-utils.h"
#include "pint-uid-map.h"
#include "sid.h"

/*
static int tree_setattr_comp_fn(
        void *v_p,
        struct PVFS_server_resp *resp_p,
        int index);
*/

#define STATE_DIRDATA_DONE 1

%%

nested machine pvfs2_mkdir_work_sm
{
    state prep_sm
    {
        run mkdir_prep_sm;
        default => create;
    }

    /* create directory */

    state create
    {
        run mkdir_create;
        success => set_attrib;
        default => err_msg;
    }

    state set_attrib
    {
        run mkdir_setattrib;
        success => write_keyvals;
        default => err_msg;
    }

    state write_keyvals
    {
        run mkdir_write_keyvals;
        default => dirdata_create;
    }

    /* create local dirdata */
    /* this loops to allow multiple local dirdata */

    state dirdata_create
    {
        run mkdir_dirdata_create;
        STATE_DIRDATA_DONE => setup_dirdata_create;
        default => dirdata_attribs;
    }

    state dirdata_attribs
    {
        run mkdir_dirdata_attribs;
        default => dirdata_keyval;
    }

    state dirdata_keyval
    {
        run mkdir_dirdata_keyvals;
        default => dirdata_create;
    }

    /* create remote dirdatas */
    /* eventually we want this PJMP so we can return before completion */

    state setup_dirdata_create
    {
        run setup_dirdata_create;
        STATE_DIRDATA_DONE => setup_getattr_request;
        success => initiate_dirdata_create;
        default => err_msg;
    }

    state initiate_dirdata_create
    {
        jump pvfs2_msgpairarray_sm;
        success => setup_getattr_request;
        default => err_msg;
    }

    /* getattr for response */

    state setup_getattr_request
    {
        run mkdir_setup_getattr_request;
        success => initiate_getattr_request;
        default => err_msg;
    }

    state initiate_getattr_request
    {
        jump pvfs2_get_attr_with_prelude_sm;
        default => setup_resp;
    }

    /* create the response to the client */

    state setup_resp
    {
        run mkdir_setup_response;
        default => return;
    }

    state err_msg 
    {
        run mkdir_error;
        default => return;
    }
}

machine pvfs2_mkdir_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => work;
        default => final_response;
    }

    state work
    {
        jump pvfs2_mkdir_work_sm;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run mkdir_cleanup;
        default => terminate;
    }
}

%%

/*
 * Function: mkdir_prep_sm
 *
 * Params:   server_op *s_op, 
 *           job_status_s *js_p
 *
 * Returns:  int
 *
 * Synopsis: Creates initializes state machine variables for mkdir
 *
 */

static PINT_sm_action mkdir_prep_sm(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *dir_attr = NULL;
    PVFS_ds_attributes *ds_attr = NULL;
    PVFS_uid uid;
    uint32_t num_groups;
    PVFS_gid group_array[PVFS_REQ_LIMIT_GROUPS];
    int ret;

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    /* This is the first true state action of the mkdir SM so
     * increment the counter for mkdir requests
     */
    PINT_perf_count(PINT_server_pc, PINT_PERF_MKDIR, 1, PINT_PERF_ADD);
    
    /* set up key fields */
    s_op->key_a = NULL;
    s_op->val_a = NULL;
    s_op->error_a = NULL;

    /*** SET UP ATTRIBUTES ***/
    /* The request provides a set of object attributes (s_op->req->u.mkdir.attr).
     * Prelude leaves "target" dir attrs in (s_op->attr) and (s_op->ds_attr).
     *
     * We need to create a set of ds attributes for writing to storage (s_op->ds_attr).
     * We will modify the req obj attr and convert them to ds_attrs at the end.
     * There are shortcut pointers (dir_attr, ds_attr) to these structs.
     * 
     * The request attrs have already had the compiled-in and config file defaults
     * incorporated, as well as the parent attrs and hints by the client code.
     *
     * This code should verify the values make sense as a precaution.  Assumes
     * we kinda trust client to ask for what it wants, but not with the details.
     *
     * MKDIR does not do a prelude lookup - see the bottom of this file where a NULL
     * handle is returned by the call back.  We also don't auto-create an object
     * with prelude, so the attributes in s_op->attr should NEVER be real.  Thus the
     * No Parent!!! comments, if they still exist are meaningless.  Instead we seem
     * to be putting some attribute information into these slots as a placeholder???
     */

    dir_attr = &(s_op->req->u.mkdir.attr);
    ds_attr = (&s_op->ds_attr);

#if 0
    if (dir_attr->u.dir.dist_dir_attr.dirdata_count < 1)
    {
    /* !!!!!!!!! No Parent !!!!! */
        s_op->attr.u.dir.dirdata_handles = NULL;
        s_op->attr.u.dir.dist_dir_bitmap = NULL;
        s_op->attr.u.dir.dirdata_sids    = NULL;
    }
    else
    {
        s_op->attr.u.dir.dist_dir_attr.dirdata_count = 
                         s_op->req->u.mkdir.dirdata_count;
        s_op->attr.u.dir.dist_dir_attr.sid_count =
                         s_op->req->u.mkdir.dirdata_sid_count;

        s_op->attr.u.dir.dirdata_handles = 
                         s_op->req->u.mkdir.dirdata_handles;
        s_op->attr.u.dir.dirdata_sids = 
                         s_op->req->u.mkdir.dirdata_sid_array;
    }
#endif

    /* Restore attribute pointers zero'd out in sys-mkdir.sm */
    dir_attr->parent = s_op->req->u.mkdir.parent;
    dir_attr->parent_sids = s_op->req->u.mkdir.parent_sid_array;
    dir_attr->meta_sid_count = s_op->req->u.mkdir.sid_count;
    dir_attr->u.dir.dirdata_handles = s_op->req->u.mkdir.dirdata_handles;
    dir_attr->u.dir.dirdata_sids = s_op->req->u.mkdir.dirdata_sid_array;
    dir_attr->u.dir.dist_dir_attr.dirdata_count = s_op->req->u.mkdir.dirdata_count;
    dir_attr->u.dir.dist_dir_attr.sid_count = s_op->req->u.mkdir.dirdata_sid_count;
    dir_attr->u.dir.dist_dir_attr.bitmap_size = 1;
    dir_attr->u.dir.dirent_count = 0; /* new dir so no entries */
    

    s_op->u.mkdir.fs_id = s_op->req->u.mkdir.fs_id;
    s_op->u.mkdir.handle = s_op->req->u.mkdir.handle;

    if (dir_attr->objtype != PVFS_TYPE_DIRECTORY)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* map owner/group from credential */
    if (dir_attr->mask & (PVFS_ATTR_COMMON_UID|PVFS_ATTR_COMMON_GID) &&
        (dir_attr->owner == PVFS_UID_MAX || dir_attr->group == PVFS_GID_MAX))
    {
        ret  = PINT_map_credential(&s_op->req->u.mkdir.credential, 
                                   &uid, &num_groups, group_array);
        if (ret != 0)
        {
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }

        if (dir_attr->mask & PVFS_ATTR_COMMON_UID &&
            dir_attr->owner == PVFS_UID_MAX)
        {
            dir_attr->owner = uid;
        }

        if (dir_attr->mask & PVFS_ATTR_COMMON_GID &&
            dir_attr->group == PVFS_GID_MAX)
        {
            dir_attr->group = group_array[0];
        }
    }

    gossip_debug(GOSSIP_MKDIR_DEBUG, " attrs to write: [owner = %d, "
                 "group = %d, perms = %o]\n", dir_attr->owner, dir_attr->group,
                 dir_attr->perms);

    /* set up the dist-dir-state portion of the attributes
     * pointed to by dir_attr attributes in the mkdir request
     * which are the directory attributes.
     *
     * this does not affect dist_dir_attr fields dirdata_min, dirdata_max,
     * dirdata_count.  server_no branch_level are the only signed fields and
     * usually start as -1
     */
    ret = PINT_init_dist_dir_state(&dir_attr->u.dir.dist_dir_attr,
                                   &dir_attr->u.dir.dist_dir_bitmap,
                                   s_op->req->u.mkdir.dirdata_count,
                                   s_op->req->u.mkdir.dirdata_sid_count,
                                   0, /* server_no -1 for meta objects */
                                   s_op->req->u.mkdir.dist_dir_servers_initial,
                                   s_op->req->u.mkdir.dist_dir_split_size);

#if 0
    /* most if not all of this should be set up on the client */

/* parent hints should have been consulted on client */
/* !!!!!!!!! No Parent !!!!! */
    if (dir_attr->u.dir.dist_dir_attr.dirdata_count < 1)
    {
        /* check for parent hint */
        if (s_op->attr.u.dir.hint.dir_dirdata_min > 0)
        {
            dir_attr->u.dir.dist_dir_attr.dirdata_count = 
                            s_op->attr.u.dir.hint.dir_dirdata_min;
        }
        else
        {
            /* look up default */
        }
    }
#endif

/* !!!!!!!!! No Parent !!!!! */
    if (dir_attr->u.dir.dist_dir_attr.dirdata_count < 1)
    {
    }
/* this might be totally useless */
#if 0
    if (dir_attr->u.dir.dist_dir_attr.sid_count < 1)
    {
        /* check for parent hint */
        if (s_op->attr.u.dir.hint.sid_count > 0)
        {
            dir_attr->u.dir.dist_dir_attr.sid_count = s_op->attr.u.dir.hint.sid_count;
        }
        else
        {
            /* look up default */
        }
    }
#endif

    if (ret != 0)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

#if 0
/* !!!!!!!!! No Parent !!!!! */
    if (dir_attr->u.dir.dist_dir_attr.dirdata_count < 1)
    {
        /* inherit hints from parent */
        memcpy(&dir_attr->u.dir.hint, &s_op->attr.u.dir.hint, sizeof(PVFS_directory_hint));
    }
    /* copy distribution parameters string */
    if (s_op->attr.u.dir.hint.dist_params_len > 0 && s_op->attr.u.dir.hint.dist_params)
    {
        dir_attr->u.dir.hint.dist_params = strdup(s_op->attr.u.dir.hint.dist_params);
    }
    else
    {
        dir_attr->u.dir.hint.dist_params = NULL;
        dir_attr->u.dir.hint.dist_params_len = 0;
    }
    /* copy distribution name string */
    if (s_op->attr.u.dir.hint.dist_name_len > 0 && s_op->attr.u.dir.hint.dist_name)
    {
        dir_attr->u.dir.hint.dist_name = strdup(s_op->attr.u.dir.hint.dist_name);
    }
    else
    {
        /* if name is missing, there is no dist so zero it all */
        dir_attr->u.dir.hint.dist_name = NULL;
        dir_attr->u.dir.hint.dist_name_len = 0;
        free(dir_attr->u.dir.hint.dist_params);
        dir_attr->u.dir.hint.dist_params = NULL;
        dir_attr->u.dir.hint.dist_params_len = 0;
    }
#endif

    /* struct specific gossip macros defined in src/common/misc/dist-dir-utils.h */
    PINT_debug_dist_dir_attr(GOSSIP_MKDIR_DEBUG, dir_attr->u.dir.dist_dir_attr);
    PINT_debug_dist_dir_bitmap(GOSSIP_MKDIR_DEBUG, dir_attr->u.dir.dist_dir_attr,
                               dir_attr->u.dir.dist_dir_bitmap);

#if 0
    /* moved earlier */

    /* last couple of things to set up before we convert to ds_attr */
    dir_attr->u.dir.dirdata_handles = s_op->req->u.mkdir.dirdata_handles;
    dir_attr->u.dir.dirdata_sids = s_op->req->u.mkdir.dirdata_sid_array;
    dir_attr->u.dir.dirent_count = 0; /* new dir so no entries */
/* !!!!!!!!! No Parent !!!!! */
    if (dir_attr->u.dir.dist_dir_attr.dirdata_count < 1)
    {
        dir_attr->meta_sid_count = s_op->attr.meta_sid_count; /* get from parent */
    }
#endif

    /* translate attrs to storage attr format */
    PVFS_ds_attr_from_object_attr(ds_attr, dir_attr);

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/*
 * Function: mkdir_create
 *
 * Params:   server_op *s_op, 
 *           job_status_s *js_p
 *
 * Returns:  int
 *
 * Synopsis: Creates dspace record for the new DIR
 *
 */
static PINT_sm_action mkdir_create(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    job_id_t i;

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    gossip_debug(GOSSIP_MKDIR_DEBUG, " creating dspace on coll_id %d\n",
                 s_op->u.mkdir.fs_id);

    gossip_debug(GOSSIP_MKDIR_DEBUG, " directory handle will be %s\n",
                 PVFS_OID_str(&s_op->u.mkdir.handle));

    ret = job_trove_dspace_create(s_op->u.mkdir.fs_id,
                                  s_op->u.mkdir.handle,
                                  PVFS_TYPE_DIRECTORY,
                                  NULL,       /* hint */
                                  TROVE_SYNC, /* flags */
                                  smcb,       /* user_ptr */
                                  0,          /* status_user_tag */
                                  js_p,
                                  &i,
                                  server_job_context,
                                  s_op->req->hints);

    return ret;
}

/*
 * Function: mkdir_setattrib
 *
 * Params:   server_op *s_op, 
 *           job_status_s *js_p
 *
 * Returns:  int
 *
 * Synopsis: Writes the ds_attr to the new directory dspace record
 *           
 */
static PINT_sm_action mkdir_setattrib(struct PINT_smcb *smcb,
                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t j_id;
    PVFS_ds_attributes *ds_attr = NULL;

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    ds_attr = (&s_op->ds_attr);
    PVFS_ds_init_time(ds_attr); /* this determines the time of dir creation */

    gossip_debug(GOSSIP_MKDIR_DEBUG, " writing directory attributes (ds):\n\t\t"
                 "object type     %d\n\t\t"
                 "uid             %d\n\t\t"
                 "gid             %d\n\t\t"
                 "mode            %d\n\t\t"
                 "meta_sids       %d\n\t\t"
                 "dirent_count    %d\n\t\t"
                 "tree_height     %d\n\t\t"
                 "dirdata_count   %d\n\t\t"
                 "bitmap_size     %d\n\t\t"
                 "split_size      %d\n\t\t"
                 "branch_level    %d\n",
                 ds_attr->type, ds_attr->uid, ds_attr->gid, ds_attr->mode,
                 ds_attr->meta_sid_count,
                 (int)ds_attr->u.directory.dirent_count,
                 ds_attr->u.directory.tree_height,
                 ds_attr->u.directory.dirdata_count,
                 ds_attr->u.directory.bitmap_size,
                 ds_attr->u.directory.split_size,
                 ds_attr->u.directory.branch_level);


    ret = job_trove_dspace_setattr(s_op->u.mkdir.fs_id,
                                   s_op->u.mkdir.handle,
                                   ds_attr, 
                                   TROVE_SYNC,
                                   smcb,
                                   0,
                                   js_p,
                                   &j_id,
                                   server_job_context,
                                   s_op->req->hints);

    return ret;
}

/** writes 3 keyvals for the new directory - the bitmap, the handles
 * of the dirdata objects and the parent PLUS dirhint keyvals
 */
static PINT_sm_action mkdir_write_keyvals(struct PINT_smcb *smcb,
                                          job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *pattr;
    int ret = -1;
    job_id_t j_id;
    int k = 0;

    /* total 3 static keyvals every dir has:
     * PVFS_DIRDATA_BITMAP, PVFS_DIRDATA_HANDLES, PARENT */
    int keyval_count = 3;

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    /* free saved capability */
/*
    PINT_cleanup_capability(s_op->u.mkdir.saved_capability);
    s_op->u.mkdir.saved_capability = NULL;
*/
    pattr = &s_op->req->u.mkdir.attr;

    /* we need to know how many attributes we are going to set 
     * before we can allocated the key_a and val_a arrays
     */
    if (pattr->mask & PVFS_ATTR_DIR_HINT)
    {
        /*
        if (pattr->u.dir.hint.dfile_count > 0)
        {
            keyval_count++;
        }
        */
        if (pattr->u.dir.hint.dist_name_len > 0)
        {
            keyval_count++;
        }
        if (pattr->u.dir.hint.dist_params_len > 0)
        {
            keyval_count++;
        }
        /*
        if (pattr->u.dir.hint.layout.algorithm > PVFS_SYS_LAYOUT_NONE &&
            pattr->u.dir.hint.layout.algorithm <= PVFS_SYS_LAYOUT_MAX)
        {
            keyval_count++;
        }
        */
        if (pattr->u.dir.hint.layout.server_list.count > 0)
        {
            keyval_count++;
        }
        /*
        if (pattr->u.dir.hint.dir_layout.algorithm > PVFS_SYS_LAYOUT_NONE &&
            pattr->u.dir.hint.dir_layout.algorithm <= PVFS_SYS_LAYOUT_MAX)
        {
            keyval_count++;
        }
        */
        if (pattr->u.dir.hint.dir_layout.server_list.count > 0)
        {
            keyval_count++;
        }
    }

    s_op->key_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->key_a)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->key_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    s_op->val_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->val_a)
    {
        free(s_op->key_a);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->val_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    s_op->key_a[0].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].size;
    s_op->key_a[0].buffer = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].key;

    s_op->val_a[0].buffer_sz = pattr->u.dir.dist_dir_attr.bitmap_size * 
                               sizeof(PVFS_dist_dir_bitmap_basetype);
    s_op->val_a[0].buffer = pattr->u.dir.dist_dir_bitmap;
    keep_keyval_buffers(s_op, 0);

    s_op->key_a[1].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].size;
    s_op->key_a[1].buffer = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].key;

    s_op->val_a[1].buffer_sz = OSASZ(pattr->u.dir.dist_dir_attr.dirdata_count,
                                     pattr->u.dir.dist_dir_attr.sid_count);
    s_op->val_a[1].buffer = pattr->u.dir.dirdata_handles;
    keep_keyval_buffers(s_op, 1);

    /* parent of directory is passed from client */
    s_op->key_a[2].buffer_sz = Trove_Common_Keys[OBJECT_PARENT_KEY].size;
    s_op->key_a[2].buffer = Trove_Common_Keys[OBJECT_PARENT_KEY].key;

    s_op->val_a[2].buffer_sz = OSASZ(1, s_op->req->u.mkdir.sid_count);
    s_op->val_a[2].buffer = s_op->req->u.mkdir.parent;
    keep_keyval_buffers(s_op, 2);

    /* set up directory hint attributes */
    k = 3;
    if (pattr->mask & PVFS_ATTR_DIR_HINT)
    {
#if 0
        if (pattr->u.dir.hint.dfile_count > 0)
        {
    int slen; /* length of conversion strings */
            /* convert to string */
            s_op->key_a[k].buffer = Trove_Special_Keys[NUM_DFILES_KEY].key;
            s_op->key_a[k].buffer_sz = Trove_Special_Keys[NUM_DFILES_KEY].size;

            s_op->val_a[k].buffer = (void *)malloc(10);
            if (!s_op->val_a[k].buffer)
            {
                js_p->error_code = -PVFS_ENOMEM;
                return SM_ACTION_COMPLETE;
            }
            slen = snprintf(s_op->val_a[k].buffer,
                            10,
                            "%05d",
                            pattr->u.dir.hint.dfile_count);
            s_op->val_a[k].buffer_sz = slen + 1;
            k++;
        }
#endif
        if (pattr->u.dir.hint.dist_name_len > 0)
        {
            s_op->key_a[k].buffer = Trove_Special_Keys[DIST_NAME_KEY].key;
            s_op->key_a[k].buffer_sz = Trove_Special_Keys[DIST_NAME_KEY].size;

            s_op->val_a[k].buffer = pattr->u.dir.hint.dist_name;
            s_op->val_a[k].buffer_sz = pattr->u.dir.hint.dist_name_len;
            keep_keyval_buffers(s_op, k);
            k++;
        }
        if (pattr->u.dir.hint.dist_params_len > 0)
        {
            s_op->key_a[k].buffer = Trove_Special_Keys[DIST_PARAMS_KEY].key;
            s_op->key_a[k].buffer_sz = Trove_Special_Keys[DIST_PARAMS_KEY].size;

            s_op->val_a[k].buffer = pattr->u.dir.hint.dist_params;
            s_op->val_a[k].buffer_sz = pattr->u.dir.hint.dist_params_len;
            keep_keyval_buffers(s_op, k);
            k++;
        }
#if 0
        if (pattr->u.dir.hint.layout.algorithm > PVFS_SYS_LAYOUT_NONE &&
            pattr->u.dir.hint.layout.algorithm <= PVFS_SYS_LAYOUT_MAX)
        {
            /* convert to string */
            s_op->key_a[k].buffer = Trove_Special_Keys[LAYOUT_KEY].key;
            s_op->key_a[k].buffer_sz = Trove_Special_Keys[LAYOUT_KEY].size;
            s_op->val_a[k].buffer = (void *)malloc(10);
            if (!s_op->val_a[k].buffer)
            {
                js_p->error_code = -PVFS_ENOMEM;
                return SM_ACTION_COMPLETE;
            }
            slen = snprintf(s_op->val_a[k].buffer,
                            10,
                            "%05d",
                            pattr->u.dir.hint.layout.algorithm);
            s_op->val_a[k].buffer_sz = slen + 1;
            k++;
        }
#endif
        if (pattr->u.dir.hint.layout.server_list.count > 0)
        {
            s_op->key_a[k].buffer = Trove_Special_Keys[SERVER_LIST_KEY].key;
            s_op->key_a[k].buffer_sz = Trove_Special_Keys[SERVER_LIST_KEY].size;
            s_op->val_a[k].buffer = pattr->u.dir.hint.layout.server_list.servers;
            s_op->val_a[k].buffer_sz = pattr->u.dir.hint.layout.server_list.bufsize;
            keep_keyval_buffers(s_op, k);
            k++;
        }
        if (pattr->u.dir.hint.dir_layout.server_list.count > 0)
        {
            s_op->key_a[k].buffer = Trove_Special_Keys[DIR_SERVER_LIST_KEY].key;
            s_op->key_a[k].buffer_sz = Trove_Special_Keys[DIR_SERVER_LIST_KEY].size;
            s_op->val_a[k].buffer = pattr->u.dir.hint.dir_layout.server_list.servers;
            s_op->val_a[k].buffer_sz = pattr->u.dir.hint.dir_layout.server_list.bufsize;
            keep_keyval_buffers(s_op, k);
            k++;
        }
    /* not sure we have KEYs and such set up for this */
    #if 0
        if (pattr->u.dir.hint.dir_layout.algorithm > PVFS_SYS_LAYOUT_NONE &&
            pattr->u.dir.hint.dir_layout.algorithm <= PVFS_SYS_LAYOUT_MAX)
        {
            /* convert to string */
            s_op->key_a[k].buffer = Trove_Special_Keys[LAYOUT_KEY].key;
            s_op->key_a[k].buffer_sz = Trove_Special_Keys[LAYOUT_KEY].size;
            s_op->val_a[k].buffer = (void *)malloc(10);
            if (!s_op->val_a[k].buffer)
            {
                js_p->error_code = -PVFS_ENOMEM;
                return SM_ACTION_COMPLETE;
            }
            slen = snprintf(s_op->val_a[k].buffer,
                            10,
                            "%05d",
                            pattr->u.dir.hint.dir_layout.algorithm);
            s_op->val_a[k].buffer_sz = slen + 1;
            k++;
        }
        if (pattr->u.dir.hint.dir_layout.server_list.count > 0)
        {
            s_op->key_a[k].buffer = Trove_Special_Keys[SERVER_LIST_KEY].key;
            s_op->key_a[k].buffer_sz = Trove_Special_Keys[SERVER_LIST_KEY].size;
            s_op->val_a[k].buffer = pattr->u.dir.hint.dir_layout.server_list.servers;
            s_op->val_a[k].buffer_sz = pattr->u.dir.hint.dir_layout.server_list.bufsize;
            keep_keyval_buffers(s_op, k);
            k++;
        }
#endif
    }
    if (k != keyval_count)
    {
        gossip_lerr("error building args for new dir attributes\n");
    }

    gossip_debug(GOSSIP_MKDIR_DEBUG, 
            "  writing kvals for meta handle: %s "
            "\t with server_no=%d and branch_level=%d \n", 
            PVFS_OID_str(&s_op->u.mkdir.handle),
            pattr->u.dir.dist_dir_attr.server_no,
            pattr->u.dir.dist_dir_attr.branch_level);

    ret = job_trove_keyval_write_list(
                                  s_op->req->u.mkdir.fs_id,
                                  s_op->u.mkdir.handle, /* meta handle */
                                  s_op->key_a,
                                  s_op->val_a,
                                  keyval_count,
                                  TROVE_SYNC, /* flags */
                                  NULL,       /* vtag */
                                  smcb,       /* user_ptr */
                                  0,          /* status_user_tag */
                                  js_p,
                                  &j_id,
                                  server_job_context,
                                  s_op->req->hints);

    /* dirdata_index is defined but not used in s_op so
     * for now I'm co-opting it - if it is needed later for
     * tree stuff we will have to solve the conflict, probably
     * by renaming this variable
     */

    s_op->u.mkdir.dirdata_index = s_op->req->u.mkdir.dirdata_count;
    s_op->u.mkdir.rmt_dirdata_index = 0;
    s_op->u.mkdir.rmt_dirdata_array = (int *)calloc(s_op->req->u.mkdir.dirdata_count + 1,
                                                    sizeof(int));

    return ret;
}

/*
 * Function: mkdir_dirdata_create
 *
 * Synopsis: Create dspace record for DIRDATA object
 *
 */

static PINT_sm_action mkdir_dirdata_create(struct PINT_smcb *smcb,
                                           job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    job_id_t j_id;
    int i = 0;
    int j = 0;

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    /* dirdata_index is apparently NOT an index but is the NUMBER of dirdata's so we
     * convert it into an index in i so we can loop from N-1 .. 0 over the dirdata's
     * and decide if they are local or remote
     */

    i = s_op->u.mkdir.dirdata_index - 1;
    j = s_op->u.mkdir.rmt_dirdata_index - 1;

    /* find dirdata on this server and create it */
    for (; i >= 0; i--)
    {
        /* test for local */
        if (PINT_cached_config_server_local(
                        &s_op->req->u.mkdir.dirdata_sid_array[i]))
        {
            /* equals so go create it - we will loop back to this state with
             * dirdata_index suitably adjustd and continue our search
             */
            gossip_debug(GOSSIP_MKDIR_DEBUG, "Local DIRDATA to create i = %d\n", i);
            break;
        }
        else
        {
            /* this is a remote dirdata, so we need to set it up for later
             */
            gossip_debug(GOSSIP_MKDIR_DEBUG, "Remote DIRDATA to create i = %d\n", i);
            s_op->u.mkdir.rmt_dirdata_array[j++] = i;
        }
    }
    /* this resets dirdata_index for the next call to this state */
    s_op->u.mkdir.dirdata_index = i;
    s_op->u.mkdir.rmt_dirdata_index = j;

    /* if i is zero there are no more dirdata to test/create */
    if (i < 0)
    {
        gossip_debug(GOSSIP_STATE_MACHINE_DEBUG, "error code: 1 is SM branch control\n");
        js_p->error_code = STATE_DIRDATA_DONE;
        return SM_ACTION_COMPLETE;
    }

    /* when we create the local dirdata (if there is one) we need a buffer of the
     * dirdata's parent with OID and SIDs.  The newly created directory object is
     * the parent of the dirdatas, so we get that right out of the request.  We
     * will reuse the buffer for multiple dirdatas if needed and then free in the
     * cleanup state.
     */

    if (!s_op->u.mkdir.dirdata_parent_buffer)
    {
        char *p;

        s_op->u.mkdir.dirdata_parent_buffer =
                malloc(OSASZ(1, s_op->req->u.mkdir.sid_count));

        p = (char *)s_op->u.mkdir.dirdata_parent_buffer;
        ZEROMEM(p, OSASZ(1, s_op->req->u.mkdir.sid_count));

        memcpy((void *)p, (void *)&s_op->req->u.mkdir.handle, sizeof(PVFS_OID));
        p += sizeof(PVFS_OID);

        memcpy((void *)p,
               (void *)s_op->req->u.mkdir.sid_array, 
               sizeof(PVFS_SID) * s_op->req->u.mkdir.sid_count);
    }

    gossip_debug(GOSSIP_MKDIR_DEBUG, " creating local dirdata dspace on coll_id %d\n",
                 s_op->u.mkdir.fs_id);

    gossip_debug(GOSSIP_MKDIR_DEBUG, " dirdata handle will be %s\n",
                 PVFS_OID_str(&s_op->req->u.mkdir.dirdata_handles[i]));

    ret = job_trove_dspace_create(s_op->u.mkdir.fs_id,
                                  s_op->req->u.mkdir.dirdata_handles[i],
                                  PVFS_TYPE_DIRDATA,
                                  NULL,       /* hint */
                                  TROVE_SYNC, /* flags */
                                  smcb,       /* user_ptr */
                                  0,          /* status_user_tag */
                                  js_p,
                                  &j_id,
                                  server_job_context,
                                  s_op->req->hints);

    return ret;
}

/*
 * Function: mkdir_dirdata_attribs
 *
 * Synopsis: Update attribs local dspace record for the DIRDATA object
 *
 */

static PINT_sm_action mkdir_dirdata_attribs(struct PINT_smcb *smcb,
                                            job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;
    int ret = -1;
    job_id_t j_id;

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    i = s_op->u.mkdir.dirdata_index;
    PVFS_ds_attributes *ds_attr = NULL;

    /* writing the same attributes from the directory */
    /* in fact we can zap a few of them that are not valid
     */
    ds_attr = (&s_op->ds_attr);
    ds_attr->type = PVFS_TYPE_DIRDATA;
    ds_attr->handle = s_op->req->u.mkdir.dirdata_handles[i];
    ds_attr->uid = 0;
    ds_attr->gid = 0;
    ds_attr->mode = 0;
    ds_attr->u.dirdata.server_no = i;

    /* do not update time here - keep the original time until
     * something modifies this dirdata, the time on this object
     * should be identical to the dir
     */

    gossip_debug(GOSSIP_MKDIR_DEBUG, " setting dirdata version to "
                 "%llu\n\tmtime is %llu\n", llu(ds_attr->mtime),
                 llu(PINT_util_mkversion_time(ds_attr->mtime)));

    ret = job_trove_dspace_setattr(s_op->u.mkdir.fs_id,
                                   s_op->req->u.mkdir.dirdata_handles[i],
                                   ds_attr,
                                   TROVE_SYNC,
                                   smcb,
                                   0,
                                   js_p,
                                   &j_id,
                                   server_job_context,
                                   s_op->req->hints);

    return ret;
}

/*
 * Function: mkdir_dirdata_keyvals
 *
 * Synopsis: Create local keyval records for the DIRDATA object
 *
 */

static PINT_sm_action mkdir_dirdata_keyvals(struct PINT_smcb *smcb,
                                            job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;
    PVFS_object_attr *pattr = NULL;
    int ret = -1;
    job_id_t j_id;
    int k = 0;

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    /* total 3 static keyvals every dirdata has:
     * PVFS_DIRDATA_BITMAP, PVFS_DIRDATA_HANDLES, PARENT */
    int keyval_count = 3;

    pattr = &s_op->req->u.mkdir.attr;

    s_op->key_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->key_a)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->key_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    s_op->val_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->val_a)
    {
        free(s_op->key_a);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->val_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    s_op->key_a[0].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].size;
    s_op->key_a[0].buffer = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].key;

    s_op->val_a[0].buffer_sz = pattr->u.dir.dist_dir_attr.bitmap_size *
                               sizeof(PVFS_dist_dir_bitmap_basetype);
    s_op->val_a[0].buffer = pattr->u.dir.dist_dir_bitmap;
    keep_keyval_buffers(s_op, 0);

    s_op->key_a[1].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].size;
    s_op->key_a[1].buffer = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].key;

    s_op->val_a[1].buffer_sz = OSASZ(pattr->u.dir.dist_dir_attr.dirdata_count,
                                     pattr->u.dir.dist_dir_attr.sid_count);
    s_op->val_a[1].buffer = pattr->u.dir.dirdata_handles;
    keep_keyval_buffers(s_op, 1);

    /* parent of dirdata is the directory, handle passed up from client */
    s_op->key_a[2].buffer_sz = Trove_Common_Keys[OBJECT_PARENT_KEY].size;
    s_op->key_a[2].buffer = Trove_Common_Keys[OBJECT_PARENT_KEY].key;

    s_op->val_a[2].buffer_sz = OSASZ(1, s_op->req->u.mkdir.sid_count);
    s_op->val_a[2].buffer = s_op->u.mkdir.dirdata_parent_buffer;
    keep_keyval_buffers(s_op, 2);

    if (k != keyval_count)
    {
        gossip_lerr("error building args for new dir attributes\n");
    }

    i = s_op->u.mkdir.dirdata_index;
    pattr->u.dir.dist_dir_attr.server_no = i;

    gossip_debug(GOSSIP_MKDIR_DEBUG,
            "  writing dist-dir-struct keyvals for dirdata: %s "
            "\t with server_no=%d and branch_level=%d \n",
            PVFS_OID_str(&s_op->req->u.mkdir.dirdata_handles[i]),
            pattr->u.dir.dist_dir_attr.server_no,
            pattr->u.dir.dist_dir_attr.branch_level);

    ret = job_trove_keyval_write_list(
                                  s_op->req->u.mkdir.fs_id,
                                  s_op->req->u.mkdir.dirdata_handles[i],
                                  s_op->key_a,
                                  s_op->val_a,
                                  keyval_count,
                                  TROVE_SYNC, /* flags */
                                  NULL,       /* vtag */
                                  smcb,       /* user_ptr */
                                  0,          /* status_user_tag */
                                  js_p,
                                  &j_id,
                                  server_job_context,
                                  s_op->req->hints);
    return ret;
}

/*
 * Function: setup_dirdata_create
 *
 * Synopsis: Setup to send requests to servers that will hold a remote dirdata for
 * this directory - locals have already been created.
 *
 */

static PINT_sm_action setup_dirdata_create(struct PINT_smcb *smcb,
                                           job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0, h = 0;
    PINT_sm_msgpair_state *msg_p = NULL;
    PVFS_capability capability;
    PVFS_object_attr *pattr = NULL;;

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    /* we are bypassing this stepfor now - might try to add it back using
     * a PJMP to prevent delaying the end of the request but for now we
     * assume remote dirdatas are created on demand at the server when a
     * request accesses them.
     */
    gossip_debug(GOSSIP_STATE_MACHINE_DEBUG, "error code: 1 is SM branch control\n");
    js_p->error_code = STATE_DIRDATA_DONE;
    return SM_ACTION_COMPLETE;

    /* set up for an array of requests */
    ret = PINT_msgpairarray_init(&s_op->msgarray_op, s_op->u.mkdir.rmt_dirdata_index);
    if (ret != 0)
    {
        gossip_err("mkdir: setattr failed to initialize %d msgpairs\n",
                   s_op->u.mkdir.rmt_dirdata_index);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }
    
    /* we need to set up the attributes, do as we did a few states above
     * zero out a couple, change a couple.  the only objattr we have is in
     * the request, we either copy it, or change it and hope we don't need
     * it again.  Going to try the latter.  Note handle is edited inside the
     * loop below.
     */
    pattr = (&s_op->req->u.mkdir.attr);
    pattr->objtype = PVFS_TYPE_DIRDATA;
    pattr->owner = 0;
    pattr->group = 0;
    pattr->perms = 0;
    pattr->parent = s_op->u.mkdir.dirdata_parent_buffer;
    pattr->parent_sids = (PVFS_SID *)(pattr->parent + 1);

    /* need to setup capability for server-to-server */
    PINT_null_capability(&capability);

    foreach_msgpair(&s_op->msgarray_op, msg_p, h)
    {
        /* these are needed in both msg_p and req */
        msg_p->fs_id = s_op->req->u.mkdir.fs_id;
        /* this picks the remote handles - computed earlier */
        msg_p->handle = s_op->req->u.mkdir.dirdata_handles[h];
        msg_p->sid_array = &s_op->req->u.mkdir.sid_array[h * s_op->req->u.mkdir.sid_count];
        msg_p->sid_count = s_op->req->u.mkdir.sid_count;

        PINT_SERVREQ_SETATTR_FILL(msg_p->req,
                                  PVFS_REQ_DIRDATA, /* sub_op req type */
                                  capability,
                                  s_op->req->u.mkdir.credential,
                                  msg_p->fs_id,
                                  msg_p->handle,
                                  msg_p->sid_count,
                                  msg_p->sid_array,
                                  s_op->req->u.mkdir.attr, 
                                  NULL);

        msg_p->msgclass = PVFS_IO_METADATA;
        msg_p->msgdir = PVFS_IO_WRITE;
        msg_p->sid_index = 0; /* indexes sid_array. h used above to compute sid_array. */
        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
        msg_p->comp_fn = NULL;

        PVFS_debug_servreq_setattr(GOSSIP_SETATTR_DEBUG, &(msg_p->req.u.setattr));

        /* This sets svr_addr for BMI */
        ret = PVFS_SID_get_addr(&msg_p->svr_addr, msg_p->sid_array);
        if (ret)
        {
            gossip_err("Failed to map meta server address\n");
            js_p->error_code = ret;
            /* need to return this error - handle in SM? */
        }
        else
        {
            js_p->error_code = 0;
        }
    }

    ret = PINT_sm_push_frame(smcb, 0, &s_op->msgarray_op);
    if ( ret < 0 )
    {
       gossip_err("%s:Error pushing setattr frame onto mkdir stack:ret(%d)\n",
                   __func__, ret);
       js_p->error_code = ret;
       return SM_ACTION_COMPLETE;
    }

    js_p->error_code = ret;
    return SM_ACTION_COMPLETE;
}

/*
 * Function: mkdir_setup_getattr_request
 *
 * Synopsis: Retrieve information about the new directory to return to the
 * client.
 *
 */

static PINT_sm_action mkdir_setup_getattr_request(
                                            struct PINT_smcb *smcb,
                                            job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *getattr_op;
    int ret = 0;
    PVFS_capability capability;

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    getattr_op = calloc(1, sizeof(*getattr_op));
    if ( !getattr_op )
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    PINT_null_capability(&capability);

    getattr_op->req = &getattr_op->decoded.stub_dec.req;        

    PINT_SERVREQ_GETATTR_FILL(*getattr_op->req,
                              PVFS_REQ_OTHER,
                              capability,
                              s_op->req->u.mkdir.credential,
                              s_op->req->u.mkdir.fs_id,
                              s_op->u.mkdir.handle,
                              PVFS_ATTR_READ_ALL_FASTEST,
                              NULL);

    PINT_cleanup_capability(&capability);

    getattr_op->op = PVFS_SERV_GETATTR;

    getattr_op->prelude_mask |= PRELUDE_NO_SCHEDULE;

    ret = PINT_sm_push_frame(smcb, 0, getattr_op);
    if ( ret < 0 )
    {
        gossip_err("%s:Error pushing getattr frame onto mkdir stack:ret(%d)\n",
                    __func__, ret);
        free(getattr_op);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    js_p->error_code = ret;
    return SM_ACTION_COMPLETE;
}

/*
 * Function: mkdir_setup_response
 *
 * Synopsis: This getattr request is returning attributes for a the new
 * directory metafile object.
 *  Check the results and prepare to return attributes to the client.
 *
 */
static PINT_sm_action mkdir_setup_response(struct PINT_smcb *smcb,
                                           job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *getattr_op;
    int task_id;
    int remaining;
    int ret;
    PVFS_object_attr *resp_attr;

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    getattr_op = PINT_sm_pop_frame(smcb,
                             &task_id,
                             &js_p->error_code,
                             &remaining);

    resp_attr = &(getattr_op->resp.u.getattr.attr);

    ret  = PINT_copy_capability(&resp_attr->capability, 
                               &s_op->resp.u.mkdir.capability);
    if (ret)
    {
        gossip_err("%s: Error copying capability from getattr to mkdir response: ret(%d)\n",__func__,ret);
        js_p->error_code = ret;
    }

    /* clean up objects */
    PINT_free_object_attr(s_op->u.mkdir.saved_attr);
    PINT_cleanup_capability(&s_op->u.mkdir.server_to_server_capability);

    PINT_cleanup_capability(&(*getattr_op->req).capability);
    free(getattr_op);
    return SM_ACTION_COMPLETE;
}

static int mkdir_error(struct PINT_smcb *smcb, job_status_s *js_p)
{
    if (js_p->error_code > -1)
    {
        js_p->error_code = -PVFS_EINVAL;
    }
    return 1;
}

/*
 * Function: mkdir_free
 *
 * Params:   server_op *s_op,
 *
 * Returns:  N/A
 *
 * Synopsis: free memory - can be called from outside this source file.
 *
 */
void mkdir_free(struct PINT_server_op *s_op)
{
    free_keyval_buffers(s_op);
}

/*
 * Function: mkdir_cleanup
 *
 * Params:   server_op *b, 
 *           job_status_s *js_p
 *
 * Returns:  int
 *
 * Synopsis: free memory and return
 *           
 */
static PINT_sm_action mkdir_cleanup(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_MKDIR_DEBUG, "(%p) %s\n", s_op, __func__);

    PINT_perf_timer_end(PINT_server_tpc, PINT_PERF_TMKDIR, &s_op->start_time);
    mkdir_free(s_op);
    /* do any of these need to be free'd ? */
    s_op->u.mkdir.saved_attr = NULL;
    s_op->u.mkdir.rmt_dirdata_array = NULL;
    free(s_op->u.mkdir.dirdata_parent_buffer);
    s_op->u.mkdir.dirdata_parent_buffer = NULL;
    /* old code I think - if things are working OK remove */
    /*free(s_op->req->u.mkdir.attr.u.dir.hint.dist_name);*/
    /*free(s_op->req->u.mkdir.attr.u.dir.hint.dist_params);*/
#if 0
    if (s_op->msgarray_op.count > 0)
    {
        PINT_free_object_attr(&s_op->req->u.tree_setattr.attr);
    }
#endif
    return(server_state_machine_complete(smcb));
}

static inline int PINT_get_object_ref_mkdir(struct PVFS_server_req *req,
                                            PVFS_fs_id *fs_id,
                                            PVFS_handle *handle)
{
    *fs_id = req->u.mkdir.fs_id;
    *handle = PVFS_HANDLE_NULL; /* This was V2 had to pick OID in this routine */
    /* *handle = req->u.mkdir.handle; */
    return 0;
}

static int PINT_get_attr_mkdir(struct PVFS_server_req *req,
                                PVFS_object_attr *attr)
{
    *attr = req->u.mkdir.attr;
    return 0;
}

static int PINT_perm_mkdir(PINT_server_op *s_op)
{
    int ret;

    if (s_op->req->capability.op_mask & PINT_CAP_CREATE)
    {
        ret = 0;
    }
    else
    {
        ret = -PVFS_EACCES;
    }

    return ret;
}

PINT_GET_CREDENTIAL_DEFINE(mkdir);

struct PINT_server_req_params pvfs2_mkdir_params =
{
    .string_name = "mkdir",
    .get_attr = PINT_get_attr_mkdir,
    .get_object_ref = PINT_get_object_ref_mkdir,
    .perm = PINT_perm_mkdir,
    .access_type = PINT_server_req_modify,
    .get_credential = PINT_get_credential_mkdir,
    .state_machine = &pvfs2_mkdir_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
