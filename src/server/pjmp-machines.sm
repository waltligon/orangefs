/*
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 *
 * Changes by Acxiom Corporation to add dirent_count field to attributes
 * Copyright Â© Acxiom Corporation, 2005.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-types-debug.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pvfs2-internal.h"
#include "pint-cached-config.h"

%%
machine pvfs2_pjmp_set_attr_work_sm
{
    state pjmp_set_attr_work_initialize
    {
        run pjmp_initialize;
        default => pjmp_call_set_attr_work_sm;
    }

    state pjmp_call_set_attr_work_sm
    {
        jump pvfs2_set_attr_with_prelude_sm;
        default => pjmp_set_attr_release_job;
    }

    state pjmp_set_attr_release_job
    {
        run pjmp_release_job;
        default => pjmp_set_attr_work_execute_terminate;
    }

    state pjmp_set_attr_work_execute_terminate
    {
        run pjmp_execute_terminate;
        default => terminate;
    }
}

machine pvfs2_pjmp_get_attr_work_sm
{
    state pjmp_get_attr_work_initialize
    {
        run pjmp_initialize;
        default => pjmp_call_get_attr_work_sm;
    }

    state pjmp_call_get_attr_work_sm
    {
        jump pvfs2_get_attr_with_prelude_sm;
        default => pjmp_get_attr_release_job;
    }

    state pjmp_get_attr_release_job
    {
        run pjmp_release_job;
        default => pjmp_get_attr_work_execute_terminate;
    }

    state pjmp_get_attr_work_execute_terminate
    {
        run pjmp_execute_terminate;
        default => terminate;
    }
}


machine pvfs2_pjmp_create_immutable_copies_sm
{
    state pjmp_create_immutable_copies_initialize
    {
        run pjmp_initialize;
        default => pjmp_call_create_immutable_copies_sm;
    }

    state pjmp_call_create_immutable_copies_sm
    {
        jump pvfs2_create_immutable_copies_sm;
        default => pjmp_create_immutable_copies_execute_terminate;
    }

    state pjmp_create_immutable_copies_execute_terminate
    {
        run pjmp_execute_terminate;
        default => terminate;
    }
}


machine pvfs2_pjmp_mirror_work_sm
{
    state pjmp_mirror_work_initialize
    {
        run pjmp_initialize;
        default => pjmp_call_mirror_work_sm;
    }

    state pjmp_call_mirror_work_sm
    {
        jump pvfs2_mirror_work_sm;
        default => pjmp_mirror_work_execute_terminate;
    }

    state pjmp_mirror_work_execute_terminate
    {
        run pjmp_execute_terminate;
        default => terminate;
    }
}


machine pvfs2_pjmp_remove_work_sm
{
    state pjmp_remove_work_initialize
    {
        run pjmp_initialize;
        default => pjmp_call_remove_work_sm;
    }

    state pjmp_call_remove_work_sm
    {
        jump pvfs2_remove_with_prelude_sm;
        default => pjmp_remove_work_release_job;
    }

    state pjmp_remove_work_release_job
    {
        run pjmp_remove_work_release_job;
        default => pjmp_remove_work_execute_terminate;
    }

    state pjmp_remove_work_execute_terminate
    {
        run pjmp_remove_work_execute_terminate;
        default => terminate;
    }
}

/*
machine pvfs2_pjmp_get_attr_sm
{
    state pjmp_initialize
    {
        run pjmp_initialize;
        default => pjmp_call_get_attr;
    }

    state pjmp_call_get_attr
    {
        jump pvfs2_get_attr_sm;
        default => pjmp_execute_terminate;
    }

    state pjmp_execute_terminate
    {
        run pjmp_execute_terminate;
        default => terminate;
    } 
}
*/

machine pvfs2_pjmp_call_msgpairarray_sm
{
    state call_msgpairarray
    {
        run call_msgpairarray;
        success => transfer_msgpair;
        default => cleanup_msgpairarray;
    }

    state transfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        default => cleanup_msgpairarray;
    }

    state cleanup_msgpairarray
    {
        run cleanup_msgpairarray;
        default => terminate;
    }
} /*end state machine pvfs2_pjmp_call_msgpairarray_sm*/
%%

static PINT_sm_action pjmp_initialize(struct PINT_smcb *smcb,
                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    gossip_lsdebug(GOSSIP_MSGPAIR_DEBUG, "Running initialize\n");
    /* keep code from looping through get_item */
    if ((s_op->req->op == PVFS_SERV_TREE_GET_DIRENT_COUNT) ||
        (s_op->req->op == PVFS_SERV_TREE_GET_FILE_SIZE))
    {
        s_op->u.getattr.attrmask &= ~PVFS_ATTR_LATEST;
        s_op->u.getattr.attrmask |=  PVFS_ATTR_FASTEST;
        js_p->error_code = 0;
    }
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action pjmp_release_job(struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret = -1;
    job_id_t tmp_id;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    gossip_lsdebug(GOSSIP_MSGPAIR_DEBUG, "Running release job\n");

    ret = job_req_sched_release( s_op->scheduled_id
                                ,smcb
                                ,0
                                ,js_p
                                ,&tmp_id
                                ,server_job_context);

    return ret;
}/*end pjmp_release_job*/

static PINT_sm_action pjmp_execute_terminate( struct PINT_smcb *smcb
                                            , job_status_s *js_p)
{
    gossip_lsdebug(GOSSIP_MSGPAIR_DEBUG, "Running terminate\n");
    return SM_ACTION_TERMINATE;
}

/****************************************************************************/
/* Actions for pvfs2_pjmp_call_msgpairarray_sm                              */
/****************************************************************************/

/* We use a separate nested state machine to call msgpairarray because */
/* msgpairarray.sm is setup to work only with a "jump".  When "pjmp"   */
/* is used, the frame stack gets corrupted.                            */
static PINT_sm_action call_msgpairarray (struct PINT_smcb *smcb
                                        ,job_status_s *js_p)
{   
    struct PINT_server_op *s_op = PINT_sm_frame(smcb,PINT_FRAME_CURRENT);

    gossip_lsdebug(GOSSIP_MSGPAIR_DEBUG,
                   "op num: %d op: %s frame: (%p) frame count: %d base frame; %d\n",
                   smcb->op, PINT_map_server_op_to_string(smcb->op),
                   s_op, smcb->frame_count, smcb->base_frame);

    js_p->error_code = 0;

    gossip_lsdebug(GOSSIP_MSGPAIR_DEBUG, "s_op->msgarray_op.msgpair.req.op:%d\n",
                   s_op->msgarray_op.msgpair.req.op);

    /* PINT_sm_push_frame(smcb, 0, &s_op->msgarray_op.msgpair.req.op); */
    PINT_sm_push_frame(smcb, 0, &s_op->msgarray_op);
   
    gossip_lsdebug(GOSSIP_MSGPAIR_DEBUG,
                   "AFTER PUSH:smcb->base_frame:%d\tframe_count:%d\n",
                   smcb->base_frame, smcb->frame_count);

    return SM_ACTION_COMPLETE;
} /* end action call_msgpairarray */

static PINT_sm_action cleanup_msgpairarray (struct PINT_smcb *smcb
                                           ,job_status_s *js_p)
{   
   gossip_debug(GOSSIP_SERVER_DEBUG,"Executing pvfs2_pjmp_call_msgpairarray_sm:cleanup_msgpairarray"
                                    "....\n");
   struct PINT_server_op *s_op = PINT_sm_frame(smcb,PINT_FRAME_CURRENT);

   gossip_debug(GOSSIP_SERVER_DEBUG,"\ts_op:%p\n",s_op);

   gossip_debug(GOSSIP_SERVER_DEBUG,"\tjs_p->error_code:%d\n"
                                   ,js_p->error_code);
   gossip_debug(GOSSIP_SERVER_DEBUG,"\tBEFORE POP:smcb->frame_base:%d"
                                    "\tframe_count:%d\n"
                                   ,smcb->base_frame,smcb->frame_count);


   gossip_debug(GOSSIP_SERVER_DEBUG,"\ts_op->msgarray_op.msgpair.req.op:%d\n"
                                    ,s_op->msgarray_op.msgpair.req.op );

   gossip_debug(GOSSIP_SERVER_DEBUG,"\ts_op->resp.status:%d\n"
                                   ,s_op->resp.status);

   return SM_ACTION_TERMINATE;
} /* end action cleanup_msgpairarray */

static PINT_sm_action pjmp_remove_work_release_job(struct PINT_smcb *smcb, job_status_s *js_p)
{
   int ret = -1;
   job_id_t tmp_id;
   struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

   /* save the error-code returned from the previous step */
   s_op->u.remove.saved_error_code = js_p->error_code;

   ret = job_req_sched_release( s_op->scheduled_id
                               ,smcb
                               ,0
                               ,js_p
                               ,&tmp_id
                               ,server_job_context);
 
   return ret;  
} /* end pjmp_remove_work_release_job */

static PINT_sm_action pjmp_remove_work_execute_terminate(struct PINT_smcb *smcb, job_status_s *js_p)
{
   struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

   js_p->error_code = s_op->u.remove.saved_error_code;

   return SM_ACTION_TERMINATE;
}/* end pjmp_remove_execute_terminate */


/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
