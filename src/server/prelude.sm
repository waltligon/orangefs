/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

/* leave first */
#include "pvfs2-config.h"

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "src/server/request-scheduler/request-scheduler.h"
#include "trove.h"
#include "pint-util.h"
#include "pvfs2-internal.h"
#include "pint-perf-counter.h"
#include "check.h"
#include "pint-uid-map.h"
#include "security-util.h"
#ifdef ENABLE_CAPCACHE
#include "capcache.h"
#endif
#ifdef ENABLE_CREDCACHE
#include "credcache.h"
#endif

/* prelude state machine:
 * This is a nested state machine that performs initial setup 
 * steps that are common to many server operations.
 * - post the request to the request scheduler
 * - check permissions
 */

static void get_anon_ids(struct filesystem_configuration_s *fsconfig,
                         PVFS_uid *uid,
                         PVFS_gid *gid);

static int iterate_all_squash_wildcards(
                              struct filesystem_configuration_s *fsconfig,
                              PVFS_BMI_addr_t client_addr);

static int iterate_root_squash_wildcards(
                               struct filesystem_configuration_s *fsconfig,
                               PVFS_BMI_addr_t client_addr);

static int translate_ids(PVFS_fs_id fsid,
                         PVFS_uid uid,
                         PVFS_gid gid,
                         PVFS_uid *translated_uid,
                         PVFS_gid *translated_gid,
                         PVFS_BMI_addr_t client_addr);

static int iterate_ro_wildcards(struct filesystem_configuration_s *fsconfig,
                                PVFS_BMI_addr_t client_addr);

static int permit_operation(PVFS_fs_id fsid,
                            enum PINT_server_req_access_type access_type,
                            PVFS_BMI_addr_t client_addr);

#if 0
#define CREATE_DATA_OBJECT 1
#define CREATE_DIRDATA_OBJECT 2
#endif
#define CREATE_OBJECT 21

%%

nested machine pvfs2_prelude_work_sm
{
    state req_sched
    {
        run prelude_req_sched;
        success => getattr_if_needed;
        default => return;
    }

    state getattr_if_needed
    {
        run prelude_getattr_if_needed;
        default => validate;
    }

    state validate
    {
        run prelude_validate;
        CREATE_OBJECT => create_object_if_allowed;
/*
        CREATE_DATA_OBJECT => create_data_object_if_allowed;
        CREATE_DIRDATA_OBJECT => create_dirdata_object_if_allowed;
*/
        default => return;
    }

    state create_object_if_allowed
    {
        run prelude_create_object_if_allowed;
        success => write_new_object_attr;
        default => return;
    }

/*
    state create_dirdata_object_if_allowed
    {
        run prelude_create_dirdata_object_if_allowed;
        success => write_new_object_attr;
        default => return;
    }
*/

    state write_new_object_attr
    {
        run prelude_write_new_object_attr;
        success => write_new_object_keyval;
        default => return;
    }

    state write_new_object_keyval
    {
        run prelude_write_new_object_keyval;
        success => validate;
        default => return;
    }
}

nested machine pvfs2_prelude_sm
{
    state setup
    {
        run prelude_setup;
        default => prelude_work;
    }

    state prelude_work
    {
        jump pvfs2_prelude_work_sm;
        default => return;
    }
}

%%

/******************* Action Functions *******************/

static PINT_sm_action prelude_setup(struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: req_sched\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));
    gossip_debug(GOSSIP_MIRROR_DEBUG,
                 "Executing pvfs2_prelude_sm:prelude_setup...\n");
    gossip_debug(GOSSIP_MIRROR_DEBUG,
                 "\tbase frame:%d\tframe count:%d\n"
                 ,smcb->base_frame,smcb->frame_count);

    /* gets the target fs_id and handle from the request and copies
     * them in the s_op
     */
    ret = PINT_server_req_get_object_ref(s_op->req,
                                         &s_op->target_fs_id,
                                         &s_op->target_handle);
    if( ret != 0 )
    {
        js_p->error_code = -PVFS_EINVAL;
    }

    /** gets the target's attrs from the request and copies into the s_op **/
    /* ret = PINT_server_req_get_attr(s_op->req, &s_op->attr); */

    /* There is a valied NULL return for some OPs */

    s_op->access_type = PINT_server_req_get_access_type(s_op->req);
    s_op->sched_policy = PINT_server_req_get_sched_policy(s_op->req);

    gossip_debug(GOSSIP_SERVER_DEBUG, "Prelude gets fs_id = %d "
                 "handle = %s\n access = %d sched = %d\n", 
                 s_op->target_fs_id, PVFS_OID_str(&s_op->target_handle),
                 s_op->access_type, s_op->sched_policy);

    /* FIXME!!add the user to the uid mgmt system */
    /* TODO: not currently supported w/new security system */
    /* Why not supported?  Is there nolonger uid in all requests
     * can we write logic for when there is or is not (like not if
     * using cert security)?  This is an important mgmt function, if 
     * it is possible to support.
     */
    /* I'm thinking this should be moved to unexpected, not everything
     * calls prelude, and sometime other things call it more than once
     */
#if 0
    ret = PINT_add_user_to_uid_mgmt(s_op->req->credentials.uid);
    if (ret != 0)
    {
        gossip_debug(GOSSIP_MIRROR_DEBUG, "Unable to add user id to uid"
                      "management interface\n");
    }
#endif

    return SM_ACTION_COMPLETE;
}

/* prelude_req_sched()
 *
 * posts a request scheduler job
 */
static PINT_sm_action prelude_req_sched(struct PINT_smcb *smcb,
                                        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: req_sched\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "Executing pvfs2_prelude_work_sm:prelude_req_sched\n");
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "\tbase_frame:%d\tframe_count:%d\n",
                 smcb->base_frame,smcb->frame_count);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: req_sched\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));

    PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DETAIL_DEBUG, "request\n");

    PINT_perf_count(PINT_server_pc, PINT_PERF_REQUESTS, 1, PINT_PERF_ADD);

    gossip_debug(GOSSIP_SERVER_DEBUG, "posting schedule for op type %d, "
                 "fs_id is %d handle is %s\n", s_op->op, s_op->target_fs_id,
                 PVFS_OID_str(&s_op->target_handle));

    if (s_op->prelude_mask & PRELUDE_NO_SCHEDULE)
    {
        ret = job_req_sched_post(s_op->op,
                                 s_op->target_fs_id,
                                 s_op->target_handle,
                                 s_op->access_type,
                                 s_op->sched_policy,
                                 smcb,
                                 0,
                                 js_p,
                                 &(s_op->scheduled_id),
                                 server_job_context);

        PINT_perf_count(PINT_server_pc, PINT_PERF_REQSCHED, 1, PINT_PERF_ADD);
    }
    else
    {
        return SM_ACTION_COMPLETE;;
    }
    return ret;
}

/* prelude_getattr_if_needed()
 *
 * reads basic attributes of target object, if there is a particular
 * target object for the operation
 */
static PINT_sm_action prelude_getattr_if_needed(struct PINT_smcb *smcb,
                                                job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t tmp_id;

    PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DETAIL_DEBUG, "start\n");

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: getattr_if_needed\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));

    /* if the handle is 0, that indicates that the request does not
     * operate on a specific handle, so there is nothing we can do
     * here
     */
    if (!PVFS_OID_cmp(&s_op->target_handle, &PVFS_HANDLE_NULL))
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "Null handle - prelude bypass getattr\n");
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    /* When creating an object it has no attrs in the DB so skip getattr */
    if (s_op->req->op == PVFS_SERV_MKDIR || s_op->req->op == PVFS_SERV_CREATE)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "Creating new object - prelude bypass getattr\n");
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    /* all other operations fall to this point and read basic
     * attribute information
     */
    memset(&(s_op->ds_attr), 0, sizeof(PVFS_ds_attributes));

    gossip_debug(GOSSIP_SERVER_DEBUG, "About to retrieve attributes "
                 "for handle %s\n", PVFS_OID_str(&s_op->target_handle));

    ret = job_trove_dspace_getattr(s_op->target_fs_id,
                                   s_op->target_handle,
                                   smcb,
                                   &(s_op->ds_attr),
                                   0,
                                   js_p,
                                   &tmp_id,
                                   server_job_context,
                                   s_op->req->hints);

    /* this getattr will not include parent, dirdata/dfile handles, or bitmaps */
    return ret;
}

static PINT_sm_action prelude_validate(struct PINT_smcb *smcb,
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_credential *cred = NULL;
    int create_object = 0;
    time_t current_time;
    int ret = -PVFS_EINVAL, capcache_hit = 0, credcache_hit = 0;
    PVFS_error error_code = 0;
    DECLARE_PROFILER(profiler);

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: prelude_validate\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));

    /* Profile validate operation */
    INIT_PROFILER(profiler);
    START_PROFILER(profiler);

    /* s_op->attr.mask = PVFS_ATTR_COMMON_ALL; */

    /* Get the errno value from the getattr to use for comparison */
    error_code = PVFS_get_errno_mapping(js_p->error_code);

    /* Next we see if we need to create a new object.
     * The only objects created by prelude are DATAFILE and DIRDATA objects
     * that were not created during the original CREATE or MKDIR operations.
     * When we create these objects the implication is that the getattr from 
     * the previous state failed, and thus we cannot depend on attr fields until
     * they are filled in.
     */
    if (error_code == ENOENT)
    {   
        /* A new object, Try to decide what kind of object from the req op type.
         * We are building the object attr for the new object which we later 
         * convert to a ds_attr for writing to the database.
         * First copy in the attrs sent in by the original req as a starting point.
         */
        gossip_debug(GOSSIP_SERVER_DEBUG, "\ttarget_handle: %s NOT FOUND!\n",
                     PVFS_OID_str(&s_op->target_handle));
        /** gets the target's attrs from the request using the get_attr method
         * defined in the .sm file and copy it to the s_op scratch space for the attr
         */
        ret = PINT_server_req_get_attr(s_op->req, &s_op->attr);
        s_op->target_object_attr = &s_op->attr; /* is this used? */

        gossip_debug(GOSSIP_SERVER_DEBUG, "\trequest attributes accessed\n");

        /* Everything has a parent, but it may not have come with the request.
         * It should have.  Don't crash if its not there, but maybe log an error!
         */
        if (s_op->attr.parent)
        {
            gossip_debug(GOSSIP_SERVER_DEBUG, "\tparent: %s\n",
                         PVFS_OID_str(s_op->attr.parent));
        }
        /* these need to be farther down once we know what kind of obj it is */
        if (s_op->attr.u.dirdata.dirdata_handles) 
        {
            gossip_debug(GOSSIP_SERVER_DEBUG, "\tdirdata_handle: %s\n",
                         PVFS_OID_str(s_op->attr.u.dirdata.dirdata_handles));
        }
        if (s_op->attr.u.dirdata.dist_dir_bitmap)
        {
            gossip_debug(GOSSIP_SERVER_DEBUG, "\tbitmap: %d\n",
                         *s_op->attr.u.dirdata.dist_dir_bitmap);
        }
        /* */

        create_object = 1;    /* default to create unless zereo'd below */
        js_p->error_code = 0; /* Clear ENOENT */
        switch (s_op->req->op)
        {
        /* datafile object specific */
        case PVFS_SERV_IO :
        case PVFS_SERV_SMALL_IO :
        case PVFS_SERV_TRUNCATE :
            gossip_debug(GOSSIP_SERVER_DEBUG, "create DATAFILE\n");
            s_op->attr.objtype = PVFS_TYPE_DATAFILE;
            s_op->attr.u.data.size = 0;
            break;
        /* dirdata object specific */
        case PVFS_SERV_RMDIRENT : /* assumes existing dirdata */
            gossip_debug(GOSSIP_SERVER_DEBUG, "removing dirent from non-existent dirdata - skip\n");
            create_object = 0;
            js_p->error_code = ENOENT;
            goto complete;
            break;
        case PVFS_SERV_CHDIRENT : /* assumes existing dirdata */
        case PVFS_SERV_CRDIRENT : /* assumes existing dirdata */
            gossip_debug(GOSSIP_SERVER_DEBUG, "create DIRDATA\n");
            s_op->attr.objtype = PVFS_TYPE_DIRDATA;
            s_op->attr.u.dirdata.dirent_count = 0;
            break;
        /* either data or dirdata */
        case PVFS_SERV_DELEATTR : /* assumes existing dirdata/datafile */

        case PVFS_SERV_GETATTR :
        case PVFS_SERV_LISTATTR :
        case PVFS_SERV_GETEATTR :
        case PVFS_SERV_LISTEATTR :

        case PVFS_SERV_SETATTR :
        case PVFS_SERV_SETEATTR :
        case PVFS_SERV_ATOMICEATTR :
            if (s_op->req->ctrl.sub == PVFS_REQ_DATAFILE)
            {
                s_op->attr.objtype = PVFS_TYPE_DATAFILE;
                s_op->attr.u.data.size = 0;
                s_op->orig_mask = s_op->attr.mask;
                s_op->attr.mask = PVFS_ATTR_DATA_ALL | PVFS_ATTR_COMMON_ALL;
            }
            else if (s_op->req->ctrl.sub == PVFS_REQ_DIRDATA)
            {
                s_op->attr.objtype = PVFS_TYPE_DIRDATA;
                s_op->attr.u.dirdata.dirent_count = 0;
                s_op->orig_mask = s_op->attr.mask;
                s_op->attr.mask = PVFS_ATTR_DIRDATA_ALL | PVFS_ATTR_COMMON_ALL;
            }
            else
            {
                gossip_err("Prelude asked to create object of unknown type\n");
                create_object = 0;
                js_p->error_code = ENOENT;
            }
            break;
        /* normal ops where the object is not expected to exist
         * beforehand
         */
        case PVFS_SERV_CREATE :
        case PVFS_SERV_MKDIR :
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "%s: create or mkdir of object\n", __func__);
            create_object = 0;
            js_p->error_code = 0;
            break;
        /* We are removing a DATAFILE or DIRDATA that does not exist yet.
         * Do not need to create a cap, or translate ids.
         */
        case PVFS_SERV_REMOVE :
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "%s: remove or rmdir of non-existing object\n", __func__);
            create_object = 0;
            js_p->error_code = ENOENT;
            goto complete;
            break;
        default:
            if (s_op->req->op < 0 || s_op->req->op > PVFS_SERV_NUM_OPS)
            {
                gossip_err("Prelude has request of unknown op %d\n", s_op->req->op);
            }
            /* else don't create an object */
            create_object = 0;
            js_p->error_code = ENOENT;
            break;
        }

        /* initialize the time members */
        /* these are used for whole second time values in file timestamps */
            current_time = time(NULL);
        s_op->attr.atime = current_time;
        s_op->attr.mtime = current_time;
        s_op->attr.ctime = current_time;
        s_op->attr.ntime = current_time;
    

        /* DIRDATA needs a set of dist_dir_data fields for distributed diretories
         * and such.  This needs to be passed by the caller, which is normally a server
         * in the midst of MKDIR operation so mkdir needs to have this info in its
         * attributes, which it does - just be sure its filled in.  Theoretically this
         * could also result from a CRDIRENT which wants to put an entry in a missing
         * dirdata.  Unfortunately crdirent does not pass an attribute.  Normally a
         * crdirent comes from a CREATE, which reads attributes from the parent dir
         * including this stuff, and issues the crdirent, so it could pass the attr
         * if the crdirent req had an attr field.
         */
        if (s_op->attr.objtype == PVFS_TYPE_DIRDATA)
        {
            s_op->attr.u.dirdata.dirent_count = 0; /* new object no items */

            /* we copied from the req attr to the s_op attr so all of this should be
             * there, no need to copy it all again
             */
#if 0            
            /* We don't know this is a setattr request - have to fix this! */
            s_op->attr.u.dirdata.dist_dir_attr.tree_height =
                            s_op->req->u.setattr.attr.u.dirdata.dist_dir_attr.tree_height;
        
            s_op->attr.u.dirdata.dist_dir_attr.dirdata_count =
                            s_op->req->u.setattr.attr.u.dirdata.dist_dir_attr.dirdata_count;

            s_op->attr.u.dirdata.dist_dir_attr.sid_count =
                            s_op->req->u.setattr.attr.u.dirdata.dist_dir_attr.sid_count;

            s_op->attr.u.dirdata.dist_dir_attr.bitmap_size =
                            s_op->req->u.setattr.attr.u.dirdata.dist_dir_attr.bitmap_size;

            s_op->attr.u.dirdata.dist_dir_attr.split_size =
                            s_op->req->u.setattr.attr.u.dirdata.dist_dir_attr.split_size;

            s_op->attr.u.dirdata.dist_dir_attr.server_no =
                            s_op->req->u.setattr.attr.u.dirdata.dist_dir_attr.server_no;
#endif
        }
    gossip_debug(GOSSIP_SERVER_DEBUG,
                     "prelude: validate: create_object is %d\n", create_object);
    } /* endif object not found */
    else
    {
        /* Translate the dspace attributes read from db into object attributes */
        PVFS_ds_attr_to_object_attr(&s_op->ds_attr, &s_op->attr);
        s_op->target_object_attr = &s_op->attr;
    }

    /* Remaining logic deals with new or existing object. */

    if (s_op->prelude_mask & PRELUDE_PERM_CHECK_DONE)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "(%p) %s (prelude sm) perm check already done... "
                     "skipping.\n", s_op,
                     PINT_map_server_op_to_string(s_op->req->op));

        return SM_ACTION_COMPLETE;
    }

    PINT_debug_capability(&s_op->req->capability, "Received");

    if (s_op->target_fs_id != PVFS_FS_ID_NULL)
    {
        /*
         * if we are exporting a volume readonly, disallow any operation 
         * that modifies the state of the file-system.
         */
        if (permit_operation(s_op->target_fs_id,
                             s_op->access_type,
                             s_op->addr) < 0)
        {
            js_p->error_code = -PVFS_EROFS;
            goto complete;
        }
    }

    PINT_server_req_get_credential(s_op->req, &cred);
    if (cred != NULL)
    {
#ifdef ENABLE_CREDCACHE
        credcache_hit = (PINT_credcache_lookup(cred) != NULL);

        gossip_debug(GOSSIP_SECURITY_DEBUG, "%s: cred cache %s\n", __func__,
                     (credcache_hit) ? "hit" : "miss");
#endif
        /* do not verify credential on credcache hit */
        ret = (credcache_hit) ? 1 : PINT_verify_credential(cred);

#ifdef ENABLE_CREDCACHE
        if (!credcache_hit && ret)
        {
            /* cache credential */
            PINT_credcache_insert(cred);
        }
#endif
        if (!ret)
        {
            char sig_buf[16];

            gossip_debug(GOSSIP_SECURITY_DEBUG, 
                         "Credential (%s) from %s failed verification.\n",
                         PINT_util_bytes2str(cred->signature, sig_buf, 4),
                         cred->issuer);

            /* have client try again on timeout */
            if (PINT_util_get_current_time() > cred->timeout)
            {
                js_p->error_code = -PVFS_EAGAIN;
            }
            else
            {
                js_p->error_code = -PVFS_EPERM;
            }
            
            goto complete;
        }
    }

    if ((s_op->target_fs_id != PVFS_FS_ID_NULL) && (cred != NULL))
    {
        PVFS_uid uid, translated_uid;
        PVFS_gid group_array[PVFS_REQ_LIMIT_GROUPS], translated_gid;
        uint32_t num_groups;
        
        /* map the credential */
        ret = PINT_map_credential(cred, &uid, &num_groups, group_array);
        if (ret != 0)
        {
            js_p->error_code = ret;

            goto complete;
        }

        /* Translate the uid and gid's in case we need to do some squashing 
         * based on the export and the client address
         */
        /* TODO: testing */
        if (translate_ids(s_op->target_fs_id,
                          uid, 
                          group_array[0],
                          &translated_uid, 
                          &translated_gid,
                          s_op->addr) == 1)
        {
            /* TODO: not applicable to certificates */
            /* modify the credential. doesn't support secondary groups */
            cred->userid = translated_uid;
            cred->group_array[0] = translated_gid;
            cred->num_groups = 1;

            /* nlmills: can't call PINT_cleanup_credential because
             * the issuer string points inside the message buffer.
             */
            free(cred->signature);
            cred->signature = NULL;
            ret = PINT_sign_credential(cred);
            if (ret)
            {
                js_p->error_code = -PVFS_ENOMEM;
                goto complete;
            }

            /* TODO: this needs to be reworked */
            /* certain requests rely on the request attributes having the
             * same uid/gid as the client 
             */
            if (s_op->req->op == PVFS_SERV_SETATTR)
            {
                s_op->req->u.setattr.attr.owner = translated_uid;
                s_op->req->u.setattr.attr.group = translated_gid;
            }
            else if (s_op->req->op == PVFS_SERV_MKDIR)
            {
                s_op->req->u.mkdir.attr.owner = translated_uid;
                s_op->req->u.mkdir.attr.group = translated_gid;
            }
            else if (s_op->req->op == PVFS_SERV_CREATE)
            {
                s_op->req->u.create.attr.owner = translated_uid;
                s_op->req->u.create.attr.group = translated_gid;
            }
        }
    }

    /* check capability cache for non-null capabilities */
#ifdef ENABLE_CAPCACHE
    capcache_hit = 1;
    if (!PINT_capability_is_null(&s_op->req->capability))
    {        
        capcache_hit = (PINT_capcache_lookup(&s_op->req->capability) != NULL);        
        gossip_debug(GOSSIP_SECURITY_DEBUG, "%s: cap cache %s!\n", __func__,
                     (capcache_hit) ? "hit" : "miss");
    }
#endif

    /* do not verify cap on cache hit */
    ret = (capcache_hit) ? 1 : PINT_verify_capability(&s_op->req->capability);

    /* check operation permissions */
    if (ret)
    {
        ret = 0; /* clear from revious ops */
        if (!create_object) /* if create_object allow all attrs to be set */
        {
            ret = PINT_perm_check(s_op);
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "%s:return from PINT_perm_check = %d\n" ,__func__ ,ret);
        }
        else
        {
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "%s:skipping PINT_perm_check\n" ,__func__);
        }
    }
    else
    {
        char sig_buf[16]; 

        gossip_debug(GOSSIP_SECURITY_DEBUG, 
                     "Capability (%s) from %s failed verification.\n",
                     PINT_util_bytes2str(s_op->req->capability.signature,
                                         sig_buf, 4),
                     s_op->req->capability.issuer);

        /* have client try again on timeout */
        if (PINT_util_get_current_time() > s_op->req->capability.timeout)
        {
            js_p->error_code = -PVFS_EAGAIN;
        }
        else
        {
            js_p->error_code = -PVFS_EPERM;
        }
        
        goto complete;
    }

    /* anything else we treat as a real error */
    if (js_p->error_code)
    {
        js_p->error_code = -PVFS_ERROR_CODE(-js_p->error_code);
        return SM_ACTION_COMPLETE;
    }

    js_p->error_code = ret;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (req=%d) (prelude sm) state: %s (status = %d)\n",
                 s_op, PINT_map_server_op_to_string(s_op->req->op),s_op->req->op,
                 __func__, js_p->error_code);

complete:

    FINISH_PROFILER("pv2", profiler, 1);
     
    /* if everything has checked out so far except the
     * dspace record is missing, then create the dspace record
     */
    if (js_p->error_code == 0 && create_object == 1)
    {
        s_op->attr.mask = s_op->orig_mask; /* clean up just in case */
        s_op->new_target_object = 1; /* passing back to mainop SM's */
        js_p->error_code = CREATE_OBJECT;
    }
    return SM_ACTION_COMPLETE;
}

/* if opcode is appropriate and we have a proper capability
 * then we create the object - a DATAFILE or DIRDATA with the
 * approporiate attributes
 */
static PINT_sm_action prelude_create_object_if_allowed(struct PINT_smcb *smcb,
                                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    job_id_t tmp_id;
 
    js_p->error_code = 0;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: create_object\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));
    gossip_debug(GOSSIP_SERVER_DEBUG, "prelude: creating missing object: %s\n",
                 PVFS_OID_str(&s_op->target_handle));

    /* setup and post dspace create job */
    ret = job_trove_dspace_create(s_op->target_fs_id,
                                  s_op->target_handle,
                                  s_op->attr.objtype,
                                  NULL, /* hint */
                                  0,    /* flags */
                                  smcb, /* user_ptr */
                                  0,    /* status_user_tag */
                                  js_p,
                                  &tmp_id,
                                  server_job_context,
                                  s_op->req->hints);
    return ret;
}

#if 0
/* if opcode is appropriate and we have a proper capability
 * then we create the object - a DIRDATA with the approporiate
 * attributes
 */
static PINT_sm_action prelude_create_dirdata_object_if_allowed(
                                                       struct PINT_smcb *smcb,
                                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    job_id_t tmp_id;

#if 0
    switch (s_op->req->op)
    {
    /* data object specific */
    case PVFS_SERV_CRDIRENT :
    case PVFS_SERV_RMDIRENT :
    case PVFS_SERV_CHDIRENT :
    /* either data or dirdata */
    case PVFS_SERV_GETATTR :
    case PVFS_SERV_SETATTR :
    case PVFS_SERV_GETEATTR :
    case PVFS_SERV_SETEATTR :
    case PVFS_SERV_DELEATTR :
    case PVFS_SERV_LISTEATTR :
    case PVFS_SERV_ATOMICEATTR :
#endif
        /* setup and post dirdata create job */
        ret = job_trove_dspace_create(s_op->target_fs_id,
                                      s_op->target_handle,
                                      PVFS_TYPE_DIRDATA,
                                      NULL, /* hint */
                                      0,    /* flags */
                                      smcb, /* user_ptr */
                                      0,    /* status_user_tag */
                                      js_p,
                                      &tmp_id,
                                      server_job_context,
                                      s_op->req->hints);
        return ret;
#if 0
    default :
        break;
    }

    return SM_ACTION_COMPLETE;
#endif
}
#endif

static PINT_sm_action prelude_write_new_object_attr(struct PINT_smcb *smcb,
                                                    job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t tmp_id;
    int ret;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: write_new_object_attr\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));
    gossip_debug(GOSSIP_SERVER_DEBUG, "prelude: writing attributes for new object\n");

    js_p->error_code = 0;

    /* PVFS_object_attr_from_ds_attr(&s_op->attr, &s_op->ds_attr); */
    PVFS_ds_attr_from_object_attr(&s_op->ds_attr, &s_op->attr);

    s_op->ds_attr.fs_id =  s_op->target_fs_id;
    s_op->ds_attr.handle = s_op->target_handle;

    /* post dspace setattr job */
    ret = job_trove_dspace_setattr(s_op->target_fs_id,
                                   s_op->target_handle,
                                   &(s_op->ds_attr),
                                   TROVE_SYNC, /* flags */
                                   smcb,       /* user_ptr */
                                   0,          /* status_user_tag */
                                   js_p,
                                   &tmp_id,
                                   server_job_context,
                                   s_op->req->hints);

    /* if this is a setattr, tell setattr SM nothing left to do */
    if (s_op->req->op == PVFS_SERV_SETATTR)
    {
        s_op->attr.mask = PVFS_ATTR_NULL; 
            
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "prelude: marking all attributes written mask: %ld\n",
                     s_op->attr.mask);
    }
    return ret;
}

/*
 * Contrary to the prev messge, this should run on a crdirent, which is
 * called during a mkdir.  The dirdata needs creating at this site.
 * This runs on a mkdir when the dirdata object has not been created
 * yet.
 */
static PINT_sm_action prelude_write_new_object_keyval(struct PINT_smcb *smcb,
                                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    //int i = 0;
    int ret = -1;
    job_id_t j_id;
    int keyval_count = 1; /* for a DATAFILE - PARENT key */

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: write_new_object_keyval\n",
                 s_op, PINT_map_server_op_to_string(s_op->req->op));

    if (s_op->req->ctrl.sub == PVFS_REQ_DIRDATA)
    {
        /* total 3 static keyvals every dirdata has:
         * PVFS_DIRDATA_BITMAP, PVFS_DIRDATA_HANDLES, PARENT */
        keyval_count = 3;
    }

    gossip_debug(GOSSIP_SERVER_DEBUG, "writing keyvals for new object\n");

    /* allocate key and val arrays */

    s_op->key_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->key_a)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->key_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    s_op->val_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);

    if(!s_op->val_a)
    {
        free(s_op->key_a);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->val_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    gossip_debug(GOSSIP_SERVER_DEBUG, "prelude setting up kvals k:%p v:%p\n",
                                       (void *)s_op->key_a, (void *)s_op->val_a); 

/*---------------------------------------------------------------------------*/

    /* write parent data for DIRDATA or DATAFILE */

    s_op->key_a[0].buffer_sz = Trove_Common_Keys[OBJECT_PARENT_KEY].size;
    s_op->key_a[0].buffer = Trove_Common_Keys[OBJECT_PARENT_KEY].key;

/* where does data come from?  depends on underlying call?
 */
    s_op->val_a[0].buffer_sz = OSASZ(1, s_op->attr.meta_sid_count);
    s_op->val_a[0].buffer = (void *)s_op->attr.parent;
    gossip_debug(GOSSIP_SERVER_DEBUG, "prelude setting up kvals2 %p sz %d\n",
                                      (void *)s_op->val_a[0].buffer,
                                      s_op->val_a[0].buffer_sz);

    keep_keyval_buffers(s_op, 0);

/*---------------------------------------------------------------------------*/


    if (keyval_count == 3)  
    {
        /* ONLY write dirdata handles for DIRDATA */

        s_op->key_a[1].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].size;
        s_op->key_a[1].buffer = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].key;

        s_op->val_a[1].buffer_sz = OSASZ(s_op->attr.u.dirdata.dist_dir_attr.dirdata_count,
                                        s_op->attr.u.dirdata.dist_dir_attr.sid_count);
/* aren't getting the right data here 
 */
        gossip_debug(GOSSIP_SERVER_DEBUG, "prelude: dirdata_handles: %s\n",
                     PVFS_OID_str(s_op->attr.u.dirdata.dirdata_handles));

        s_op->val_a[1].buffer = (void *)s_op->attr.u.dirdata.dirdata_handles;
        gossip_debug(GOSSIP_SERVER_DEBUG, "prelude setting up kvals1 %p sz %d\n",
                                        (void *)s_op->val_a[1].buffer,
                                        s_op->val_a[1].buffer_sz);

        keep_keyval_buffers(s_op, 1);

/*---------------------------------------------------------------------------*/

        /* ONLY write bitmap data for DIRDATA */

        s_op->key_a[2].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].size;
        s_op->key_a[2].buffer = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].key;

        s_op->val_a[2].buffer_sz = s_op->attr.u.dirdata.dist_dir_attr.bitmap_size *
                                sizeof(PVFS_dist_dir_bitmap_basetype);
/* aren't getting the right data here 
 */
        gossip_debug(GOSSIP_SERVER_DEBUG, "prelude: bitmap: %d\n",
                     *s_op->attr.u.dirdata.dist_dir_bitmap);

        s_op->val_a[2].buffer = (void *)s_op->attr.u.dirdata.dist_dir_bitmap;
        gossip_debug(GOSSIP_SERVER_DEBUG, "prelude setting up kvals0 %p sz %d\n",
                                        (void *)s_op->val_a[2].buffer,
                                        s_op->val_a[2].buffer_sz);

        keep_keyval_buffers(s_op, 2);

    }
/*---------------------------------------------------------------------------*/

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "  writing kvals for dirdata: %s "
                 "\t with server_no=%d and branch_level=%d \n",
                 PVFS_OID_str(&s_op->target_handle),
                 s_op->attr.u.dirdata.dist_dir_attr.server_no,
                 s_op->attr.u.dirdata.dist_dir_attr.branch_level);

    //i = s_op->u.mkdir.handle_index;

    ret = job_trove_keyval_write_list(s_op->target_fs_id,
                                      s_op->target_handle,
                                      s_op->key_a,
                                      s_op->val_a,
                                      keyval_count,
                                      TROVE_SYNC, /* flags */
                                      NULL,       /* vtag */
                                      smcb,       /* user_ptr */
                                      0,          /* status_user_tag */
                                      js_p,
                                      &j_id,
                                      server_job_context,
                                      s_op->req->hints);

    return ret;
}

/******************* Helper Functions *******************/

static void get_anon_ids(struct filesystem_configuration_s *fsconfig,
                         PVFS_uid *uid,
                         PVFS_gid *gid)
{
    *uid = fsconfig->exp_anon_uid;
    *gid = fsconfig->exp_anon_gid;
    return;
}

static int iterate_all_squash_wildcards(
                              struct filesystem_configuration_s *fsconfig,
                              PVFS_BMI_addr_t client_addr)
{
    int i;

    for (i = 0; i < fsconfig->all_squash_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "BMI_query_addr_range %lld, %s\n",
                     lld(client_addr), fsconfig->all_squash_hosts[i]);
        if (BMI_query_addr_range(client_addr,
                                 fsconfig->all_squash_hosts[i],
                                 fsconfig->all_squash_netmasks[i]) == 1)
        {
            return 1;
        }
    }
    return 0;
}

static int iterate_root_squash_wildcards(
                               struct filesystem_configuration_s *fsconfig,
                               PVFS_BMI_addr_t client_addr)
{
    int i;

    /* check exceptions first */
    for (i = 0; i < fsconfig->root_squash_exceptions_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "BMI_query_addr_range %lld, %s, netmask: %i\n",
            lld(client_addr), fsconfig->root_squash_exceptions_hosts[i],
            fsconfig->root_squash_exceptions_netmasks[i]);
        if (BMI_query_addr_range(
                           client_addr,
                           fsconfig->root_squash_exceptions_hosts[i], 
                           fsconfig->root_squash_exceptions_netmasks[i]) == 1)
        {
            /* in the exception list, do not squash */
            return 0;
        }
    }

    for (i = 0; i < fsconfig->root_squash_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "BMI_query_addr_range %lld, %s, netmask: %i\n",
                     lld(client_addr), fsconfig->root_squash_hosts[i],
                     fsconfig->root_squash_netmasks[i]);
        if (BMI_query_addr_range(client_addr,
                                 fsconfig->root_squash_hosts[i], 
                                 fsconfig->root_squash_netmasks[i]) == 1)
        {
            return 1;
        }
    }
    return 0;
}

/* Translate_ids will return 1 if it did some uid/gid squashing, 0 otherwise */
static int translate_ids(PVFS_fs_id fsid,
                         PVFS_uid uid,
                         PVFS_gid gid,
                         PVFS_uid *translated_uid,
                         PVFS_gid *translated_gid,
                         PVFS_BMI_addr_t client_addr)
{
    int exp_flags = 0;
    struct server_configuration_s *serv_config = NULL;
    struct filesystem_configuration_s * fsconfig = NULL;

    serv_config = PINT_server_config_mgr_get_config();
    fsconfig = PINT_config_find_fs_id(serv_config, fsid);

    if (fsconfig == NULL)
    {
        return 0;
    }
    exp_flags = fsconfig->exp_flags;
    /* If all squash was set */
    if (exp_flags & TROVE_EXP_ALL_SQUASH)
    {
        if (iterate_all_squash_wildcards(fsconfig, client_addr) == 1)
        {
            get_anon_ids(fsconfig, translated_uid, translated_gid);
            gossip_debug(GOSSIP_SERVER_DEBUG,
                "Translated ids from <%u:%u> to <%u:%u>\n",
                uid, gid, *translated_uid, *translated_gid);
            return 1;
        }
    }
    /* if only root squash was set translate uids for root alone*/
    if (exp_flags & TROVE_EXP_ROOT_SQUASH)
    {
        if (uid == 0 || gid == 0)
        {
            if (iterate_root_squash_wildcards(fsconfig, client_addr) == 1)
            {
                get_anon_ids(fsconfig, translated_uid, translated_gid);
                gossip_debug(GOSSIP_SERVER_DEBUG,
                    "Translated ids from <%u:%u> to <%u:%u>\n",
                    uid, gid, *translated_uid, *translated_gid);
                return 1;
            }
        }
    }
    /* no such translation required! */
    *translated_uid = uid;
    *translated_gid = gid;
    return 0;
}

static int iterate_ro_wildcards(struct filesystem_configuration_s *fsconfig,
                                PVFS_BMI_addr_t client_addr)
{
    int i;

    for (i = 0; i < fsconfig->ro_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "BMI_query_addr_range %lld, %s\n",
            lld(client_addr), fsconfig->ro_hosts[i]);
        /* Does the client address match the wildcard specification and/or */
        /* the netmask specification?                                      */
        if (BMI_query_addr_range(client_addr, fsconfig->ro_hosts[i],
                fsconfig->ro_netmasks[i]) == 1)
        {
            return 1;
        }
    }
    return 0;
}

/*
 * Return zero if this operation should be allowed.
 */
static int permit_operation(PVFS_fs_id fsid,
                            enum PINT_server_req_access_type access_type,
                            PVFS_BMI_addr_t client_addr)
{ 
    int exp_flags = 0; 
    struct server_configuration_s *serv_config = NULL;
    struct filesystem_configuration_s * fsconfig = NULL;

    if (access_type == PINT_SERVER_REQ_READONLY)
    {
        return 0;  /* anything that doesn't modify state is okay */
    }
    serv_config = PINT_server_config_mgr_get_config();
    fsconfig = PINT_config_find_fs_id(serv_config, fsid);

    if (fsconfig == NULL)
    {
        return 0;
    }
    exp_flags = fsconfig->exp_flags;

    /* cheap test to see if ReadOnly was even specified in the exportoptions */
    if (!(exp_flags & TROVE_EXP_READ_ONLY))
    {
        return 0;
    }
    /* Drat. Iterate thru the list of wildcards specified in
     * server_configuration and see
     * the client address matches. if yes, then we deny permission
     */
    if (iterate_ro_wildcards(fsconfig, client_addr) == 1)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, 
            "Disallowing read-write operation on a read-only exported file-system\n");
        return -EROFS;
    }
    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
