/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

/* leave first */
#include "pvfs2-config.h"

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "src/server/request-scheduler/request-scheduler.h"
#include "trove.h"
#include "pint-util.h"
#include "pvfs2-internal.h"
#include "pint-perf-counter.h"
#include "check.h"
#include "pint-uid-map.h"
#include "security-util.h"
#ifdef ENABLE_CAPCACHE
#include "capcache.h"
#endif
#ifdef ENABLE_CREDCACHE
#include "credcache.h"
#endif

/* prelude state machine:
 * This is a nested state machine that performs initial setup 
 * steps that are common to many server operations.
 * - post the request to the request scheduler
 * - check permissions
 */

static void get_anon_ids(struct filesystem_configuration_s *fsconfig,
                         PVFS_uid *uid,
                         PVFS_gid *gid);

static int iterate_all_squash_wildcards(
                              struct filesystem_configuration_s *fsconfig,
                              PVFS_BMI_addr_t client_addr);

static int iterate_root_squash_wildcards(
                               struct filesystem_configuration_s *fsconfig,
                               PVFS_BMI_addr_t client_addr);

static int translate_ids(PVFS_fs_id fsid,
                         PVFS_uid uid,
                         PVFS_gid gid,
                         PVFS_uid *translated_uid,
                         PVFS_gid *translated_gid,
                         PVFS_BMI_addr_t client_addr);

static int iterate_ro_wildcards(struct filesystem_configuration_s *fsconfig,
                                PVFS_BMI_addr_t client_addr);

static int permit_operation(PVFS_fs_id fsid,
                            enum PINT_server_req_access_type access_type,
                            PVFS_BMI_addr_t client_addr);

#if 0
#define CREATE_DATA_OBJECT 1
#define CREATE_DIRDATA_OBJECT 2
#endif
#define CREATE_OBJECT 21

%%

nested machine pvfs2_prelude_work_sm
{
    state req_sched
    {
        run prelude_req_sched;
        success => getattr_if_needed;
        default => return;
    }

    state getattr_if_needed
    {
        run prelude_getattr_if_needed;
        default => validate;
    }

    state validate
    {
        run prelude_validate;
        CREATE_OBJECT => create_object_if_allowed;
/*
        CREATE_DATA_OBJECT => create_data_object_if_allowed;
        CREATE_DIRDATA_OBJECT => create_dirdata_object_if_allowed;
*/
        default => return;
    }

    state create_object_if_allowed
    {
        run prelude_create_object_if_allowed;
        success => write_new_object_attr;
        default => return;
    }

/*
    state create_dirdata_object_if_allowed
    {
        run prelude_create_dirdata_object_if_allowed;
        success => write_new_object_attr;
        default => return;
    }
*/

    state write_new_object_attr
    {
        run prelude_write_new_object_attr;
        success => write_new_object_keyval;
        default => return;
    }

    state write_new_object_keyval
    {
        run prelude_write_new_object_keyval;
        success => validate;
        default => return;
    }
}

nested machine pvfs2_prelude_sm
{
    state setup
    {
        run prelude_setup;
        default => prelude_work;
    }

    state prelude_work
    {
        jump pvfs2_prelude_work_sm;
        default => return;
    }
}

%%

/******************* Action Functions *******************/

static PINT_sm_action prelude_setup(struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    fprintf(stderr, "Prelude: gossip_debug_on = %d\n", gossip_debug_on);
    fprintf(stderr, "SERVER_DEBUG 1 = %lud\n", GOSSIP_SERVER_DEBUG.mask1);
    fprintf(stderr, "SERVER_DEBUG 2 = %lud\n", GOSSIP_SERVER_DEBUG.mask2);
    fprintf(stderr, "debug_mask 1 = %lud\n", gossip_debug_mask.mask1);
    fprintf(stderr, "debug_mask 2 = %lud\n", gossip_debug_mask.mask2);

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: req_sched\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));
    gossip_debug(GOSSIP_MIRROR_DEBUG,
                 "Executing pvfs2_prelude_sm:prelude_setup...\n");
    gossip_debug(GOSSIP_MIRROR_DEBUG,
                 "\tbase frame:%d\tframe count:%d\n"
                 ,smcb->base_frame,smcb->frame_count);

    /* gets the target fs_id and handle from the request and puts
     * them in the s_op
     */
    ret = PINT_server_req_get_object_ref(s_op->req,
                                         &s_op->target_fs_id,
                                         &s_op->target_handle);
    if( ret != 0 )
    {
        js_p->error_code = -PVFS_EINVAL;
    }

    s_op->access_type = PINT_server_req_get_access_type(s_op->req);
    s_op->sched_policy = PINT_server_req_get_sched_policy(s_op->req);

    gossip_debug(GOSSIP_SERVER_DEBUG, "Prelude gets fs_id = %d "
                 "handle = %s\n access = %d sched = %d\n", 
                 s_op->target_fs_id, PVFS_OID_str(&s_op->target_handle),
                 s_op->access_type, s_op->sched_policy);

    /* add the user to the uid mgmt system */
    /* TODO: not currently supported w/new security system
    ret = PINT_add_user_to_uid_mgmt(s_op->req->credentials.uid);
    if (ret != 0)
    {
        gossip_debug(GOSSIP_MIRROR_DEBUG, "Unable to add user id to uid"
                      "management interface\n");
    }
*/

    return SM_ACTION_COMPLETE;
}

/* prelude_req_sched()
 *
 * posts a request scheduler job
 */
static PINT_sm_action prelude_req_sched(struct PINT_smcb *smcb,
                                        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: req_sched\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "Executing pvfs2_prelude_work_sm:prelude_req_sched\n");
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "\tbase_frame:%d\tframe_count:%d\n",
                 smcb->base_frame,smcb->frame_count);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: req_sched\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));

    PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DETAIL_DEBUG, "request\n");

    PINT_perf_count(PINT_server_pc, PINT_PERF_REQUESTS, 1, PINT_PERF_ADD);

    gossip_debug(GOSSIP_SERVER_DEBUG, "posting schedule for op type %d, "
                 "fs_id is %d handle is %s\n", s_op->op, s_op->target_fs_id,
                 PVFS_OID_str(&s_op->target_handle));

    if (s_op->prelude_mask & PRELUDE_NO_SCHEDULE)
    {
        ret = job_req_sched_post(s_op->op,
                                 s_op->target_fs_id,
                                 s_op->target_handle,
                                 s_op->access_type,
                                 s_op->sched_policy,
                                 smcb,
                                 0,
                                 js_p,
                                 &(s_op->scheduled_id),
                                 server_job_context);

        PINT_perf_count(PINT_server_pc, PINT_PERF_REQSCHED, 1, PINT_PERF_ADD);
    }
    else
    {
        return SM_ACTION_COMPLETE;;
    }
    return ret;
}

/* prelude_getattr_if_needed()
 *
 * reads basic attributes of target object, if there is a particular
 * target object for the operation
 */
static PINT_sm_action prelude_getattr_if_needed(struct PINT_smcb *smcb,
                                                job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t tmp_id;

    PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DETAIL_DEBUG, "start\n");

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: getattr_if_needed\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));

    /* if the handle is 0, that indicates that the request does not
     * operate on a specific handle, so there is nothing we can do
     * here
     */
    if (!PVFS_OID_cmp(&s_op->target_handle, &PVFS_HANDLE_NULL))
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "Null handle - prelude bypass getattr\n");
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    /* all other operations fall to this point and read basic
     * attribute information
     */
    memset(&(s_op->ds_attr), 0, sizeof(PVFS_ds_attributes));

    gossip_debug(GOSSIP_SERVER_DEBUG, "About to retrieve attributes "
                 "for handle %s\n", PVFS_OID_str(&s_op->target_handle));

    ret = job_trove_dspace_getattr(s_op->target_fs_id,
                                   s_op->target_handle,
                                   smcb,
                                   &(s_op->ds_attr),
                                   0,
                                   js_p,
                                   &tmp_id,
                                   server_job_context,
                                   s_op->req->hints);

    return ret;
}

static PINT_sm_action prelude_validate(struct PINT_smcb *smcb,
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_credential *cred = NULL;
    int create_object = 0;
    int ret = -PVFS_EINVAL, capcache_hit = 0, credcache_hit = 0;
    PVFS_error error_code = 0;
    DECLARE_PROFILER(profiler);

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: req_sched\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));
    gossip_debug(GOSSIP_SERVER_DEBUG, "validating getattr\n");

    /* Profile validate operation */
    INIT_PROFILER(profiler);
    START_PROFILER(profiler);

    /* Get the errno value to use for comparison */
    error_code = PVFS_get_errno_mapping(js_p->error_code);

    /* RAL:  Need to re-visit this logic.  Should we always create the DATAFILE
     *       dspace record, regardless of operation?
     */ 
    if (error_code == ENOENT)
    {
        /* probably a new object, try to create the object */
        s_op->ds_attr.fs_id = s_op->target_fs_id;
        s_op->ds_attr.handle = s_op->target_handle;
        create_object = 1;
        js_p->error_code = 0;
        switch (s_op->req->op)
        {
        /* datafile object specific */
        case PVFS_SERV_IO :
        case PVFS_SERV_SMALL_IO :
        case PVFS_SERV_TRUNCATE :
            s_op->ds_attr.u.datafile.b_size = 0;
            s_op->ds_attr.type = PVFS_TYPE_DATAFILE;
            break;
        /* dirdata object specific */
        case PVFS_SERV_CRDIRENT :
        case PVFS_SERV_RMDIRENT :
        case PVFS_SERV_CHDIRENT :
            s_op->ds_attr.type = PVFS_TYPE_DIRDATA;
            s_op->ds_attr.u.dirdata.dirent_count = 0;
            break;
        /* either data or dirdata */
        case PVFS_SERV_GETATTR :
        case PVFS_SERV_SETATTR :
        case PVFS_SERV_LISTATTR :
        case PVFS_SERV_GETEATTR :
        case PVFS_SERV_SETEATTR :
        case PVFS_SERV_DELEATTR :
        case PVFS_SERV_LISTEATTR :
        case PVFS_SERV_ATOMICEATTR :
            if (s_op->req->ctrl.sub == PVFS_REQ_DATAFILE)
            {
                s_op->ds_attr.type = PVFS_TYPE_DATAFILE;
                s_op->ds_attr.u.datafile.b_size = 0;
            }
            else if (s_op->req->ctrl.sub == PVFS_REQ_DIRDATA)
            {
                s_op->ds_attr.type = PVFS_TYPE_DIRDATA;
                s_op->ds_attr.u.dirdata.dirent_count = 0;
            }
            else
            {
                gossip_err("Prelude asked to create object of unknown type\n");
                create_object = 0;
                js_p->error_code = ENOENT;
            }
            break;
        /* normal ops where the object is not expected to exist
         * beforehand
         */
        case PVFS_SERV_CREATE :
        case PVFS_SERV_MKDIR :
            create_object = 0;
            js_p->error_code = 0;
            break;
        default:
                gossip_err("Prelude has request of unknown op %d\n",
                           s_op->req->op);
                create_object = 0;
                js_p->error_code = ENOENT;
            break;
        }
    }

#if 0
    if (error_code == ENOENT && (s_op->req->op == PVFS_SERV_IO || 
                                 s_op->req->op == PVFS_SERV_GETATTR))
    {
        /* we failed to find the dpsace record.  fake one and we will 
         * add it later if validation works out.
         */
        s_op->ds_attr.type = PVFS_TYPE_DATAFILE;
        s_op->ds_attr.fs_id = s_op->target_fs_id;
        s_op->ds_attr.handle = s_op->target_handle;
        s_op->ds_attr.u.datafile.b_size = 0;
        create_object = 1;
        js_p->error_code = 0;
    }
    if (error_code == ENOENT && s_op->req->op == PVFS_SERV_SETATTR)
    {
        /* we failed to find the dpsace record.  fake one and we will 
         * add it later if validation works out.
         */
        s_op->ds_attr.type = PVFS_TYPE_DIRDATA;
        s_op->ds_attr.fs_id = s_op->target_fs_id;
        s_op->ds_attr.handle = s_op->target_handle;
        s_op->ds_attr.u.dirdata.dirent_count = 0;
        create_object = 1;
        js_p->error_code = 0;
    }
#endif

    /*
     * first we translate the dspace attributes into a more convenient
     * server use-able format.  i.e. a PVFS_object_attr
     */
    PVFS_object_attr_from_ds_attr(&s_op->attr, &s_op->ds_attr);

    if ( s_op->attr.objtype == PVFS_TYPE_DATAFILE )
    {
       s_op->attr.mask = PVFS_ATTR_DATA_ALL;
    }
    else
    if ( s_op->attr.objtype == PVFS_TYPE_DIRDATA )
    {
       s_op->attr.mask = PVFS_ATTR_DIRDATA_ALL;
    }
    else
    {
       s_op->attr.mask = PVFS_ATTR_COMMON_ALL;
    }

    s_op->target_object_attr = &s_op->attr;

    if (s_op->prelude_mask & PRELUDE_PERM_CHECK_DONE)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "(%p) %s (prelude sm) perm check already done... "
                     "skipping.\n", s_op,
                     PINT_map_server_op_to_string(s_op->req->op));

        return SM_ACTION_COMPLETE;
    }

    PINT_debug_capability(&s_op->req->capability, "Received");

    if (s_op->target_fs_id != PVFS_FS_ID_NULL)
    {
        /*
         * if we are exporting a volume readonly, disallow any operation 
         * that modifies the state of the file-system.
         */
        if (permit_operation(s_op->target_fs_id,
                             s_op->access_type,
                             s_op->addr) < 0)
        {
            js_p->error_code = -PVFS_EROFS;
            goto complete;
        }
    }

    PINT_server_req_get_credential(s_op->req, &cred);
    if (cred != NULL)
    {
#ifdef ENABLE_CREDCACHE
        credcache_hit = (PINT_credcache_lookup(cred) != NULL);

        gossip_debug(GOSSIP_SECURITY_DEBUG, "%s: cred cache %s\n", __func__,
                     (credcache_hit) ? "hit" : "miss");
#endif
        /* do not verify credential on credcache hit */
        ret = (credcache_hit) ? 1 : PINT_verify_credential(cred);

#ifdef ENABLE_CREDCACHE
        if (!credcache_hit && ret)
        {
            /* cache credential */
            PINT_credcache_insert(cred);
        }
#endif
        if (!ret)
        {
            char sig_buf[16];

            gossip_debug(GOSSIP_SECURITY_DEBUG, 
                         "Credential (%s) from %s failed verification.\n",
                         PINT_util_bytes2str(cred->signature, sig_buf, 4),
                         cred->issuer);

            /* have client try again on timeout */
            if (PINT_util_get_current_time() > cred->timeout)
            {
                js_p->error_code = -PVFS_EAGAIN;
            }
            else
            {
                js_p->error_code = -PVFS_EPERM;
            }
            
            goto complete;
        }
    }

    if ((s_op->target_fs_id != PVFS_FS_ID_NULL) && (cred != NULL))
    {
        PVFS_uid uid, translated_uid;
        PVFS_gid group_array[PVFS_REQ_LIMIT_GROUPS], translated_gid;
        uint32_t num_groups;
        
        /* map the credential */
        ret = PINT_map_credential(cred, &uid, &num_groups, group_array);
        if (ret != 0)
        {
            js_p->error_code = ret;

            goto complete;
        }

        /* Translate the uid and gid's in case we need to do some squashing 
         * based on the export and the client address
         */
        /* TODO: testing */
        if (translate_ids(s_op->target_fs_id,
                          uid, 
                          group_array[0],
                          &translated_uid, 
                          &translated_gid,
                          s_op->addr) == 1)
        {
            /* TODO: not applicable to certificates */
            /* modify the credential. doesn't support secondary groups */
            cred->userid = translated_uid;
            cred->group_array[0] = translated_gid;
            cred->num_groups = 1;

            /* nlmills: can't call PINT_cleanup_credential because
             * the issuer string points inside the message buffer.
             */
            free(cred->signature);
            cred->signature = NULL;
            ret = PINT_sign_credential(cred);
            if (ret)
            {
                js_p->error_code = -PVFS_ENOMEM;
                goto complete;
            }

            /* TODO: this needs to be reworked */
            /* certain requests rely on the request attributes having the
             * same uid/gid as the client 
             */
            if (s_op->req->op == PVFS_SERV_SETATTR)
            {
                s_op->req->u.setattr.attr.owner = translated_uid;
                s_op->req->u.setattr.attr.group = translated_gid;
            }
            else if (s_op->req->op == PVFS_SERV_MKDIR)
            {
                s_op->req->u.mkdir.attr.owner = translated_uid;
                s_op->req->u.mkdir.attr.group = translated_gid;
            }
            else if (s_op->req->op == PVFS_SERV_CREATE)
            {
                s_op->req->u.create.attr.owner = translated_uid;
                s_op->req->u.create.attr.group = translated_gid;
            }
        }
    }

    /* check capability cache for non-null capabilities */
#ifdef ENABLE_CAPCACHE
    capcache_hit = 1;
    if (!PINT_capability_is_null(&s_op->req->capability))
    {        
        capcache_hit = (PINT_capcache_lookup(&s_op->req->capability) != NULL);        
        gossip_debug(GOSSIP_SECURITY_DEBUG, "%s: cap cache %s!\n", __func__,
                     (capcache_hit) ? "hit" : "miss");
    }
#endif

    /* do not verify cap on cache hit */
    ret = (capcache_hit) ? 1 : PINT_verify_capability(&s_op->req->capability);

    /* check operation permissions */
    if (ret)
    {
        ret = PINT_perm_check(s_op);
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s:return from PINT_perm_check=%d\n"
                                        ,__func__
                                        ,ret);
    }
    else
    {
        char sig_buf[16]; 

        gossip_debug(GOSSIP_SECURITY_DEBUG, 
                     "Capability (%s) from %s failed verification.\n",
                     PINT_util_bytes2str(s_op->req->capability.signature,
                                         sig_buf, 4),
                     s_op->req->capability.issuer);

        /* have client try again on timeout */
        if (PINT_util_get_current_time() > s_op->req->capability.timeout)
        {
            js_p->error_code = -PVFS_EAGAIN;
        }
        else
        {
            js_p->error_code = -PVFS_EPERM;
        }
        
        goto complete;
    }

    /* anything else we treat as a real error */
    if (js_p->error_code)
    {
        js_p->error_code = -PVFS_ERROR_CODE(-js_p->error_code);
        return SM_ACTION_COMPLETE;
    }

    js_p->error_code = ret;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (req=%d) (prelude sm) state: perm_check (status = %d)\n",
                 s_op, PINT_map_server_op_to_string(s_op->req->op),s_op->req->op,
                 js_p->error_code);

complete:

    FINISH_PROFILER("pv2", profiler, 1);
     
    /* if everything has checked out so far except the
     * dspace record is missing, then create the dspace record
     */
    if (js_p->error_code == 0 && create_object == 1)
    {
        js_p->error_code = CREATE_OBJECT;
    }
#if 0
        if (s_op->attr.objtype == PVFS_TYPE_DATAFILE)
        {
            js_p->error_code = CREATE_DATA_OBJECT;
        }
        else if (s_op->attr.objtype == PVFS_TYPE_DIRDATA)
        {
            js_p->error_code = CREATE_DIRDATA_OBJECT;
        }
    }
#endif
    return SM_ACTION_COMPLETE;
}

/* if opcode is appropriate and we have a proper capability
 * then we create the object - a DFILE with the approporiate
 * attributes
 */
//static PINT_sm_action prelude_create_data_object_if_allowed(
static PINT_sm_action prelude_create_object_if_allowed(
                                                       struct PINT_smcb *smcb,
                                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    job_id_t tmp_id;


    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: req_sched\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));
    gossip_debug(GOSSIP_SERVER_DEBUG, "creating missing object\n");
#if 0
    /* RAL:  revisit the operations allowed to create a DATAFILE dspace record
     */ 
    switch (s_op->req->op)
    {
    /* data object specific */
    case PVFS_SERV_IO :
    case PVFS_SERV_SMALL_IO :
    case PVFS_SERV_TRUNCATE :
    /* either data or dirdata */
    case PVFS_SERV_GETATTR :
    case PVFS_SERV_SETATTR :
    case PVFS_SERV_GETEATTR :
    case PVFS_SERV_SETEATTR :
    case PVFS_SERV_DELEATTR :
    case PVFS_SERV_LISTEATTR :
    case PVFS_SERV_ATOMICEATTR :
#endif
        /* setup and post dspace create job */
        ret = job_trove_dspace_create(s_op->target_fs_id,
                                      s_op->target_handle,
                                      s_op->attr.objtype,
                                      NULL, /* hint */
                                      0,    /* flags */
                                      smcb, /* user_ptr */
                                      0,    /* status_user_tag */
                                      js_p,
                                      &tmp_id,
                                      server_job_context,
                                      s_op->req->hints);
        return ret;
#if 0
    default :
        break;
    }

    return SM_ACTION_COMPLETE;
#endif
}

#if 0
/* if opcode is appropriate and we have a proper capability
 * then we create the object - a DIRDATA with the approporiate
 * attributes
 */
static PINT_sm_action prelude_create_dirdata_object_if_allowed(
                                                       struct PINT_smcb *smcb,
                                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    job_id_t tmp_id;

#if 0
    switch (s_op->req->op)
    {
    /* data object specific */
    case PVFS_SERV_CRDIRENT :
    case PVFS_SERV_RMDIRENT :
    case PVFS_SERV_CHDIRENT :
    /* either data or dirdata */
    case PVFS_SERV_GETATTR :
    case PVFS_SERV_SETATTR :
    case PVFS_SERV_GETEATTR :
    case PVFS_SERV_SETEATTR :
    case PVFS_SERV_DELEATTR :
    case PVFS_SERV_LISTEATTR :
    case PVFS_SERV_ATOMICEATTR :
#endif
        /* setup and post dirdata create job */
        ret = job_trove_dspace_create(s_op->target_fs_id,
                                      s_op->target_handle,
                                      PVFS_TYPE_DIRDATA,
                                      NULL, /* hint */
                                      0,    /* flags */
                                      smcb, /* user_ptr */
                                      0,    /* status_user_tag */
                                      js_p,
                                      &tmp_id,
                                      server_job_context,
                                      s_op->req->hints);
        return ret;
#if 0
    default :
        break;
    }

    return SM_ACTION_COMPLETE;
#endif
}
#endif

static PINT_sm_action prelude_write_new_object_attr(struct PINT_smcb *smcb,
                                                    job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t tmp_id;
    time_t current_time;
    int ret;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: req_sched\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));
    gossip_debug(GOSSIP_SERVER_DEBUG, "writing attributes for new object\n");

    js_p->error_code = 0;

#if 0
    /* RAL:  revisit if operation type is necessary */
    switch (s_op->req->op)
    {
    case PVFS_SERV_IO :
    case PVFS_SERV_GETATTR :
    case PVFS_SERV_SETATTR :
#endif

    /* initialize the time members */
    current_time = time(NULL);
    s_op->ds_attr.atime = current_time;
    s_op->ds_attr.mtime = current_time;
    s_op->ds_attr.ctime = current_time;
    s_op->ds_attr.ntime = current_time;

    /* I'm pretty sure that s_op->attr has nothing in it - its failure
     * is what started us down this path - so we need a better/more
     * reliable place to get this data from.
     */

    /* s_op->ds_attr.type = ; already done */
    s_op->ds_attr.fs_id =  s_op->target_fs_id;
    s_op->ds_attr.handle = s_op->target_handle;
    /*
    s_op->ds_attr.uid = s_op->attr.owner;
    s_op->ds_attr.gid = s_op->attr.group;
    s_op->ds_attr.mode = s_op->attr.perms;
    */
    s_op->ds_attr.uid = s_op->req->u.setattr.attr.owner;
    s_op->ds_attr.gid = s_op->req->u.setattr.attr.group;
    s_op->ds_attr.mode = s_op->req->u.setattr.attr.perms;


    switch (s_op->ds_attr.type)
    {
    case PVFS_TYPE_DIRDATA :
        s_op->ds_attr.u.dirdata.dirent_count = 0; /* new object no items */
        s_op->ds_attr.u.dirdata.tree_height = 
                           s_op->attr.u.dirdata.dist_dir_attr.tree_height;
        s_op->ds_attr.u.dirdata.dirdata_count = 
                           s_op->attr.u.dirdata.dist_dir_attr.dirdata_count;
        s_op->ds_attr.u.dirdata.sid_count = 
                           s_op->attr.u.dirdata.dist_dir_attr.sid_count;
        s_op->ds_attr.u.dirdata.bitmap_size = 
                           s_op->attr.u.dirdata.dist_dir_attr.bitmap_size;
        s_op->ds_attr.u.dirdata.split_size = 
                           s_op->attr.u.dirdata.dist_dir_attr.split_size;
        s_op->ds_attr.u.dirdata.server_no = 
                           s_op->attr.u.dirdata.dist_dir_attr.server_no;
        /* s_op->ds_attr.u.dirdata.branch_level = ; already done */

        break;
    case PVFS_TYPE_DATAFILE :
        /* s_op->ds_attr.u.wdatafile.b_size = ; already done */

    default:
        break;
    }

    /* post dspace setattr job */
    ret = job_trove_dspace_setattr(s_op->target_fs_id,
                                   s_op->target_handle,
                                   &(s_op->ds_attr),
                                   TROVE_SYNC, /* flags */
                                   smcb,       /* user_ptr */
                                   0,          /* status_user_tag */
                                   js_p,
                                   &tmp_id,
                                   server_job_context,
                                   s_op->req->hints);
    return ret;
#if 0
    default :
        break;
    }

    return SM_ACTION_COMPLETE;
#endif
}

static PINT_sm_action prelude_write_new_object_keyval(struct PINT_smcb *smcb,
                                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;
    PVFS_object_attr *pattr;
    int ret = -1;
    job_id_t j_id;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: req_sched\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));
    gossip_debug(GOSSIP_SERVER_DEBUG, "writing keyvals for new object\n");

    /* total 3 static keyvals every dirdata has:
     * PVFS_DIRDATA_BITMAP, PVFS_DIRDATA_HANDLES, PARENT */
    int keyval_count = 3;

    pattr = &s_op->req->u.mkdir.attr;

    s_op->key_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->key_a)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->key_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    s_op->val_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);

    /*gossip_debug(GOSSIP_SERVER_DEBUG, "prelude setting up kvals %s\n", s_op->val_a); */

    if(!s_op->val_a)
    {
        free(s_op->key_a);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->val_a, (sizeof(PVFS_ds_keyval) * keyval_count));

/*---------------------------------------------------------------------------*/

    s_op->key_a[0].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].size;
    s_op->key_a[0].buffer = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].key;

    s_op->val_a[0].buffer_sz = pattr->u.dir.dist_dir_attr.bitmap_size *
                               sizeof(PVFS_dist_dir_bitmap_basetype);
    s_op->val_a[0].buffer = pattr->u.dir.dist_dir_bitmap;
    /*gossip_debug(GOSSIP_SERVER_DEBUG, "prelude setting up kvals %s\n", s_op->val_a); */
    keep_keyval_buffers(s_op, 0);

/*---------------------------------------------------------------------------*/

    s_op->key_a[1].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].size;
    s_op->key_a[1].buffer = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].key;

    s_op->val_a[1].buffer_sz = OSASZ(pattr->u.dir.dist_dir_attr.dirdata_count,
                                     pattr->u.dir.dist_dir_attr.sid_count);
    s_op->val_a[1].buffer = pattr->u.dir.dirdata_handles;
    /*gossip_debug(GOSSIP_SERVER_DEBUG, "prelude setting up kvals %s\n", s_op->val_a);*/
    keep_keyval_buffers(s_op, 1);

/*---------------------------------------------------------------------------*/

    s_op->key_a[2].buffer_sz = Trove_Common_Keys[OBJECT_PARENT_KEY].size;
    s_op->key_a[2].buffer = Trove_Common_Keys[OBJECT_PARENT_KEY].key;

    s_op->val_a[2].buffer_sz = OSASZ(1, s_op->req->u.mkdir.sid_count);
    s_op->val_a[2].buffer = s_op->req->u.mkdir.parent;

/*---------------------------------------------------------------------------*/

    keep_keyval_buffers(s_op, 2);

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "  writing dist-dir-struct keyvals for dirdata: %s "
                 "\t with server_no=%d and branch_level=%d \n",
                 PVFS_OID_str(&s_op->u.mkdir.handle),
                 pattr->u.dir.dist_dir_attr.server_no,
                 pattr->u.dir.dist_dir_attr.branch_level);

    i = s_op->u.mkdir.handle_index;

    ret = job_trove_keyval_write_list(s_op->req->u.mkdir.fs_id,
                                      s_op->req->u.mkdir.dirdata_handles[i],
                                      s_op->key_a,
                                      s_op->val_a,
                                      keyval_count,
                                      TROVE_SYNC, /* flags */
                                      NULL,       /* vtag */
                                      smcb,       /* user_ptr */
                                      0,          /* status_user_tag */
                                      js_p,
                                      &j_id,
                                      server_job_context,
                                      s_op->req->hints);

    return ret;
}

/******************* Helper Functions *******************/

static void get_anon_ids(struct filesystem_configuration_s *fsconfig,
                         PVFS_uid *uid,
                         PVFS_gid *gid)
{
    *uid = fsconfig->exp_anon_uid;
    *gid = fsconfig->exp_anon_gid;
    return;
}

static int iterate_all_squash_wildcards(
                              struct filesystem_configuration_s *fsconfig,
                              PVFS_BMI_addr_t client_addr)
{
    int i;

    for (i = 0; i < fsconfig->all_squash_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "BMI_query_addr_range %lld, %s\n",
                     lld(client_addr), fsconfig->all_squash_hosts[i]);
        if (BMI_query_addr_range(client_addr,
                                 fsconfig->all_squash_hosts[i],
                                 fsconfig->all_squash_netmasks[i]) == 1)
        {
            return 1;
        }
    }
    return 0;
}

static int iterate_root_squash_wildcards(
                               struct filesystem_configuration_s *fsconfig,
                               PVFS_BMI_addr_t client_addr)
{
    int i;

    /* check exceptions first */
    for (i = 0; i < fsconfig->root_squash_exceptions_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "BMI_query_addr_range %lld, %s, netmask: %i\n",
            lld(client_addr), fsconfig->root_squash_exceptions_hosts[i],
            fsconfig->root_squash_exceptions_netmasks[i]);
        if (BMI_query_addr_range(
                           client_addr,
                           fsconfig->root_squash_exceptions_hosts[i], 
                           fsconfig->root_squash_exceptions_netmasks[i]) == 1)
        {
            /* in the exception list, do not squash */
            return 0;
        }
    }

    for (i = 0; i < fsconfig->root_squash_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "BMI_query_addr_range %lld, %s, netmask: %i\n",
                     lld(client_addr), fsconfig->root_squash_hosts[i],
                     fsconfig->root_squash_netmasks[i]);
        if (BMI_query_addr_range(client_addr,
                                 fsconfig->root_squash_hosts[i], 
                                 fsconfig->root_squash_netmasks[i]) == 1)
        {
            return 1;
        }
    }
    return 0;
}

/* Translate_ids will return 1 if it did some uid/gid squashing, 0 otherwise */
static int translate_ids(PVFS_fs_id fsid,
                         PVFS_uid uid,
                         PVFS_gid gid,
                         PVFS_uid *translated_uid,
                         PVFS_gid *translated_gid,
                         PVFS_BMI_addr_t client_addr)
{
    int exp_flags = 0;
    struct server_configuration_s *serv_config = NULL;
    struct filesystem_configuration_s * fsconfig = NULL;

    serv_config = PINT_server_config_mgr_get_config();
    fsconfig = PINT_config_find_fs_id(serv_config, fsid);

    if (fsconfig == NULL)
    {
        return 0;
    }
    exp_flags = fsconfig->exp_flags;
    /* If all squash was set */
    if (exp_flags & TROVE_EXP_ALL_SQUASH)
    {
        if (iterate_all_squash_wildcards(fsconfig, client_addr) == 1)
        {
            get_anon_ids(fsconfig, translated_uid, translated_gid);
            gossip_debug(GOSSIP_SERVER_DEBUG,
                "Translated ids from <%u:%u> to <%u:%u>\n",
                uid, gid, *translated_uid, *translated_gid);
            return 1;
        }
    }
    /* if only root squash was set translate uids for root alone*/
    if (exp_flags & TROVE_EXP_ROOT_SQUASH)
    {
        if (uid == 0 || gid == 0)
        {
            if (iterate_root_squash_wildcards(fsconfig, client_addr) == 1)
            {
                get_anon_ids(fsconfig, translated_uid, translated_gid);
                gossip_debug(GOSSIP_SERVER_DEBUG,
                    "Translated ids from <%u:%u> to <%u:%u>\n",
                    uid, gid, *translated_uid, *translated_gid);
                return 1;
            }
        }
    }
    /* no such translation required! */
    *translated_uid = uid;
    *translated_gid = gid;
    return 0;
}

static int iterate_ro_wildcards(struct filesystem_configuration_s *fsconfig,
                                PVFS_BMI_addr_t client_addr)
{
    int i;

    for (i = 0; i < fsconfig->ro_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "BMI_query_addr_range %lld, %s\n",
            lld(client_addr), fsconfig->ro_hosts[i]);
        /* Does the client address match the wildcard specification and/or */
        /* the netmask specification?                                      */
        if (BMI_query_addr_range(client_addr, fsconfig->ro_hosts[i],
                fsconfig->ro_netmasks[i]) == 1)
        {
            return 1;
        }
    }
    return 0;
}

/*
 * Return zero if this operation should be allowed.
 */
static int permit_operation(PVFS_fs_id fsid,
                            enum PINT_server_req_access_type access_type,
                            PVFS_BMI_addr_t client_addr)
{ 
    int exp_flags = 0; 
    struct server_configuration_s *serv_config = NULL;
    struct filesystem_configuration_s * fsconfig = NULL;

    if (access_type == PINT_SERVER_REQ_READONLY)
    {
        return 0;  /* anything that doesn't modify state is okay */
    }
    serv_config = PINT_server_config_mgr_get_config();
    fsconfig = PINT_config_find_fs_id(serv_config, fsid);

    if (fsconfig == NULL)
    {
        return 0;
    }
    exp_flags = fsconfig->exp_flags;

    /* cheap test to see if ReadOnly was even specified in the exportoptions */
    if (!(exp_flags & TROVE_EXP_READ_ONLY))
    {
        return 0;
    }
    /* Drat. Iterate thru the list of wildcards specified in
     * server_configuration and see
     * the client address matches. if yes, then we deny permission
     */
    if (iterate_ro_wildcards(fsconfig, client_addr) == 1)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, 
            "Disallowing read-write operation on a read-only exported file-system\n");
        return -EROFS;
    }
    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
