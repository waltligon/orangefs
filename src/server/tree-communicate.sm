/* 
 * (C) 2008 Clemson University and The University of Chicago
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for creating files.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "pvfs2-dist-simple-stripe.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "pint-distribution.h"
#include "PINT-reqproto-encode.h"
#include "pint-util.h"
#include "pint-dist-utils.h"
#include "ncache.h"
#include "pvfs2-internal.h"
#include "extent-utils.h"
#include "security-util.h"

enum
{
    LOCAL_OPERATION = 2,
    REMOTE_OPERATION = 3
};

/* completion function prototypes */
static int tree_setattr_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
static int tree_remove_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
static int tree_get_file_size_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
static int tree_getattr_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);

%%

machine pvfs2_tree_setattr_sm
{
    state tree_setattr_do_work
    {
        jump pvfs2_tree_setattr_work_sm;
        default => tree_setattr_final_response;
    }

    state tree_setattr_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_setattr_cleanup;
    }

    state tree_setattr_cleanup
    {
        run tree_setattr_cleanup;
        default => terminate;
    }
}

nested machine pvfs2_tree_setattr_work_sm
{
    state tree_setattr_work_do_work
    {
        pjmp tree_setattr_setup
        {
            REMOTE_OPERATION => pvfs2_pjmp_call_msgpairarray_sm;
            LOCAL_OPERATION => pvfs2_pjmp_set_attr_work_sm;
        }
        default => tree_setattr_work_cleanup;
    }

    state tree_setattr_work_cleanup
    {
        run tree_setattr_work_cleanup;
        default => return;
    }
}

machine pvfs2_tree_remove_sm
{
    state tree_remove_do_work
    {
        jump pvfs2_tree_remove_work_sm;
        default => tree_remove_final_response;
    }

    state tree_remove_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_remove_cleanup;
    }

    state tree_remove_cleanup
    {
        run tree_remove_cleanup;
        default => terminate;
    }
}

nested machine pvfs2_tree_remove_work_sm
{
    state tree_remove_work_do_work
    {
        pjmp tree_remove_setup
        {
            REMOTE_OPERATION => pvfs2_pjmp_call_msgpairarray_sm;
            LOCAL_OPERATION => pvfs2_pjmp_remove_work_sm;
        }
        default => tree_remove_work_cleanup;
    }

    state tree_remove_work_cleanup
    {
        run tree_remove_work_cleanup;
        default => return;
    }
}

machine pvfs2_tree_get_file_size_sm
{
    state tree_get_file_size_do_work
    {
        jump pvfs2_tree_get_file_size_work_sm;
        default => tree_get_file_size_final_response;
    }

    state tree_get_file_size_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_get_file_size_cleanup;
    }

    state tree_get_file_size_cleanup
    {
        run tree_get_file_size_cleanup;
        default => terminate;
    }
}

nested machine pvfs2_tree_get_file_size_work_sm
{
    state tree_get_file_size_work_do_work
    {
        pjmp tree_get_file_size_setup
        {
            REMOTE_OPERATION => pvfs2_pjmp_call_msgpairarray_sm;
            LOCAL_OPERATION => pvfs2_pjmp_get_attr_work_sm;
        }
        default => tree_get_file_size_work_cleanup;
    }

    state tree_get_file_size_work_cleanup
    {
        run tree_get_file_size_work_cleanup;
        default => return;
    }
}

machine pvfs2_tree_getattr_sm
{       
    state tree_getattr_do_work
    {
        jump pvfs2_tree_getattr_work_sm;
        default => tree_getattr_final_response;
    }
        
    state tree_getattr_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_getattr_cleanup;
    }
        
    state tree_getattr_cleanup
    {
        run tree_getattr_cleanup;
        default => terminate;
    }
}
    
nested machine pvfs2_tree_getattr_work_sm
{       
    state tree_getattr_work_do_work
    {       
        pjmp tree_getattr_setup
        {
            REMOTE_OPERATION => pvfs2_pjmp_call_msgpairarray_sm;
            LOCAL_OPERATION => pvfs2_pjmp_get_attr_work_sm;
        }
        default => tree_getattr_work_cleanup;
    }
        
    state tree_getattr_work_cleanup
    {
        run tree_getattr_work_cleanup;
        default => return;
    }
}

%%

static PINT_sm_action tree_communicate_partition_handles(struct PINT_smcb *smcb,
    job_status_s *js_p,
    int num_data_files,
    PVFS_fs_id fs_id,
    enum PVFS_server_op operation,
    PVFS_handle *handle_array)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *tree_communicate_s_op = NULL;
    struct PVFS_server_req *this_req = s_op->req;
    int num_partitions, num_files_per_server;
    int i;
    char server_name[1024];
    struct server_configuration_s *server_config = PINT_server_config_mgr_get_config();
    int ret = -PVFS_EINVAL;
    struct PVFS_server_req *req = NULL;
    PVFS_capability capability;

    s_op->u.tree_communicate.handle_array_local = calloc(
        num_data_files, sizeof(*s_op->u.tree_communicate.handle_array_local));
    s_op->u.tree_communicate.handle_array_remote = calloc(
        num_data_files, sizeof(*s_op->u.tree_communicate.handle_array_remote));
    s_op->u.tree_communicate.local_join_size = calloc(
        num_data_files, sizeof(*s_op->u.tree_communicate.local_join_size));
    s_op->u.tree_communicate.remote_join_size = calloc(
        num_data_files, sizeof(*s_op->u.tree_communicate.remote_join_size));

    if (!s_op->u.tree_communicate.handle_array_local  ||
        !s_op->u.tree_communicate.handle_array_remote ||
        !s_op->u.tree_communicate.local_join_size     ||
        !s_op->u.tree_communicate.remote_join_size)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* Separate the handles into local and remote. */
    for (i = 0; i < num_data_files; i++)
    {
        PINT_cached_config_get_server_name(server_name, 1024, handle_array[i], fs_id);
        if (! strcmp(server_config->host_id, server_name)) /* this one is local */
        {
            gossip_debug(GOSSIP_SERVER_DEBUG,
                     "tree_communicate_partition_handles: local handle = %llu\n",
                     llu(handle_array[i]));
            s_op->u.tree_communicate.handle_array_local[
                 s_op->u.tree_communicate.handle_array_local_count] = handle_array[i];
            s_op->u.tree_communicate.local_join_size[
                 s_op->u.tree_communicate.handle_array_local_count] = i;
            s_op->u.tree_communicate.handle_array_local_count++;
        }
        else
        {
            gossip_debug(GOSSIP_SERVER_DEBUG,
                     "tree_communicate_partition_handles: remote handle = %llu\n",
                     llu(handle_array[i]));
            s_op->u.tree_communicate.handle_array_remote[
                 s_op->u.tree_communicate.handle_array_remote_count] = handle_array[i];
            s_op->u.tree_communicate.remote_join_size[
                 s_op->u.tree_communicate.handle_array_remote_count] = i;
            s_op->u.tree_communicate.handle_array_remote_count++;
        }
    }/*end for*/

    if (s_op->u.tree_communicate.handle_array_local_count > 0) {

        for (i=0; i<s_op->u.tree_communicate.handle_array_local_count; i++)
        {
            /* Create a stack frame for the local operation. */
            s_op->num_pjmp_frames++;
            js_p->error_code = LOCAL_OPERATION;

            PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, tree_communicate_s_op,
                s_op->u.tree_communicate.handle_array_local[i],
                fs_id, js_p->error_code, req, LOCAL_OPERATION);

            /*keep info in new op structure for later use*/
            tree_communicate_s_op->resp = s_op->resp;
            tree_communicate_s_op->u.tree_communicate = s_op->u.tree_communicate;

            switch (operation)
            {
            case PVFS_SERV_TREE_SETATTR:
            {
                PVFS_sys_attr dummy_sys_attr;
                
                memset(&dummy_sys_attr, 0, sizeof(PVFS_sys_attr));
                
                PINT_SERVREQ_SETATTR_FILL(
                    *req,
                    s_op->req->capability,
                    s_op->req->u.tree_setattr.credential,
                    fs_id,
                    s_op->u.tree_communicate.handle_array_local[i],
                    this_req->u.tree_setattr.objtype,
                    dummy_sys_attr,
                    0,
                    s_op->req->hints);

                /* copy to req->u.setattr.attr because of calling pvfs2_set_attr_work_sm next */
                PINT_copy_object_attr(&req->u.setattr.attr,
                    &this_req->u.tree_setattr.attr);
                req->u.setattr.attr.objtype = 
                    this_req->u.tree_setattr.objtype;
                req->u.setattr.attr.mask |= PVFS_ATTR_COMMON_TYPE;
                
                tree_communicate_s_op->local_index = i;
 
                break;
            }   
            
            case PVFS_SERV_TREE_REMOVE:
            {
                PINT_SERVREQ_REMOVE_FILL(
                    *req,
                    s_op->req->capability,
                    s_op->req->u.tree_remove.credential,
                    fs_id,
                    s_op->u.tree_communicate.handle_array_local[i],
                    s_op->req->hints);

                /*this identifies which "local" frame is being populated.*/
                /* we need to store this int in a location not in the union.
                 * it will be accessed as u.getattr in the state machine
                 * so we can't rely on a value in u.tree_communicate here.
                 * All we need is an int, I'm loathe to do a malloc instead of
                 * just re-purposing one of the existing ints in the s_op. */
                tree_communicate_s_op->local_index = i;

                break;
            }

            case PVFS_SERV_TREE_GET_FILE_SIZE:
            {
                PINT_SERVREQ_GETATTR_FILL(
                    *req,
                    s_op->req->capability,
                    this_req->u.tree_get_file_size.credential,
                    fs_id,
                    s_op->u.tree_communicate.handle_array_local[i],
                    PVFS_ATTR_DATA_SIZE,
                    s_op->req->hints);

                /*this identifies which "local" frame is being populated.*/
                /* we need to store this int in a location not in the union.
                 * it will be accessed as u.getattr in the state machine
                 * so we can't rely on a value in u.tree_communicate here.
                 * All we need is an int, I'm loathe to do a malloc instead of
                 * just re-purposing one of the existing ints in the s_op. */
                tree_communicate_s_op->local_index = i;

                break;
            }

            case PVFS_SERV_TREE_GETATTR:
            {
                PINT_SERVREQ_GETATTR_FILL(
                    *req,
                    s_op->req->capability,
                    this_req->u.tree_getattr.credential,
                    fs_id,
                    s_op->u.tree_communicate.handle_array_local[i],
                    s_op->req->u.tree_getattr.attrmask,
                    s_op->req->hints);

                /*this identifies which "local" frame is being populated.*/
                /* we need to store this int in a location not in the union.
                 * it will be accessed as u.getattr in the state machine
                 * so we can't rely on a value in u.tree_communicate here.
                 * All we need is an int, I'm loathe to do a malloc instead of
                 * just re-purposing one of the existing ints in the s_op. */
                tree_communicate_s_op->local_index = i;

                break;
            }

            default:
                break;
        }/*end switch*/
       }/*end for*/
    }/*end if local*/

    if (s_op->u.tree_communicate.handle_array_remote_count > 0) {

      /* Decide how to divide the remote handles. If there are only a few
         (fewer than tree_threshhold from the config file) then go ahead and
         send to each remaining server individually. */
      if (s_op->u.tree_communicate.handle_array_remote_count >
          server_config->tree_threshold)
      {
          num_partitions = server_config->tree_width;
          num_files_per_server =
                   s_op->u.tree_communicate.handle_array_remote_count /
                   server_config->tree_width;
          if (num_partitions * num_files_per_server <
                   s_op->u.tree_communicate.handle_array_remote_count) {
                num_files_per_server++;
            }
        }
        else
        {
            num_partitions = s_op->u.tree_communicate.handle_array_remote_count;
            num_files_per_server = 1;
        }

        gossip_debug(GOSSIP_SERVER_DEBUG,
            "tree_communicate_partition_handles: num_data_files = %d,"
            " num_remote_handles = %d, "
            "num_partitions = %d, num_files_per_server = %d\n",
            num_data_files,
            s_op->u.tree_communicate.handle_array_remote_count,
            num_partitions,
            num_files_per_server);

        /* We need to send tree-based messages to other servers */
        js_p->error_code = REMOTE_OPERATION;
        s_op->num_pjmp_frames++;

        /* Prepare the stack for pjmp. */
        PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, tree_communicate_s_op,
            s_op->u.tree_communicate.handle_array_remote[0],
            fs_id, js_p->error_code, req, REMOTE_OPERATION);

        /*store the number of partitions*/
        s_op->u.tree_communicate.num_partitions = num_partitions;

        /*keep info in new op structure for later use*/
        tree_communicate_s_op->resp = s_op->resp;
        tree_communicate_s_op->u.tree_communicate = s_op->u.tree_communicate;
       
        ret = PINT_msgpairarray_init(&tree_communicate_s_op->msgarray_op
                                    ,num_partitions);
        if (ret)
        {
            gossip_lerr("tree_communicate: failed to allocate msgarray\n");
            return -PVFS_ENOMEM;
        }

        /* Use a null capability with tree_get_file_size and tree_getattr op */
        if (operation == PVFS_SERV_TREE_GET_FILE_SIZE ||
            operation == PVFS_SERV_TREE_GETATTR)
        {
            PINT_null_capability(&capability);
        }
        
        /* Fill in the msgarray. */
        for (i = 0; i < num_partitions; i++)
        {
            PINT_sm_msgpair_state *msg_p;
            int num_data_files_for_this_server;

            /* Handle the case where the last partition has fewer files than the
             * other partitions. 
            */
            for (num_data_files_for_this_server = num_files_per_server;
                 i*num_files_per_server + num_data_files_for_this_server >
                 s_op->u.tree_communicate.handle_array_remote_count;
                 num_data_files_for_this_server--)
            {
                /* Do nothing; */
            }

            msg_p = &tree_communicate_s_op->msgarray_op.msgarray[i];

            switch (operation)
            {
                case PVFS_SERV_TREE_SETATTR:
                {
                    PINT_SERVREQ_TREE_SETATTR_FILL(
                        msg_p->req,
                        s_op->req->capability,
                        this_req->u.tree_setattr.credential,
                        fs_id,
                        this_req->u.tree_setattr.objtype,
                        this_req->u.tree_setattr.attr,
                        (i * num_files_per_server),
                        num_data_files_for_this_server,
                        &s_op->u.tree_communicate.handle_array_remote[i*num_files_per_server],
                        s_op->req->hints);
                    msg_p->comp_fn = tree_setattr_comp_fn;

                    msg_p->retry_flag = PVFS_MSGPAIR_RETRY; 
                    break;
                }

                case PVFS_SERV_TREE_REMOVE:
                {
                    PINT_SERVREQ_TREE_REMOVE_FILL(
                        msg_p->req,
                        s_op->req->capability,
                        s_op->req->u.tree_remove.credential,
                        fs_id,
                        (i * num_files_per_server),
                        num_data_files_for_this_server,
                        &s_op->u.tree_communicate.handle_array_remote[i*num_files_per_server],
                        s_op->req->hints);
                    msg_p->comp_fn = tree_remove_comp_fn;
                    msg_p->retry_flag = PVFS_MSGPAIR_RETRY; 
                    break;
                }
    
                case PVFS_SERV_TREE_GET_FILE_SIZE:
                {
                    PINT_SERVREQ_TREE_GET_FILE_SIZE_FILL(
                        msg_p->req,
                        capability,
                        s_op->req->u.tree_get_file_size.credential,
                        fs_id,
                        (i * num_files_per_server),
                        num_data_files_for_this_server,
                        &s_op->u.tree_communicate.handle_array_remote[i*num_files_per_server],
                        this_req->u.tree_get_file_size.retry_msgpair_at_leaf,
                        s_op->req->hints);

                    msg_p->comp_fn = tree_get_file_size_comp_fn;
                    /* if the logical file is mirrored, then we want the 
                     * mirroring logic to handle retries, when we are 
                     * processing the leaf of the tree, i.e., this tree request
                     * contains msgpairs having only one handle each. Otherwise,
                     * we let msgpairarray handle retries.
                     */
                    if ((this_req->u.tree_get_file_size.retry_msgpair_at_leaf) && 
                        (num_files_per_server == 1))
                    {
                        gossip_debug(GOSSIP_SERVER_DEBUG, "%s:retry_flag:"
                                     "PVFS_MSGPAIR_NO_RETRY\n", __func__);
                        msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
                    }
                    else
                    {
                        gossip_debug(GOSSIP_SERVER_DEBUG, "%s:retry_flag:"
                                     "PVFS_MSGPAIR_RETRY\n", __func__);
                        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
                    }
                    break;
                }

                case PVFS_SERV_TREE_GETATTR:
                {
                    PINT_SERVREQ_TREE_GETATTR_FILL(
                        msg_p->req,
                        capability,
                        s_op->req->u.tree_getattr.credential,
                        fs_id,
                        (i * num_files_per_server),
                        num_data_files_for_this_server,
                        &s_op->u.tree_communicate.handle_array_remote[i*num_files_per_server],
                        this_req->u.tree_getattr.attrmask,
                        this_req->u.tree_getattr.retry_msgpair_at_leaf,
                        s_op->req->hints);
                    msg_p->comp_fn = tree_getattr_comp_fn;
                    /* if the logical file is mirrored, then we want the 
                     * mirroring logic to handle retries, when we are 
                     * processing the leaf of the tree, i.e., this tree request
                     * contains msgpairs having only one handle each. Otherwise,
                     * we let msgpairarray handle retries.
                     */                  
                    if ((this_req->u.tree_getattr.retry_msgpair_at_leaf) &&
                        (num_files_per_server == 1))
                    {
                        gossip_debug(GOSSIP_SERVER_DEBUG, "%s:retry_flag:"
                                     "PVFS_MSGPAIR_NO_RETRY\n", __func__);
                        msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
                    }
                    else
                    {
                        gossip_debug(GOSSIP_SERVER_DEBUG, "%s:retry_flag:"
                                   "PVFS_MSGPAIR_RETRY\n", __func__);
                        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
                    }
                    break;
                }

                default:
                    break;
            }
            msg_p->fs_id = fs_id;
            msg_p->handle =
              s_op->u.tree_communicate.handle_array_remote[i*num_files_per_server];

            ret = PINT_cached_config_map_to_server(&msg_p->svr_addr,
                                                   msg_p->handle,
                                                   msg_p->fs_id);
            if (ret)
            {
                gossip_err("Failed to map server address\n");
            }
        }/*end for*/

        if (operation == PVFS_SERV_TREE_GET_FILE_SIZE ||
            operation == PVFS_SERV_TREE_GETATTR)
        {
            PINT_cleanup_capability(&capability);
        }

    }/*end if remote*/

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action tree_setattr_setup(struct PINT_smcb *smcb,
                                         job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    assert(s_op->req->op == PVFS_SERV_TREE_SETATTR);

    s_op->resp.u.tree_setattr.caller_handle_index =
            s_op->req->u.tree_setattr.caller_handle_index;
    s_op->resp.u.tree_setattr.handle_count =
            s_op->req->u.tree_setattr.handle_count;

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: frame:%p \ttree.caller_handle_index:%u\n"
                                     "\t\ttree.handle_count:%d "
                                     "\ttree.op:%d\n"
                                    ,__func__
                                    ,s_op
                                    ,s_op->resp.u.tree_setattr.caller_handle_index
                                    ,s_op->resp.u.tree_setattr.handle_count
                                    ,s_op->resp.op);

    /* allocate response arrays */
    s_op->resp.u.tree_setattr.status = (int32_t *)
        calloc(s_op->req->u.tree_setattr.handle_count, sizeof(int32_t));
    if (! s_op->resp.u.tree_setattr.status)
    {
        gossip_err("tree_setattr: failed to allocate array\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    return (tree_communicate_partition_handles(smcb, js_p, s_op->req->u.tree_setattr.handle_count,
        s_op->req->u.tree_setattr.fs_id, PVFS_SERV_TREE_SETATTR,
        s_op->req->u.tree_setattr.handle_array));
}

static int tree_setattr_comp_fn(void *v_p,
                                struct PVFS_server_resp *resp_p,
                                int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op = PINT_sm_frame(smcb, (PINT_MSGPAIR_PARENT_SM));
    struct PVFS_server_resp *op_resp = &(s_op->resp); /*op resp structure*/
    struct PVFS_server_resp *m_resp = resp_p;         /*msgpair resp structure*/
    struct PVFS_servresp_tree_setattr *op_tree = &(op_resp->u.tree_setattr);
    struct PVFS_servresp_tree_setattr *m_tree  = &(m_resp->u.tree_setattr);
    struct PINT_server_tree_communicate_op *s_tree_comm = &(s_op->u.tree_communicate);
    int i;
    uint32_t status_array_index=0;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_setattr_comp_fn[%d], caller_handle_index = %u\n",
                 index, resp_p->u.tree_setattr.caller_handle_index);

    assert(m_resp->op == PVFS_SERV_TREE_SETATTR);

    if (m_resp->status != 0)
    {
        PVFS_perror_gossip("Setattr failure", m_resp->status);
        return resp_p->status;
    }

    /* stash the status for each file handle */
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: m_resp->u.tree_setattr.handle_count"
                                     " is %d\n"
                                    ,__func__
                                    ,m_resp->u.tree_setattr.handle_count);
    for (i = 0; i < m_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: caller_handle_index:%u "
                                         "\tarray_local_count:%d\n"
                                        ,__func__
                                        ,m_tree->caller_handle_index                                        ,s_tree_comm->handle_array_local_count);
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: status for file %d is %d\n"
                                        ,__func__
                                        ,i
                                        ,m_tree->status[i]);
        status_array_index = s_op->u.tree_communicate.remote_join_size[ i +
                              resp_p->u.tree_setattr.caller_handle_index];

        op_tree->status[status_array_index] = m_tree->status[i];
    }

    return 0;
}

static PINT_sm_action tree_setattr_work_cleanup(struct PINT_smcb *smcb,
                                     job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_servresp_tree_setattr *s_tree = &(s_op->resp.u.tree_setattr);
    int i, j, k, task_id, error_code;
    uint32_t status_array_index=0;
    PINT_server_op *old_frame;
    struct PVFS_servreq_tree_setattr *tree_req = NULL;
    PINT_sm_msgpair_state *tree_msgarray = NULL;
    PINT_sm_msgarray_op *tree_msgop = NULL;

    assert(s_op->req->op == PVFS_SERV_TREE_SETATTR);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "%s: num_pjmp_frames = %d\n"
                ,__func__
                ,s_op->num_pjmp_frames);

    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (old_frame)
        {
           /* sub-tree msgpair array*/
           tree_msgarray  = old_frame->msgarray_op.msgarray;

           /* sub-tree msgop structure */
           tree_msgop = &(old_frame->msgarray_op);


        }

        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Value of task_id is %d\n"
                                        ,__func__,task_id);
        gossip_debug(GOSSIP_SERVER_DEBUG
                    ,"%s: Value of handle_count is %d\n"
                    ,__func__
                    ,old_frame->resp.u.tree_setattr.handle_count);
        gossip_debug(GOSSIP_SERVER_DEBUG
                     ,"%s: Value of error_code is %d\n"
                     ,__func__
                     ,error_code);


        if (task_id == REMOTE_OPERATION)
        {
            if (error_code != 0)
            { /*sub-tree request failed; all handles identified in each msgpair
               *must be retried.  response structure is invalid; use request.
              */
              gossip_debug(GOSSIP_SERVER_DEBUG
                          ,"%s: REMOTE OPERATION encountered error:%d\n"
                          ,__func__
                          ,error_code);
              for (j=0; j < tree_msgop->count; j++)
              {
                 tree_req = &(tree_msgarray[j].req.u.tree_setattr);
                 uint32_t index = 0;
                 for (k=0; k < tree_req->handle_count; k++)
                 {
                    index = tree_req->caller_handle_index
                            + k
                            + s_op->u.tree_communicate.handle_array_local_count;
                    s_op->resp.u.tree_setattr.status[index] = error_code;
                    gossip_err("%s:index:%d \terror[%d]:%d\n"
                              ,__func__
                              ,index
                              ,index
                              ,s_op->resp.u.tree_setattr.status[index]);
                 }/*end for*/
              }/*end for*/
            }/*end if non-zero error-code*/

            /* Free resources used in the request. */
            for (j=0; j < tree_msgop->count; j++)
            {
               tree_req = &(tree_msgarray[j].req.u.tree_setattr);
               PINT_free_object_attr(&tree_req->attr);
            }/*end for*/
           PINT_msgpairarray_destroy(&old_frame->msgarray_op);

        }
        else
        { /* LOCAL OPERATION */
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "%s: status of local handle is %d\n"
                         ,__func__
                         ,error_code);
            gossip_debug(GOSSIP_SERVER_DEBUG,"%s:handle_index:%d\n"
                                            ,__func__
                                           ,old_frame->local_index);
            status_array_index = s_op->u.tree_communicate.local_join_size[
                                     old_frame->local_index];
            s_op->resp.u.tree_setattr.status[status_array_index] = error_code;

            PINT_free_object_attr(&old_frame->req->u.setattr.attr);
            PINT_cleanup_capability(&old_frame->req->capability);
        }
        free(old_frame);
    }/*end for*/

    for (i=0; i<s_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->status[%d]:%d\n"
                                        ,__func__
                                        ,i
                                        ,s_tree->status[i]);
    }

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Resp op:%d \tResp status:%d\n"
                                    ,__func__
                                    ,s_op->resp.op
                                    ,s_op->resp.status);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: s_op->addr:%d\n"
                                    ,__func__
                                    ,(int)s_op->addr);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->caller_handle_index:%u "
                                     "\tresp->handle_count:%d\n"
                                    ,__func__
                                    ,s_tree->caller_handle_index
                                    ,s_tree->handle_count);

    /*deallocate resources*/
    if (s_op->u.tree_communicate.handle_array_local)
       free(s_op->u.tree_communicate.handle_array_local);
    if (s_op->u.tree_communicate.handle_array_remote)
       free(s_op->u.tree_communicate.handle_array_remote);
    if (s_op->u.tree_communicate.local_join_size)
       free(s_op->u.tree_communicate.local_join_size);
    if (s_op->u.tree_communicate.remote_join_size)
       free(s_op->u.tree_communicate.remote_join_size);
    s_op->u.tree_communicate.handle_array_local  = NULL;
    s_op->u.tree_communicate.handle_array_remote = NULL;
    s_op->u.tree_communicate.local_join_size     = NULL;
    s_op->u.tree_communicate.remote_join_size    = NULL;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

void tree_setattr_free(PINT_server_op *s_op)
{
    struct PVFS_servresp_tree_setattr *s_tree = &(s_op->resp.u.tree_setattr);

    /*cleanup response structure*/
    if (s_tree->status)
    {
       free(s_tree->status);
    }
}

static PINT_sm_action tree_setattr_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    tree_setattr_free(s_op);
    return(server_state_machine_complete(smcb));
}

static PINT_sm_action tree_remove_setup(struct PINT_smcb *smcb,
                                        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    assert(s_op->req->op == PVFS_SERV_TREE_REMOVE);

    s_op->resp.u.tree_remove.caller_handle_index =
            s_op->req->u.tree_remove.caller_handle_index;
    s_op->resp.u.tree_remove.handle_count =
            s_op->req->u.tree_remove.handle_count;

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: frame:%p \ttree.caller_handle_index:%u\n"
                                     "\t\ttree.handle_count:%d "
                                     "\ttree.op:%d\n"
                                    ,__func__
                                    ,s_op
                                    ,s_op->resp.u.tree_remove.caller_handle_index
                                    ,s_op->resp.u.tree_remove.handle_count
                                    ,s_op->resp.op);

    /* allocate response arrays */
    s_op->resp.u.tree_remove.status = (int32_t *)
        calloc(s_op->req->u.tree_remove.handle_count, sizeof(int32_t));
    if (! s_op->resp.u.tree_remove.status)
    {
        gossip_err("tree_remove: failed to allocate array\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    return (tree_communicate_partition_handles(smcb, js_p,
        s_op->req->u.tree_remove.handle_count,
        s_op->req->u.tree_remove.fs_id, PVFS_SERV_TREE_REMOVE,
        s_op->req->u.tree_remove.handle_array));
}

static int tree_remove_comp_fn(void *v_p, 
                               struct PVFS_server_resp *resp_p,
                               int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op = PINT_sm_frame(smcb, (PINT_MSGPAIR_PARENT_SM));
    struct PVFS_server_resp *op_resp = &(s_op->resp); /*op resp structure*/
    struct PVFS_server_resp *m_resp = resp_p;         /*msgpair resp structure*/
    struct PVFS_servresp_tree_remove *op_tree = &(op_resp->u.tree_remove);
    struct PVFS_servresp_tree_remove *m_tree  = &(m_resp->u.tree_remove);
    struct PINT_server_tree_communicate_op *s_tree_comm = &(s_op->u.tree_communicate);
    int i;
    uint32_t status_array_index=0;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_remove_comp_fn[%d], caller_handle_index = %u\n",
                 index, resp_p->u.tree_remove.caller_handle_index);

    assert(m_resp->op == PVFS_SERV_TREE_REMOVE);

    if (m_resp->status != 0)
    {
        PVFS_perror_gossip("Remove failure", m_resp->status);
        return resp_p->status;
    }

    /* stash the status for each file handle */
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: m_resp->u.tree_remove.handle_count"
                                     " is %d\n"
                                    ,__func__
                                    ,m_resp->u.tree_remove.handle_count);

    for (i = 0; i < m_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: caller_handle_index:%u "
                                         "\tarray_local_count:%d\n"
                                        ,__func__
                                        ,m_tree->caller_handle_index
                                        ,s_tree_comm->handle_array_local_count);
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: status for file %d is %d\n"
                                        ,__func__
                                        ,i
                                        ,m_tree->status[i]);

        status_array_index = s_op->u.tree_communicate.remote_join_size[ i +
                              resp_p->u.tree_remove.caller_handle_index];

        op_tree->status[status_array_index] = m_tree->status[i];
    }

    return 0;
}

static PINT_sm_action tree_remove_work_cleanup(struct PINT_smcb *smcb,
                                    job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_servresp_tree_remove *s_tree = &(s_op->resp.u.tree_remove);
    int i, j, k, task_id, error_code;
    uint32_t status_array_index=0;
    PINT_server_op *old_frame;
    struct PVFS_servreq_tree_remove *tree_req = NULL;
    PINT_sm_msgpair_state *tree_msgarray = NULL;
    PINT_sm_msgarray_op *tree_msgop = NULL;

    assert(s_op->req->op == PVFS_SERV_TREE_REMOVE);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "%s: num_pjmp_frames = %d\n"
                ,__func__
                ,s_op->num_pjmp_frames);


    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (old_frame)
        {
           /* sub-tree msgpair array*/
           tree_msgarray  = old_frame->msgarray_op.msgarray;

           /* sub-tree msgop structure */
           tree_msgop = &(old_frame->msgarray_op);


        }

        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Value of task_id is %d\n"
                                        ,__func__,task_id);
        gossip_debug(GOSSIP_SERVER_DEBUG
                    ,"%s: Value of handle_count is %d\n"
                    ,__func__
                    ,old_frame->resp.u.tree_remove.handle_count);
        gossip_debug(GOSSIP_SERVER_DEBUG
                     ,"%s: Value of error_code is %d\n"
                     ,__func__
                     ,error_code);

        if (task_id == REMOTE_OPERATION)
        {
            if (error_code != 0)
            { /*sub-tree request failed; all handles identified in each msgpair
               *must be retried.  response structure is invalid; use request.
              */
              gossip_debug(GOSSIP_SERVER_DEBUG
                          ,"%s: REMOTE OPERATION encountered error:%d\n"
                          ,__func__
                          ,error_code);
              for (j=0; j < tree_msgop->count; j++)
              {
                 tree_req = &(tree_msgarray[j].req.u.tree_remove);
                 uint32_t index = 0;
                 for (k=0; k < tree_req->handle_count; k++)
                 {
                    index = tree_req->caller_handle_index
                            + k
                            + s_op->u.tree_communicate.handle_array_local_count;
                    s_op->resp.u.tree_remove.status[index] = error_code;
                    gossip_err("%s:index:%d \terror[%d]:%d\n"
                              ,__func__
                              ,index
                              ,index
                              ,s_op->resp.u.tree_remove.status[index]);
                 }/*end for*/
              }/*end for*/
            }/*end if non-zero error-code*/

           PINT_msgpairarray_destroy(&old_frame->msgarray_op);
        }
        else
        { /* LOCAL OPERATION */
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "%s: status of local file is %d\n"
                         ,__func__
                         ,error_code);
            gossip_debug(GOSSIP_SERVER_DEBUG,"%s:handle_index:%d\n"
                                            ,__func__
                                            ,old_frame->local_index);
            status_array_index = s_op->u.tree_communicate.local_join_size[
                                     old_frame->local_index];
            s_op->resp.u.tree_remove.status[status_array_index] = error_code;

            PINT_cleanup_capability(&old_frame->req->capability);
        }
        free(old_frame);
    }/*end for*/

    for (i=0; i<s_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->status[%d]:%d\n"
                                        ,__func__
                                        ,i
                                        ,s_tree->status[i]);
    }

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Resp op:%d \tResp status:%d\n"
                                    ,__func__
                                    ,s_op->resp.op
                                    ,s_op->resp.status);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: s_op->addr:%d\n"
                                    ,__func__
                                    ,(int)s_op->addr);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->caller_handle_index:%u "
                                     "\tresp->handle_count:%d\n"
                                    ,__func__
                                    ,s_tree->caller_handle_index
                                    ,s_tree->handle_count);

    /*deallocate resources*/
    if (s_op->u.tree_communicate.handle_array_local)
       free(s_op->u.tree_communicate.handle_array_local);
    if (s_op->u.tree_communicate.handle_array_remote)
       free(s_op->u.tree_communicate.handle_array_remote);
    if (s_op->u.tree_communicate.local_join_size)
       free(s_op->u.tree_communicate.local_join_size);
    if (s_op->u.tree_communicate.remote_join_size)
       free(s_op->u.tree_communicate.remote_join_size);
    s_op->u.tree_communicate.handle_array_local  = NULL;
    s_op->u.tree_communicate.handle_array_remote = NULL;
    s_op->u.tree_communicate.local_join_size     = NULL;
    s_op->u.tree_communicate.remote_join_size    = NULL;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}/*end tree_remove_work_cleanup*/
 
void tree_remove_free(PINT_server_op *s_op)
{
    struct PVFS_servresp_tree_remove *s_tree = &(s_op->resp.u.tree_remove);

    /*cleanup response structure*/
    if (s_tree->status)
       free(s_tree->status);
}

static PINT_sm_action tree_remove_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    tree_remove_free(s_op);

    return(server_state_machine_complete(smcb));
}
 
static PINT_sm_action tree_get_file_size_setup(struct PINT_smcb *smcb,
                                               job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_server_req *req = s_op->req;

    assert(s_op->req->op == PVFS_SERV_TREE_GET_FILE_SIZE);

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s:req->retry_msgpair_at_leaf:%s\n"
                ,__func__
                ,(req->u.tree_get_file_size.retry_msgpair_at_leaf ? "YES" : "NO"));

    s_op->resp.u.tree_get_file_size.caller_handle_index =
            s_op->req->u.tree_get_file_size.caller_handle_index;
    s_op->resp.u.tree_get_file_size.handle_count =
            s_op->req->u.tree_get_file_size.num_data_files;

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: frame:%p \ttree.caller_handle_index:%u\n"
                                     "\t\ttree.handle_count:%d "
                                     "\ttree.op:%d\n"
                                    ,__func__
                                    ,s_op
                                    ,s_op->resp.u.tree_get_file_size.caller_handle_index
                                    ,s_op->resp.u.tree_get_file_size.handle_count
                                    ,s_op->resp.op);

    /* allocate response arrays */
    s_op->resp.u.tree_get_file_size.error = (PVFS_error *)
        calloc(s_op->req->u.tree_get_file_size.num_data_files, sizeof(PVFS_error));
    s_op->resp.u.tree_get_file_size.size = (PVFS_size *)
        calloc(s_op->req->u.tree_get_file_size.num_data_files, sizeof(PVFS_size));
    if (! s_op->resp.u.tree_get_file_size.error ||
        ! s_op->resp.u.tree_get_file_size.size)
    {
        gossip_err("tree_get_file_size: failed to allocate arrays\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    return (tree_communicate_partition_handles(smcb, js_p,
        s_op->req->u.tree_get_file_size.num_data_files,
        s_op->req->u.tree_get_file_size.fs_id, PVFS_SERV_TREE_GET_FILE_SIZE,
        s_op->req->u.tree_get_file_size.handle_array));
}

static int tree_get_file_size_comp_fn(void *v_p,
                                      struct PVFS_server_resp *resp_p,
                                      int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op = PINT_sm_frame(smcb, (PINT_MSGPAIR_PARENT_SM));
    struct PVFS_server_resp *op_resp = &(s_op->resp); /*op resp structure*/
    struct PVFS_server_resp *m_resp = resp_p;         /*msgpair resp structure*/
    struct PVFS_servresp_tree_get_file_size *op_tree = &(op_resp->u.tree_get_file_size);
    struct PVFS_servresp_tree_get_file_size *m_tree  = &(m_resp->u.tree_get_file_size);
    struct PINT_server_tree_communicate_op *s_tree_comm = &(s_op->u.tree_communicate); 
    int i;
    uint32_t size_array_index=0,
             error_array_index=0;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_get_file_size_comp_fn[%d], caller_handle_index = %u\n",
                 index, resp_p->u.tree_get_file_size.caller_handle_index);

    assert(m_resp->op == PVFS_SERV_TREE_GET_FILE_SIZE);

    if (m_resp->status != 0)
    {
        PVFS_perror_gossip("Get file size failure", m_resp->status);
        return resp_p->status;
    }

    /* stash the sizes and error codes for each file handle */
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: m_resp->u.tree_get_file_size.handle_count"
                                     " is %d\n"
                                    ,__func__
                                    ,m_resp->u.tree_get_file_size.handle_count);

    for (i = 0; i < m_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: size of datafile[%d] is %lld\n"
                                        ,__func__
                                        ,i
                                        ,lld(m_tree->size[i]));
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: caller_handle_index:%u "
                                         "\tarray_local_count:%d\n"
                                        ,__func__
                                        ,m_tree->caller_handle_index
                                        ,s_tree_comm->handle_array_local_count);
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: error code for datafile %d is %d\n"
                                        ,__func__
                                        ,i
                                        ,m_tree->error[i]);

        size_array_index = s_op->u.tree_communicate.remote_join_size[ i +
                              resp_p->u.tree_get_file_size.caller_handle_index];
        error_array_index = size_array_index;

        op_tree->size[size_array_index]   = m_tree->size[i];

        op_tree->error[error_array_index] = m_tree->error[i];
    }

    return 0;
}

static PINT_sm_action tree_get_file_size_work_cleanup(struct PINT_smcb *smcb,
                                           job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_servresp_tree_get_file_size *s_tree = &(s_op->resp.u.tree_get_file_size);
    int i, j, k, task_id, error_code;
    uint32_t size_array_index=0, error_array_index=0;
    PINT_server_op *old_frame;
    struct PVFS_servreq_tree_get_file_size *tree_req = NULL;
    PINT_sm_msgpair_state *tree_msgarray = NULL;
    PINT_sm_msgarray_op *tree_msgop = NULL;
    struct PINT_server_tree_communicate_op *s_tree_comm = &(s_op->u.tree_communicate); 


    assert(s_op->req->op == PVFS_SERV_TREE_GET_FILE_SIZE);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "%s: num_pjmp_frames = %d\n"
                ,__func__
                ,s_op->num_pjmp_frames);

    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (old_frame)
        {  
           /* sub-tree msgpair array*/
           tree_msgarray  = old_frame->msgarray_op.msgarray;

           /* sub-tree msgop structure */
           tree_msgop = &(old_frame->msgarray_op);
        }

        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Value of task_id is %d\n"
                                        ,__func__,task_id);
        gossip_debug(GOSSIP_SERVER_DEBUG
                    ,"%s: Value of handle_count is %d\n"
                    ,__func__
                    ,old_frame->resp.u.tree_get_file_size.handle_count);
        gossip_debug(GOSSIP_SERVER_DEBUG
                     ,"%s: Value of error_code is %d\n"
                     ,__func__
                     ,error_code);

        if (task_id == REMOTE_OPERATION) 
        {
            if (error_code != 0)
            { /*sub-tree request failed; all handles identified in each msgpair 
               *must be retried.  response structure is invalid; use request.
              */
              gossip_debug(GOSSIP_SERVER_DEBUG
                          ,"%s: REMOTE OPERATION encountered error:%d\n"
                          ,__func__
                          ,error_code);
              for (j=0; j < tree_msgop->count; j++)
              {
                 tree_req = &(tree_msgarray[j].req.u.tree_get_file_size);
                 uint32_t index = 0;
                 for (k=0; k < tree_req->num_data_files; k++)
                 {
                    index = tree_req->caller_handle_index 
                            + k
                            + s_op->u.tree_communicate.handle_array_local_count;
                    s_op->resp.u.tree_get_file_size.size[index]  = 0;
                    s_op->resp.u.tree_get_file_size.error[index] = error_code;
                    gossip_err("%s:index:%d \terror[%d]:%d\n"
                              ,__func__
                              ,index
                              ,index
                              ,s_op->resp.u.tree_get_file_size.error[index]);
                 }/*end for*/
              }/*end for*/
            }/*end if non-zero error-code*/

            PINT_msgpairarray_destroy(&old_frame->msgarray_op);
        }
        else { /* LOCAL OPERATION */
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "%s: size of local datafile is %lld\n"
                         ,__func__
                         ,lld(old_frame->resp.u.getattr.attr.u.data.size));
            gossip_debug(GOSSIP_SERVER_DEBUG,"%s:handle_index:%d\n"
                                            ,__func__
                                            ,old_frame->local_index);
            size_array_index = s_op->u.tree_communicate.local_join_size[
                                     old_frame->local_index];
            error_array_index=size_array_index;
            s_op->resp.u.tree_get_file_size.size[size_array_index] =
                old_frame->resp.u.getattr.attr.u.data.size;
            s_op->resp.u.tree_get_file_size.error[error_array_index] =
                error_code;

            PINT_cleanup_capability(&old_frame->req->capability);
        }
        free(old_frame);
    }/*end for*/

    for (i=0; i<s_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->size[%d]:%u "
                                         "\tresp->error[%d]:%d\n"
                                        ,__func__
                                        ,i
                                        ,(unsigned int)s_tree->size[i]
                                        ,i
                                        ,s_tree->error[i]);
    }

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Resp op:%d \tResp status:%d\n"
                                    ,__func__
                                    ,s_op->resp.op
                                    ,s_op->resp.status);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: s_op->addr:%d\n"
                                    ,__func__
                                    ,(int)s_op->addr);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->caller_handle_index:%u "
                                     "\tresp->handle_count:%d\n"
                                    ,__func__
                                    ,s_tree->caller_handle_index
                                    ,s_tree->handle_count);

    /*cleanup tree-communicate structure*/
    if (s_tree_comm->handle_array_local)
       free(s_tree_comm->handle_array_local);
    if (s_tree_comm->handle_array_remote)
       free(s_tree_comm->handle_array_remote);
    if (s_tree_comm->local_join_size)
       free(s_tree_comm->local_join_size);
    if (s_tree_comm->remote_join_size)
       free(s_tree_comm->remote_join_size);
    s_tree_comm->handle_array_local  = NULL;
    s_tree_comm->handle_array_remote = NULL;
    s_tree_comm->local_join_size     = NULL;
    s_tree_comm->remote_join_size    = NULL;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}/*end tree_get_file_size_work_cleanup*/
 
static PINT_sm_action tree_get_file_size_cleanup(struct PINT_smcb *smcb,
                                      job_status_s *js_p)
{
   PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
   struct PVFS_servresp_tree_get_file_size *s_tree = &(s_op->resp.u.tree_get_file_size);
 
   /*cleanup response structure*/
   if (s_tree->size)
      free(s_tree->size);
   if (s_tree->error)
      free(s_tree->error);
    
   return(server_state_machine_complete(smcb));
}

static PINT_sm_action tree_getattr_setup(struct PINT_smcb *smcb,
                                         job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_server_req *req = s_op->req;

    assert(s_op->req->op == PVFS_SERV_TREE_GETATTR);

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s:req->retry_msgpair_at_leaf:%s\n"
                ,__func__
                ,(req->u.tree_getattr.retry_msgpair_at_leaf ? "YES" : "NO"));

    s_op->resp.u.tree_getattr.caller_handle_index =
            s_op->req->u.tree_getattr.caller_handle_index;
    s_op->resp.u.tree_getattr.handle_count =
            s_op->req->u.tree_getattr.handle_count;

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: frame:%p \ttree.caller_handle_index:%u\n"
                                     "\t\ttree.handle_count:%d "
                                     "\ttree.op:%d\n"
                                    ,__func__
                                    ,s_op
                                    ,s_op->resp.u.tree_getattr.caller_handle_index
                                    ,s_op->resp.u.tree_getattr.handle_count
                                    ,s_op->resp.op);

    /* allocate response arrays */
    s_op->resp.u.tree_getattr.error = (PVFS_error *)
        calloc(s_op->req->u.tree_getattr.handle_count, sizeof(PVFS_error));
    s_op->resp.u.tree_getattr.attr = (PVFS_object_attr *)
        calloc(s_op->req->u.tree_getattr.handle_count,
               sizeof(PVFS_object_attr)); 
    if (! s_op->resp.u.tree_getattr.error || 
        ! s_op->resp.u.tree_getattr.attr)
    {
        gossip_err("tree_getattr: failed to allocate arrays\n");
        js_p->error_code = -PVFS_ENOMEM; 
        return SM_ACTION_COMPLETE;
    }   
        
    return (tree_communicate_partition_handles(smcb, js_p,
        s_op->req->u.tree_getattr.handle_count,
        s_op->req->u.tree_getattr.fs_id, PVFS_SERV_TREE_GETATTR,
        s_op->req->u.tree_getattr.handle_array));
}

static int tree_getattr_comp_fn(void *v_p,
                                struct PVFS_server_resp *resp_p,
                                int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op = PINT_sm_frame(smcb, (PINT_MSGPAIR_PARENT_SM));
    struct PVFS_server_resp *op_resp = &(s_op->resp); /*op resp structure*/
    struct PVFS_server_resp *m_resp = resp_p;         /*msgpair resp structure*/
    struct PVFS_servresp_tree_getattr *op_tree = &(op_resp->u.tree_getattr);
    struct PVFS_servresp_tree_getattr *m_tree  = &(m_resp->u.tree_getattr);
    struct PINT_server_tree_communicate_op *s_tree_comm = &(s_op->u.tree_communicate);
    int i;
    uint32_t attr_array_index=0,
             error_array_index=0;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_getattr_comp_fn[%d], caller_handle_index = %u\n",
                 index, resp_p->u.tree_getattr.caller_handle_index);

    assert(m_resp->op == PVFS_SERV_TREE_GETATTR);

    if (m_resp->status != 0)
    {
        PVFS_perror_gossip("Getattr failure", m_resp->status);
        return resp_p->status;
    }

    /* stash the attrs and error codes for each file handle */
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: m_resp->u.tree_getattr.handle_count"
                                     " is %d\n"
                                    ,__func__
                                    ,m_resp->u.tree_getattr.handle_count);

    for (i = 0; i < m_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: caller_handle_index:%u "
                                         "\tarray_local_count:%d\n"
                                        ,__func__
                                        ,m_tree->caller_handle_index
                                        ,s_tree_comm->handle_array_local_count);
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: error code for handle %d is %d\n"
                                        ,__func__
                                        ,i
                                        ,m_tree->error[i]);

        attr_array_index = s_op->u.tree_communicate.remote_join_size[ i +
                              resp_p->u.tree_getattr.caller_handle_index];
        error_array_index = attr_array_index;

        PINT_copy_object_attr(&op_tree->attr[attr_array_index],
                              &m_tree->attr[i]);

        op_tree->error[error_array_index] = m_tree->error[i];
    }

    return 0;
}

static PINT_sm_action tree_getattr_work_cleanup(struct PINT_smcb *smcb,
                                     job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_servresp_tree_getattr *s_tree = &(s_op->resp.u.tree_getattr);
    int i, j, k, task_id, error_code;
    uint32_t attr_array_index=0, error_array_index=0;
    PINT_server_op *old_frame;
    struct PVFS_servreq_tree_getattr *tree_req = NULL;
    PINT_sm_msgpair_state *tree_msgarray = NULL;
    PINT_sm_msgarray_op *tree_msgop = NULL;
    struct PINT_server_tree_communicate_op *s_tree_comm = &(s_op->u.tree_communicate);

    assert(s_op->req->op == PVFS_SERV_TREE_GETATTR);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "%s: num_pjmp_frames = %d\n"
                ,__func__
                ,s_op->num_pjmp_frames);

    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (old_frame)
        {
           /* sub-tree msgpair array*/
           tree_msgarray  = old_frame->msgarray_op.msgarray;

           /* sub-tree msgop structure */
           tree_msgop = &(old_frame->msgarray_op);
        }

        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Value of task_id is %d\n"
                                        ,__func__,task_id);
        gossip_debug(GOSSIP_SERVER_DEBUG
                    ,"%s: Value of handle_count is %d\n"
                    ,__func__
                    ,old_frame->resp.u.tree_getattr.handle_count);
        gossip_debug(GOSSIP_SERVER_DEBUG
                     ,"%s: Value of error_code is %d\n"
                     ,__func__
                     ,error_code);

        if (task_id == REMOTE_OPERATION)
        {
            if (error_code != 0)
            { /*sub-tree request failed; all handles identified in each msgpair
               *must be retried.  response structure is invalid; use request.
              */
              gossip_debug(GOSSIP_SERVER_DEBUG
                          ,"%s: REMOTE OPERATION encountered error:%d\n"
                          ,__func__
                          ,error_code);
              for (j=0; j < tree_msgop->count; j++)
              {
                 tree_req = &(tree_msgarray[j].req.u.tree_getattr);
                 uint32_t index = 0;
                 for (k=0; k < tree_req->handle_count; k++)
                 {
                    index = tree_req->caller_handle_index
                            + k
                            + s_op->u.tree_communicate.handle_array_local_count;
                    PINT_copy_object_attr(&s_op->resp.u.tree_getattr.attr[index],
                           &old_frame->resp.u.getattr.attr);
                    s_op->resp.u.tree_getattr.error[index] = error_code;
                    gossip_err("%s:index:%d \terror[%d]:%d\n"
                              ,__func__
                              ,index
                              ,index
                              ,s_op->resp.u.tree_getattr.error[index]);
                 }/*end for*/
              }/*end for*/
            }/*end if non-zero error-code*/

            PINT_msgpairarray_destroy(&old_frame->msgarray_op);
        }
        else { /* LOCAL OPERATION */
            gossip_debug(GOSSIP_SERVER_DEBUG,"%s:handle_index:%d\n"
                                            ,__func__
                                            ,old_frame->local_index);
            attr_array_index = s_op->u.tree_communicate.local_join_size[
                                     old_frame->local_index];
            error_array_index=attr_array_index;
            PINT_copy_object_attr(&s_op->resp.u.tree_getattr.attr[attr_array_index],
                   &old_frame->resp.u.getattr.attr);
            s_op->resp.u.tree_getattr.error[error_array_index] = error_code;

            PINT_cleanup_capability(&old_frame->req->capability);
        }
        free(old_frame);
    }/*end for*/

    for (i=0; i<s_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->error[%d]:%d\n"
                                        ,__func__
                                        ,i
                                        ,s_tree->error[i]);
    }

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Resp op:%d \tResp status:%d\n"
                                    ,__func__
                                    ,s_op->resp.op
                                    ,s_op->resp.status);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: s_op->addr:%d\n"
                                    ,__func__
                                    ,(int)s_op->addr);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->caller_handle_index:%d "
                                     "\tresp->handle_count:%d\n"
                                    ,__func__
                                    ,s_tree->caller_handle_index
                                    ,s_tree->handle_count);

    /*cleanup tree-communicate structure*/
    if (s_tree_comm->handle_array_local)
       free(s_tree_comm->handle_array_local);
    if (s_tree_comm->handle_array_remote)
       free(s_tree_comm->handle_array_remote);
    if (s_tree_comm->local_join_size)
       free(s_tree_comm->local_join_size);
    if (s_tree_comm->remote_join_size)
       free(s_tree_comm->remote_join_size);
    s_tree_comm->handle_array_local  = NULL;
    s_tree_comm->handle_array_remote = NULL;
    s_tree_comm->local_join_size     = NULL;
    s_tree_comm->remote_join_size    = NULL;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}/*end tree_getattr_work_cleanup*/

void tree_getattr_free(PINT_server_op *s_op)
{
   struct PVFS_servresp_tree_getattr *s_tree = &(s_op->resp.u.tree_getattr);
   int i;

   /*cleanup response structure*/
   if (s_tree->attr)
   {
      for (i = 0; i < s_op->req->u.tree_getattr.handle_count; i++) {
         PINT_free_object_attr(&s_tree->attr[i]);
      }
      free(s_tree->attr);
   }
   if (s_tree->error)
   {
      free(s_tree->error);
   }
}

static PINT_sm_action tree_getattr_cleanup(struct PINT_smcb *smcb,
                                job_status_s *js_p)
{
   PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

   tree_getattr_free(s_op);
   return(server_state_machine_complete(smcb));
}

static inline int PINT_get_object_ref_tree_setattr(struct PVFS_server_req *req,
                                                   PVFS_fs_id *fs_id,
                                                   PVFS_handle *handle)
{   
    *fs_id = req->u.tree_setattr.fs_id;
    *handle = req->u.tree_setattr.handle_array[0];
    return 0;
};

static PINT_sm_action perm_tree_setattr(struct PINT_server_op *s_op)
{
    int ret;

    /* TODO - permission not required */
    ret = 0;

    return ret;
}

PINT_GET_CREDENTIAL_DEFINE(tree_setattr);

struct PINT_server_req_params pvfs2_tree_setattr_params =
{
    .string_name = "tree_setattr",
    .get_object_ref = PINT_get_object_ref_tree_setattr,
    .perm = perm_tree_setattr,
    .access_type = PINT_server_req_modify,
    .get_credential = PINT_get_credential_tree_setattr,
    .state_machine = &pvfs2_tree_setattr_sm
};
    
static inline int PINT_get_object_ref_tree_remove(struct PVFS_server_req *req,
                                                  PVFS_fs_id *fs_id,
                                                  PVFS_handle *handle)
{
    *fs_id = req->u.tree_remove.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

static PINT_sm_action perm_tree_remove(struct PINT_server_op *s_op)
{
    int ret;

    /* this capability is for the parent of the target object */
    if (s_op->req->capability.op_mask & PINT_CAP_REMOVE)
    {
        ret = 0;
    }
    else
    {
        ret = -PVFS_EACCES;
    }

    return ret;
}

PINT_GET_CREDENTIAL_DEFINE(tree_remove);

struct PINT_server_req_params pvfs2_tree_remove_params =
{
    .string_name = "tree_remove",
    .get_object_ref = PINT_get_object_ref_tree_remove,
    .perm = perm_tree_remove,
    .access_type = PINT_server_req_modify,
    .get_credential = PINT_get_credential_tree_remove,
    .state_machine = &pvfs2_tree_remove_sm
};

static inline int PINT_get_object_ref_tree_get_file_size(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id = req->u.tree_get_file_size.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

static PINT_sm_action perm_tree_get_file_size(PINT_server_op *s_op)
{
    int ret;

    /* permission not required */
    ret = 0;

    return ret;
}

struct PINT_server_req_params pvfs2_tree_get_file_size_params =
{
    .string_name = "tree_get_file_size",
    .get_object_ref = PINT_get_object_ref_tree_get_file_size,
    .perm = perm_tree_get_file_size,
    .access_type = PINT_server_req_readonly,
    .state_machine = &pvfs2_tree_get_file_size_sm
};

static inline int PINT_get_object_ref_tree_getattr(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id = req->u.tree_getattr.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

static PINT_sm_action perm_tree_getattr(PINT_server_op *s_op)
{
    int ret;

    /* permission not required */
    ret = 0;

    return ret;
}

struct PINT_server_req_params pvfs2_tree_getattr_params =
{
    .string_name = "tree_getattr",
    .get_object_ref = PINT_get_object_ref_tree_getattr,
    .perm = perm_tree_getattr,
    .access_type = PINT_server_req_readonly,
    .state_machine = &pvfs2_tree_getattr_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=9 sts=4 sw=4 expandtab
 */
