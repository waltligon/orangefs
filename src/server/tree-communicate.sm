/* 
 * (C) 2008 Clemson University and The University of Chicago
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for creating files.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "pvfs2-dist-simple-stripe.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "pint-distribution.h"
#include "PINT-reqproto-encode.h"
#include "pint-util.h"
#include "pint-dist-utils.h"
#include "ncache.h"
#include "pvfs2-internal.h"
#include "extent-utils.h"
#include "security-util.h"
#include "sid.h"

enum
{
    NEXT_STATE_LOCAL  = 2,
    NEXT_STATE_REMOTE = 3,
    PJMP_LOCAL        = 4,
    PJMP_REMOTE       = 5
};

/* completion function prototypes */
static int tree_get_file_size_comp_fn(void *v_p,
                                      struct PVFS_server_resp *resp_p,
                                      int index);
static int tree_get_dirent_count_comp_fn(void *v_p,
                                         struct PVFS_server_resp *resp_p,
                                         int index);
static int tree_remove_comp_fn(void *v_p,
                               struct PVFS_server_resp *resp_p,
                               int index);
static int tree_getattr_comp_fn(void *v_p,
                                struct PVFS_server_resp *resp_p,
                                int index);
static int tree_setattr_comp_fn(void *v_p,
                                struct PVFS_server_resp *resp_p,
                                int index);

%%

machine pvfs2_tree_setattr_sm
{
    state tree_setattr_do_work
    {
        jump pvfs2_tree_setattr_work_sm;
        default => tree_setattr_final_response;
    }

    state tree_setattr_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_setattr_cleanup;
    }

    state tree_setattr_cleanup
    {
        run tree_setattr_cleanup;
        default => terminate;
    }
}

nested machine pvfs2_tree_setattr_work_sm
{
    state tree_setattr_work_do_work
    {
        pjmp tree_setattr_setup
        {
            PJMP_REMOTE => pvfs2_pjmp_call_msgpairarray_sm;
            PJMP_LOCAL => pvfs2_pjmp_set_attr_work_sm;
        }
        default => tree_setattr_work_cleanup;
    }

    state tree_setattr_work_cleanup
    {
        run tree_setattr_work_cleanup;
        default => return;
    }
}

machine pvfs2_tree_remove_sm
{
    state tree_remove_do_work
    {
        jump pvfs2_tree_remove_work_sm;
        default => tree_remove_final_response;
    }

    state tree_remove_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_remove_cleanup;
    }

    state tree_remove_cleanup
    {
        run tree_remove_cleanup;
        default => terminate;
    }
}

nested machine pvfs2_tree_remove_work_sm
{
    state tree_remove_work_do_work
    {
        pjmp tree_remove_setup
        {
            PJMP_REMOTE => pvfs2_pjmp_call_msgpairarray_sm;
            PJMP_LOCAL => pvfs2_pjmp_remove_work_sm;
        }
        default => tree_remove_work_cleanup;
    }

    state tree_remove_work_cleanup
    {
        run tree_remove_work_cleanup;
        default => return;
    }
}

machine pvfs2_tree_get_file_size_sm
{
    state tree_get_file_size_do_work
    {
        jump pvfs2_tree_get_file_size_work_sm;
        default => tree_get_file_size_final_response;
    }

    state tree_get_file_size_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_get_file_size_cleanup;
    }

    state tree_get_file_size_cleanup
    {
        run tree_get_file_size_cleanup;
        default => terminate;
    }
}

nested machine pvfs2_tree_get_file_size_work_sm
{
    state tree_get_file_size_work_do_work
    {
        pjmp tree_get_file_size_setup
        {
            PJMP_REMOTE => pvfs2_pjmp_call_msgpairarray_sm;
            PJMP_LOCAL => pvfs2_pjmp_get_attr_work_sm;
        }
        default => tree_get_file_size_work_cleanup;
    }

    state tree_get_file_size_work_cleanup
    {
        run tree_get_file_size_work_cleanup;
        default => return;
    }
}

machine pvfs2_tree_get_dirent_count_sm
{
    state tree_get_dirent_count_do_work
    {
        jump pvfs2_tree_get_dirent_count_work_sm;
        default => tree_get_dirent_count_final_response;
    }

    state tree_get_dirent_count_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_get_dirent_count_cleanup;
    }

    state tree_get_dirent_count_cleanup
    {
        run tree_get_dirent_count_cleanup;
        default => terminate;
    }
}

nested machine pvfs2_tree_get_dirent_count_work_sm
{
    state tree_get_dirent_count_work_do_work
    {
        pjmp tree_get_dirent_count_setup
        {
            PJMP_REMOTE => pvfs2_pjmp_call_msgpairarray_sm;
            PJMP_LOCAL => pvfs2_pjmp_get_attr_work_sm;
        }
        default => tree_get_dirent_count_work_cleanup;
    }

    state tree_get_dirent_count_work_cleanup
    {
        run tree_get_dirent_count_work_cleanup;
        default => return;
    }
}

machine pvfs2_tree_getattr_sm
{       
    state tree_getattr_do_work
    {
        jump pvfs2_tree_getattr_work_sm;
        default => tree_getattr_final_response;
    }
        
    state tree_getattr_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_getattr_cleanup;
    }
        
    state tree_getattr_cleanup
    {
        run tree_getattr_cleanup;
        default => terminate;
    }
}
    
nested machine pvfs2_tree_getattr_work_sm
{       
    state tree_getattr_work_do_work
    {       
        pjmp tree_getattr_setup
        {
            PJMP_REMOTE => pvfs2_pjmp_call_msgpairarray_sm;
            PJMP_LOCAL => pvfs2_pjmp_get_attr_work_sm;
        }
        default => tree_getattr_work_cleanup;
    }
        
    state tree_getattr_work_cleanup
    {
        run tree_getattr_work_cleanup;
        default => return;
    }
}

%%

/******************** ACTION FUNCTIONS *********************/

static PINT_sm_action tree_communicate_partition_handles(
                                                  struct PINT_smcb *smcb
                                                 ,job_status_s *js_p
                                                 ,int num_data_files
                                                 ,int num_sids
                                                 ,PVFS_fs_id fs_id
                                                 ,enum PVFS_server_op operation
                                                 ,PVFS_handle *handle_array
                                                 ,PVFS_SID *sid_array)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *tree_communicate_s_op =
                        PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_server_req *this_req = s_op->req;
    int num_partitions = 0, num_files_per_server = 0;
    int i,j;
    struct server_configuration_s *config = PINT_server_config_mgr_get_config();
    int ret = -PVFS_EINVAL;
    struct PVFS_server_req *req = NULL;
    PVFS_capability capability;

    s_op->u.tree_communicate.handle_array_local = calloc(
                        num_data_files,
                        sizeof(*s_op->u.tree_communicate.handle_array_local));
    s_op->u.tree_communicate.handle_array_remote = calloc(
                        num_data_files,
                        sizeof(*s_op->u.tree_communicate.handle_array_remote));
    s_op->u.tree_communicate.local_join_size = calloc(
                        num_data_files,
                        sizeof(*s_op->u.tree_communicate.local_join_size));
    s_op->u.tree_communicate.remote_join_size = calloc(
                        num_data_files,
                        sizeof(*s_op->u.tree_communicate.remote_join_size));

    if (!s_op->u.tree_communicate.handle_array_local  ||
        !s_op->u.tree_communicate.handle_array_remote ||
        !s_op->u.tree_communicate.local_join_size     ||
        !s_op->u.tree_communicate.remote_join_size)
    {
        /* in case any of the mallocs succeeded */
        free(s_op->u.tree_communicate.handle_array_local); 
        free(s_op->u.tree_communicate.handle_array_remote);
        free(s_op->u.tree_communicate.local_join_size);
        free(s_op->u.tree_communicate.remote_join_size);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* Separate the handles into local and remote. */
    for (i = 0; i < num_data_files; i++)
    {
        gossip_lsdebug(GOSSIP_SERVER_DEBUG, "New target\n");
        /* Since a datafile will exist on multiple sids, check each sid to
         * see if one matches the local sid.  If so, use the local sid to
         * calculate/retrieve the size of the datafile.
         */
        for (j = 0; j < num_sids; j++)
        {
            gossip_lsdebug(GOSSIP_SERVER_DEBUG, "New SID\n");
            /* j is looping through the number of sids per object,
             * a datafile object in this case, 
             * and i is ordinal number for this datafile within the group of
             * datafiles.  NOTE:  the datafiles are stored ordinally in the
             * handle_array. sid groups are stored ordinally; one group represents
             * the sids for one datafile; the first group contains sids for the
             * first datafile, and so on.
             */
            if (PINT_cached_config_server_local( &sid_array[(i * num_sids) + j] ))
            {
                /* we found a local sid, so put handle on the local list */
                gossip_lsdebug(GOSSIP_SERVER_DEBUG,
                             "local handle = %s\n",
                             PVFS_OID_str(&handle_array[i]));

                s_op->u.tree_communicate.handle_array_local[
                          s_op->u.tree_communicate.handle_array_local_count] =
                                   handle_array[i];


                //What is this used for?
                s_op->u.tree_communicate.local_join_size[
                          s_op->u.tree_communicate.handle_array_local_count] =
                                   i;

                /* we assume only one SID for any OID can be local */
                s_op->u.tree_communicate.handle_array_local_count++;
                break;
            }            
        }/*end for each sid*/

        if ( j == num_sids )
        {
            /* we did NOT find a local sid within the sid group,
             * so all sids must represent remote servers.
             * Add the datafile to the remote list.
             */
            gossip_lsdebug(GOSSIP_SERVER_DEBUG, 
                         "remote handle = %s\n",
                         PVFS_OID_str(&handle_array[i]));

            s_op->u.tree_communicate.handle_array_remote[
                      s_op->u.tree_communicate.handle_array_remote_count] = 
                             handle_array[i];

            //What is this used for?
            s_op->u.tree_communicate.remote_join_size[
                      s_op->u.tree_communicate.handle_array_remote_count] = 
                      i;

            s_op->u.tree_communicate.handle_array_remote_count++;
        }
    }/*end for each datafile*/


    /* For each local handle, setup a state machine frame, 
     * a required precursor to pjmps in the next state.  
     * (pjmps execute multiple requests simultaneously.)
     */
    if (s_op->u.tree_communicate.handle_array_local_count > 0)
    {
        gossip_lsdebug(GOSSIP_SERVER_DEBUG, "Local target\n");
        for (i = 0; i < s_op->u.tree_communicate.handle_array_local_count; i++)
        {
            gossip_lsdebug(GOSSIP_SERVER_DEBUG, "Next Local\n");
            /* Create a stack frame for the local operation. */
            s_op->u.tree_communicate.num_pjmp_frames++;
            js_p->error_code = NEXT_STATE_LOCAL;

            /* this creates a new frame and pushes it for a subsequent PJMP */
            PINT_CREATE_SUBORDINATE_SERVER_FRAME(
                               smcb,
                               tree_communicate_s_op, /* new frame */
                               config->host_sid,
                               fs_id,
                               js_p->error_code,
                               req,                  /* req in new frame */
                               PJMP_LOCAL);

            switch (operation)
            {
            case PVFS_SERV_TREE_SETATTR:
            {
                PVFS_object_attr dummy_obj_attr;
                gossip_lsdebug(GOSSIP_SERVER_DEBUG, "SETATTR\n");
                 
                memset(&dummy_obj_attr, 0, sizeof(PVFS_object_attr));
            
                PINT_SERVREQ_SETATTR_FILL(
                               *req,
                               s_op->req->ctrl.sub,
                               s_op->req->capability,
                               s_op->req->u.tree_setattr.credential,
                               fs_id,
                               s_op->u.tree_communicate.handle_array_local[0],
                               0,    /* V3 sid count */
                               NULL, /* V3 sid array */
                               dummy_obj_attr,
                               s_op->req->hints);

                /* copy to req->u.setattr.attr because of calling
                * pvfs2_set_attr_work_sm next
                */
                /* 
                 * I'm pretty sure if we put this_req->u.tree_setattr.attr
                 * in the macro above it will have the same effect
                 * now that we have sys_attrs out of the way
                 */
                PINT_copy_object_attr(&req->u.setattr.attr,
                                      &this_req->u.tree_setattr.attr);
                /*
                 * These two should go before the macro call ??
                 */
                req->u.setattr.attr.objtype = 
                                      this_req->u.tree_setattr.objtype;
                req->u.setattr.attr.mask |= PVFS_ATTR_COMMON_TYPE;
                tree_communicate_s_op->local_index = i;
 
                break;
            }
            
            case PVFS_SERV_TREE_REMOVE:
            {
                gossip_lsdebug(GOSSIP_SERVER_DEBUG, "REMOVE\n");
                PINT_SERVREQ_REMOVE_FILL(
                        *req,
                        s_op->req->capability,
                        s_op->req->u.tree_remove.credential,
                        fs_id,
                        s_op->u.tree_communicate.handle_array_local[i],
                        s_op->u.tree_communicate.sid_count, /* FIXME */
                        s_op->u.tree_communicate.sid_array, /* FIXME */
                        s_op->req->hints);

                /*this identifies which "local" frame is being populated.*/
                /* we need to store this int in a location not in the union.
                 * it will be accessed as u.getattr in the state machine
                 * so we can't rely on a value in u.tree_communicate here.
                 * All we need is an int, I'm loathe to do a malloc instead of
                 * just re-purposing one of the existing ints in the s_op. */
                tree_communicate_s_op->local_index = i;

                break;
            }

            case PVFS_SERV_TREE_GET_FILE_SIZE:
            {
                gossip_lsdebug(GOSSIP_SERVER_DEBUG, "FILE_SIZE\n");
                PINT_SERVREQ_GETATTR_FILL(
                         *req,
                         PVFS_REQ_DATAFILE,
                         s_op->req->capability,
                         this_req->u.tree_get_file_size.credential,
                         fs_id,
                         s_op->u.tree_communicate.handle_array_local[i],
                         PVFS_ATTR_DATA_ALL,
                         s_op->req->hints);

                /* this identifies which "local" subordinate frame is being populated.
                 * we need to store this int in a location not in the union.
                 * it will be accessed as u.getattr in the state machine
                 * so we can't rely on a value in u.tree_communicate here.
                 */
                tree_communicate_s_op->local_index = i;

                break;
            }
            case PVFS_SERV_TREE_GET_DIRENT_COUNT:
            {
                gossip_lsdebug(GOSSIP_SERVER_DEBUG, "DIRENT_CNT\n");
/* I don't really remember why this was changed WBL */
#if 1
                PINT_SERVREQ_GETATTR_FILL(
                         *req,
                         PVFS_REQ_DIRDATA,
                         s_op->req->capability,
                         this_req->u.tree_get_dirent_count.credential,
                         fs_id,
                         s_op->u.tree_communicate.handle_array_local[i],
                         PVFS_ATTR_DIRDATA_ALL,
                         s_op->req->hints);
#else
                PINT_SERVREQ_TREE_GET_DIRENT_COUNT_FILL(
                       msg_p->req,
                       capability,
                       this_req->u.tree_get_file_size.credential,
                       fs_id,
                       (i * num_files_per_server),
                       num_data_files_for_this_server,
                       &s_op->u.tree_communicate.handle_array_remote[
                                     i * num_files_per_server],
                       s_op->u.tree_communicate.sid_count, /* FIXME */
                       s_op->u.tree_communicate.sid_array, /* FIXME */
                       this_req->u.tree_get_dirent_count.retry_msgpair_at_leaf,
                              s_op->req->hints);
#endif

                tree_communicate_s_op->local_index = i;
 
                break;
            }

            case PVFS_SERV_TREE_GETATTR:
            {
                gossip_lsdebug(GOSSIP_SERVER_DEBUG, "GETATTR\n");
                PINT_SERVREQ_GETATTR_FILL(
                    *req,
                    s_op->req->ctrl.sub,
                    s_op->req->capability,
                    this_req->u.tree_getattr.credential,
                    fs_id,
                    s_op->u.tree_communicate.handle_array_local[i],
                    s_op->req->u.tree_getattr.attrmask,
                    s_op->req->hints);

                /*this identifies which "local" frame is being populated.*/
                /* we need to store this int in a location not in the union.
                 * it will be accessed as u.getattr in the state machine
                 * so we can't rely on a value in u.tree_communicate here.
                 * All we need is an int, I'm loathe to do a malloc instead of
                 * just re-purposing one of the existing ints in the s_op. */
                tree_communicate_s_op->local_index = i;

                break;
            }

            default:
                break;
            } /* end local switch */
        } /* end for each local handle */
    } /* end if local */
    gossip_lsdebug(GOSSIP_SERVER_DEBUG, "Done with local\n");

    /* END OF LOCAL FILES - NOW REMOTE FILES */

    if (s_op->u.tree_communicate.handle_array_remote_count > 0)
    {
        gossip_lsdebug(GOSSIP_SERVER_DEBUG, "Remote target\n");
        /* Decide how to divide the remote handles.
         * If there are only a few (fewer than tree_threshhold
         * from the config file) then go ahead and
         * send to each remaining server individually.
         */
        if (s_op->u.tree_communicate.handle_array_remote_count >
            config->tree_threshold)
        {
            num_partitions = config->tree_width;
            num_files_per_server =
                   s_op->u.tree_communicate.handle_array_remote_count /
                   config->tree_width;
            if (num_partitions * num_files_per_server <
                   s_op->u.tree_communicate.handle_array_remote_count)
            {
                num_files_per_server++;
            }
        }
        else
        {
            num_partitions =
                     s_op->u.tree_communicate.handle_array_remote_count;
            num_files_per_server = 1;
        }

        gossip_lsdebug(GOSSIP_SERVER_DEBUG,
                     "num_data_files = %d, num_remote_handles = %d, "
                     "num_partitions = %d, num_files_per_server = %d\n",
                     num_data_files,
                     s_op->u.tree_communicate.handle_array_remote_count,
                     num_partitions, num_files_per_server);

        /* We need to send tree-based messages to other servers */
        js_p->error_code = NEXT_STATE_REMOTE;
        s_op->u.tree_communicate.num_pjmp_frames++;

        /* Prepare the stack for pjmp. */
        PINT_CREATE_SUBORDINATE_SERVER_FRAME( /* pushes a frame */
                smcb,
                tree_communicate_s_op,
                PVFS_SID_NULL,  /* bc this is a remote operation, we don't 
                                   need a real sid, just a place holder */
                fs_id,
                js_p->error_code, /* out: location */
                req,
                PJMP_REMOTE); /* task_id */

        /* store the number of partitions */
        s_op->u.tree_communicate.num_partitions = num_partitions;

        /*keep info in new frame for later use*/
        tree_communicate_s_op->resp = s_op->resp;
        tree_communicate_s_op->u.tree_communicate = s_op->u.tree_communicate;
       
        ret = PINT_msgpairarray_init(&tree_communicate_s_op->msgarray_op
                                    ,num_partitions);
        if (ret)
        {
            gossip_lerr("tree_communicate: failed to allocate msgarray\n");
            return -PVFS_ENOMEM;
        }

        /* Use a null capability with tree_get_file_size and tree_getattr op */
        if (operation == PVFS_SERV_TREE_GET_FILE_SIZE ||
            operation == PVFS_SERV_TREE_GET_DIRENT_COUNT ||
            operation == PVFS_SERV_TREE_GETATTR)
        {
            PINT_null_capability(&capability);
        }
        
        /* Fill in the msgarray. */
        for (i = 0; i < num_partitions; i++)
        {
            PINT_sm_msgpair_state *msg_p;
            int num_data_files_for_this_server;

            /* Handle the case where the last partition
             * has fewer files than the 
             * other partitions. 
             */
            for (num_data_files_for_this_server = num_files_per_server;
                 i * num_files_per_server + num_data_files_for_this_server >
                         s_op->u.tree_communicate.handle_array_remote_count;
                 num_data_files_for_this_server--)
            {
                /* Do nothing; */
            }

            msg_p = &tree_communicate_s_op->msgarray_op.msgarray[i];

            switch (operation)
            {
            case PVFS_SERV_TREE_SETATTR:
            {
                gossip_lsdebug(GOSSIP_SERVER_DEBUG, "SETATTR\n");
                PINT_SERVREQ_TREE_SETATTR_FILL(
                                msg_p->req,
                                s_op->req->ctrl.sub,
                                s_op->req->capability,
                                this_req->u.tree_setattr.credential,
                                fs_id,
                                this_req->u.tree_setattr.objtype,
                                this_req->u.tree_setattr.attr,
                                0,    /* caller handle index */
                                num_data_files_for_this_server,
                                &s_op->u.tree_communicate.handle_array_remote[
                                                    i * num_files_per_server],
                                0,    /* V3 sid count */
                                NULL, /* V3 sid array */
                                s_op->req->hints);

                msg_p->comp_fn = tree_setattr_comp_fn;
                msg_p->retry_flag = PVFS_MSGPAIR_RETRY; 
            }
            break;

            case PVFS_SERV_TREE_REMOVE:
            {
                gossip_lsdebug(GOSSIP_SERVER_DEBUG, "REMOVE\n");
                PINT_SERVREQ_TREE_REMOVE_FILL(
                        msg_p->req,
                        s_op->req->capability,
                        s_op->req->u.tree_remove.credential,
                        fs_id,
                        (i * num_files_per_server),
                        num_data_files_for_this_server,
                        &s_op->u.tree_communicate.handle_array_remote[
                                        i * num_files_per_server],
                        s_op->u.tree_communicate.sid_count, /* V3 FIXME */
                        s_op->u.tree_communicate.sid_array, /* V3 FIXME */
                        s_op->req->hints);

                msg_p->comp_fn = tree_remove_comp_fn;
                msg_p->retry_flag = PVFS_MSGPAIR_RETRY; 
            }
            break;
    
            case PVFS_SERV_TREE_GET_FILE_SIZE:
            {
                gossip_lsdebug(GOSSIP_SERVER_DEBUG, "FILE_SIZE\n");
                PINT_SERVREQ_TREE_GET_FILE_SIZE_FILL(
                        msg_p->req,
                        capability,
                        this_req->u.tree_get_file_size.credential,
                        fs_id,
                        (i * num_files_per_server),
                        num_data_files_for_this_server,
                        &s_op->u.tree_communicate.handle_array_remote[
                                      i * num_files_per_server],
                        s_op->u.tree_communicate.sid_count, /* FIXME */
                        s_op->u.tree_communicate.sid_array, /* FIXME */
                        this_req->u.tree_get_file_size.retry_msgpair_at_leaf,
                        s_op->req->hints);

                msg_p->comp_fn = tree_get_file_size_comp_fn;

                /* if the logical file is mirrored, then we
                 * want the mirroring logic
                 * to handle retries, when we are processing
                 * the leaf of the tree, 
                 * i.e., this tree request contains msgpairs
                 * having only one handle
                 * each. Otherwise, we let msgpairarray handle retries.
                 */
                if ( (this_req->u.tree_get_file_size.retry_msgpair_at_leaf) && 
                     (num_files_per_server == 1))
                {
                    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"retry_flag:"
                                 "PVFS_MSGPAIR_NO_RETRY\n");
                    msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
                }
                else
                {
                    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"retry_flag:"
                                 "PVFS_MSGPAIR_RETRY\n");
                    msg_p->retry_flag = PVFS_MSGPAIR_RETRY; 
                }
            }
            break;

            case PVFS_SERV_TREE_GET_DIRENT_COUNT:
            {
                gossip_lsdebug(GOSSIP_SERVER_DEBUG, "DIRENT_CNT\n");
                PINT_SERVREQ_TREE_GET_DIRENT_COUNT_FILL(
                        msg_p->req,
                        capability,
                        this_req->u.tree_get_dirent_count.credential,
                        fs_id,
                        (i * num_files_per_server),
                        num_data_files_for_this_server,
                        &s_op->u.tree_communicate.handle_array_remote[
                                      i * num_files_per_server],
                        s_op->u.tree_communicate.sid_count, /* FIXME */
                        s_op->u.tree_communicate.sid_array, /* FIXME */
                        this_req->u.tree_get_dirent_count.retry_msgpair_at_leaf,
                        s_op->req->hints);

                msg_p->comp_fn = tree_get_dirent_count_comp_fn;
                msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;

                /* if the logical file is mirrored, then we
                 * want the mirroring logic
                 * to handle retries, when we are processing
                 * the leaf of the tree,
                 * i.e., this tree request contains msgpairs
                 * having only one handle
                 * each. Otherwise, we let msgpairarray handle retries.
                 */
                if ((this_req->u.tree_get_dirent_count.retry_msgpair_at_leaf)&&
                     (num_files_per_server == 1))
                {
                    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"retry_flag:"
                                 "PVFS_MSGPAIR_NO_RETRY\n");
                    msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
                }
                else
                {
                    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"retry_flag:"
                                 "PVFS_MSGPAIR_RETRY\n");
                    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
                }
            }
            break;

            case PVFS_SERV_TREE_GETATTR:
            {
                gossip_lsdebug(GOSSIP_SERVER_DEBUG, "GETATTR\n");
                PINT_SERVREQ_TREE_GETATTR_FILL(
                        msg_p->req,
                        s_op->req->ctrl.sub,
                        capability,
                        s_op->req->u.tree_getattr.credential,
                        fs_id,
                        (i * num_files_per_server),
                        num_data_files_for_this_server,
                        &s_op->u.tree_communicate.handle_array_remote[
                                                     i * num_files_per_server],
                        /* sid_count this_req->u.tree_getattr.sid_count, */
                        s_op->u.tree_communicate.sid_count, /* FIXME */
                        /* sid_array this_req->u.tree_getattr.sid_array, */
                        s_op->u.tree_communicate.sid_array, /* FIXME */
                        this_req->u.tree_getattr.attrmask,
                        this_req->u.tree_getattr.retry_msgpair_at_leaf,
                        s_op->req->hints);

                msg_p->comp_fn = tree_getattr_comp_fn;

                /* if the logical file is mirrored, then we
                 * want the mirroring logic
                 * to handle retries, when we are processing
                 * the leaf of the tree, 
                 * i.e., this tree request contains msgpairs
                 * having only one handle
                 * each. Otherwise, we let msgpairarray handle retries.
                 */
                if ( (this_req->u.tree_getattr.retry_msgpair_at_leaf) &&
                     (num_files_per_server == 1))
                {
                    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"retry_flag = "
                                                     "PVFS_MSGPAIR_NO_RETRY\n");
                    msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
                }
                else
                {
                    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"retry_flag = "
                                                     "PVFS_MSGPAIR_RETRY\n");
                    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
                }
            } /* end of TREE_GETATTR case */
            break;

            default:
                break;
            } /* end of remote switch */

            msg_p->fs_id = fs_id;
            msg_p->handle = s_op->u.tree_communicate.handle_array_remote[
                                                   i * num_files_per_server];
            msg_p->sid_array = &sid_array[i * num_sids];

            /* V3 need to adjust sid array index */
            gossip_lsdebug(GOSSIP_SERVER_DEBUG,
                         "msg_p->svr_addr (%p) msg_p->sid_array[0] (%p)\n",
                         &msg_p->svr_addr, &msg_p->sid_array[0]);

            ret = PVFS_SID_get_addr(&msg_p->svr_addr, &msg_p->sid_array[0]);
            if (ret)
            {
                gossip_err("Failed to map server address\n");
            }
        } /* end for partitions */

        /* Use a null capability with tree_get_file_size and tree_getattr op */
        if (operation == PVFS_SERV_TREE_GET_FILE_SIZE ||
            operation == PVFS_SERV_TREE_GET_DIRENT_COUNT ||
            operation == PVFS_SERV_TREE_GETATTR)
        {
            PINT_null_capability(&capability);
        }
        gossip_lsdebug(GOSSIP_SERVER_DEBUG, "Done with remote\n");
    }/* end if remote */

    gossip_lsdebug(GOSSIP_SERVER_DEBUG, "Done.\n");
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/*--------------------------------------------------------------------------*/
static PINT_sm_action tree_setattr_setup(struct PINT_smcb *smcb,
                                         job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    assert(s_op->req->op == PVFS_SERV_TREE_SETATTR);

/* V3 have not dealt with tree stuff - old system returns some stuff
 * but it is not clear why thus it has been removed.  Once we are clear
 * on that, remove this
 */
#if 0
    s_op->resp.u.tree_setattr.caller_handle_index =
            s_op->req->u.tree_setattr.caller_handle_index;
    s_op->resp.u.tree_setattr.handle_count =
            s_op->req->u.tree_setattr.handle_count;

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: frame:%p \ttree.caller_handle_index:%u\n"
                                     "\t\ttree.handle_count:%d "
                                     "\ttree.op:%d\n"
                                    ,__func__
                                    ,s_op
                                    ,s_op->resp.u.tree_setattr.caller_handle_index
                                    ,s_op->resp.u.tree_setattr.handle_count
                                    ,s_op->resp.op);

    /* allocate response arrays */
    s_op->resp.u.tree_setattr.status = (int32_t *)
        calloc(s_op->req->u.tree_setattr.handle_count, sizeof(int32_t));
    if (! s_op->resp.u.tree_setattr.status)
    {
        gossip_err("tree_setattr: failed to allocate array\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
#endif

    return (tree_communicate_partition_handles(
                                smcb,
                                js_p,
                                s_op->req->u.tree_setattr.handle_count,
                                s_op->req->u.tree_setattr.sid_count,
                                s_op->req->u.tree_setattr.fs_id,
                                PVFS_SERV_TREE_SETATTR,
                                s_op->req->u.tree_setattr.handle_array,
                                s_op->req->u.tree_setattr.sid_array));
}

static int tree_setattr_comp_fn(void *v_p,
                                struct PVFS_server_resp *resp_p,
                                int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op = PINT_sm_frame(smcb, (PINT_MSGPAIR_PARENT_SM));
    struct PVFS_server_resp *op_resp = &(s_op->resp); /*op resp structure*/
    struct PVFS_server_resp *m_resp = resp_p;         /*msgpair resp structure*/
    struct PVFS_servresp_tree_setattr *op_tree = &(op_resp->u.tree_setattr);
    struct PVFS_servresp_tree_setattr *m_tree  = &(m_resp->u.tree_setattr);
    struct PINT_server_tree_communicate_op *s_tree_comm = &(s_op->u.tree_communicate);
    int i;
    uint32_t status_array_index=0;

    gossip_lsdebug(GOSSIP_SERVER_DEBUG,
                 "tree_setattr_comp_fn[%d], caller_handle_index = %u\n",
                 index, resp_p->u.tree_setattr.caller_handle_index);

    assert(m_resp->op == PVFS_SERV_TREE_SETATTR);

    if (m_resp->status != 0)
    {
        PVFS_perror_gossip("Setattr failure", m_resp->status);
        return resp_p->status;
    }

    /* stash the status for each file handle */
    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"m_resp->u.tree_setattr.handle_count is %d\n"
                                    ,m_resp->u.tree_setattr.handle_count);
    for (i = 0; i < m_tree->handle_count; i++)
    {
        gossip_lsdebug(GOSSIP_SERVER_DEBUG,"caller_handle_index:%u "
                                         "\tarray_local_count:%d\n"
                                        ,m_tree->caller_handle_index
                                        ,s_tree_comm->handle_array_local_count);
        gossip_lsdebug(GOSSIP_SERVER_DEBUG,"status for file %d is %d\n"
                                        ,i ,m_tree->status[i]);
        status_array_index = s_op->u.tree_communicate.remote_join_size[ i +
                              resp_p->u.tree_setattr.caller_handle_index];

        op_tree->status[status_array_index] = m_tree->status[i];
    }

    return 0;
}

static int tree_setattr_work_cleanup(struct PINT_smcb *smcb, 
                                     job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_servresp_tree_setattr *s_tree = &(s_op->resp.u.tree_setattr);
    int i, j, k, task_id, error_code;
    uint32_t status_array_index=0;
    PINT_server_op *old_frame;
    struct PVFS_servreq_tree_setattr *tree_req = NULL;
    PINT_sm_msgpair_state *tree_msgarray = NULL;
    PINT_sm_msgarray_op *tree_msgop = NULL;

    assert(s_op->req->op == PVFS_SERV_TREE_SETATTR);
    gossip_lsdebug(GOSSIP_SERVER_DEBUG, "num_pjmp_frames = %d\n"
                , s_op->num_pjmp_frames);

    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->u.tree_communicate.num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (old_frame)
        {
           /* sub-tree msgpair array*/
           tree_msgarray  = old_frame->msgarray_op.msgarray;

           /* sub-tree msgop structure */
           tree_msgop = &(old_frame->msgarray_op);
        }

        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Value of task_id is %d\n"
                                        ,__func__,task_id);
        gossip_debug(GOSSIP_SERVER_DEBUG
                    , "%s: Value of handle_count is %d\n"
                    , __func__, old_frame->resp.u.tree_setattr.handle_count);
        gossip_debug(GOSSIP_SERVER_DEBUG
                     , "%s: Value of error_code is %d\n"
                     , __func__, error_code);

        if (task_id == PJMP_REMOTE)
        {
            if (error_code != 0)
            {
                /*sub-tree request failed; all handles identified in each
                 * msgpair must be retried.  response structure is invalid;
                 * use request.
                 */
                gossip_debug(GOSSIP_SERVER_DEBUG
                          , "%s: REMOTE OPERATION encountered error:%d\n"
                          , __func__, error_code);
                for (j = 0; j < tree_msgop->count; j++)
                {
                    tree_req = &(tree_msgarray[j].req.u.tree_setattr);
                    uint32_t index = 0;
                    for (k = 0; k < tree_req->handle_count; k++)
                    {
                        index = tree_req->caller_handle_index
                                + k
                                + s_op->u.tree_communicate.handle_array_local_count;
                        s_op->resp.u.tree_setattr.status[index] = error_code;
                        gossip_err("%s:index:%d \terror[%d]:%d\n"
                                  , __func__, index, index
                                  , s_op->resp.u.tree_setattr.status[index]);
                    }/*end for*/
                }/*end for*/
            }/*end if non-zero error-code*/

            /* Free resources used in the request. */
            for (j = 0; j < tree_msgop->count; j++)
            {
                tree_req = &(tree_msgarray[j].req.u.tree_setattr);
                PINT_free_object_attr(&tree_req->attr);
            }/*end for*/
           PINT_msgpairarray_destroy(&old_frame->msgarray_op);

        }
        else
        { /* LOCAL OPERATION */
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "%s: status of local handle is %d\n"
                         , __func__ , error_code);
            gossip_debug(GOSSIP_SERVER_DEBUG,"%s:handle_index:%d\n"
                                            , __func__
                                           , old_frame->local_index);
            status_array_index = s_op->u.tree_communicate.local_join_size[
                                     old_frame->local_index];
            s_op->resp.u.tree_setattr.status[status_array_index] = error_code;

            PINT_free_object_attr(&old_frame->req->u.setattr.attr);
            PINT_cleanup_capability(&old_frame->req->capability);
        }
        free(old_frame);
    }/*end for*/

    for (i=0; i<s_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "%s: resp->status[%d]:%d\n"
                                        , __func__, i, s_tree->status[i]);
    }

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Resp op:%d \tResp status:%d\n"
                                    , __func__, s_op->resp.op
                                    , s_op->resp.status);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: s_op->addr:%d\n"
                                    , __func__, (int)s_op->addr);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->caller_handle_index:%u "
                                     "\tresp->handle_count:%d\n"
                                     , __func__, s_tree->caller_handle_index
                                     , s_tree->handle_count);

    /*deallocate resources*/
    if (s_op->u.tree_communicate.handle_array_local)
    {
        free(s_op->u.tree_communicate.handle_array_local);
    }
    if (s_op->u.tree_communicate.handle_array_remote)
    {
        free(s_op->u.tree_communicate.handle_array_remote);
    }
    if (s_op->u.tree_communicate.local_join_size)
    {
        free(s_op->u.tree_communicate.local_join_size);
    }
    if (s_op->u.tree_communicate.remote_join_size)
    {
        free(s_op->u.tree_communicate.remote_join_size);
    }
    s_op->u.tree_communicate.handle_array_local  = NULL;
    s_op->u.tree_communicate.handle_array_remote = NULL;
    s_op->u.tree_communicate.local_join_size     = NULL;
    s_op->u.tree_communicate.remote_join_size    = NULL;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

void tree_setattr_free(PINT_server_op *s_op)
{
    struct PVFS_servresp_tree_setattr *s_tree = &(s_op->resp.u.tree_setattr);

    /*cleanup response structure*/
    if (s_tree->status)
    {
        free(s_tree->status);
    }
}

static int tree_setattr_cleanup(struct PINT_smcb *smcb, job_status_s *js_p)
{
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    tree_setattr_free(s_op);
    return(server_state_machine_complete(smcb));
}

/*--------------------------------------------------------------------------*/
static PINT_sm_action tree_remove_setup(struct PINT_smcb *smcb,
                                        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    assert(s_op->req->op == PVFS_SERV_TREE_REMOVE);

    s_op->resp.u.tree_remove.caller_handle_index =
            s_op->req->u.tree_remove.caller_handle_index;
    s_op->resp.u.tree_remove.handle_count =
            s_op->req->u.tree_remove.handle_count;

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: frame:%p \ttree.caller_handle_index:%u\n"
                                     "\t\ttree.handle_count:%d "
                                     "\ttree.op:%d\n"
                                    ,__func__
                                    ,s_op
                                    ,s_op->resp.u.tree_remove.caller_handle_index
                                    ,s_op->resp.u.tree_remove.handle_count
                                    ,s_op->resp.op);

    /* allocate response arrays */
    s_op->resp.u.tree_remove.status = (int32_t *)
                calloc(s_op->req->u.tree_remove.handle_count, sizeof(int32_t));
    if (! s_op->resp.u.tree_remove.status)
    {
        gossip_err("tree_remove: failed to allocate array\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    return (tree_communicate_partition_handles(
                                       smcb,
                                       js_p,
                                       s_op->req->u.tree_remove.handle_count,
                                       s_op->req->u.tree_remove.sid_count,
                                       s_op->req->u.tree_remove.fs_id,
                                       PVFS_SERV_TREE_REMOVE,
                                       s_op->req->u.tree_remove.handle_array,
                                       s_op->req->u.tree_remove.sid_array));
}

static int tree_remove_comp_fn(void *v_p, 
                               struct PVFS_server_resp *resp_p,
                               int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op = PINT_sm_frame(smcb, (PINT_MSGPAIR_PARENT_SM));
    struct PVFS_server_resp *op_resp = &(s_op->resp); /*op resp structure*/
    struct PVFS_server_resp *m_resp = resp_p;         /*msgpair resp structure*/
    struct PVFS_servresp_tree_remove *op_tree = &(op_resp->u.tree_remove);
    struct PVFS_servresp_tree_remove *m_tree  = &(m_resp->u.tree_remove);
    struct PINT_server_tree_communicate_op *s_tree_comm = &(s_op->u.tree_communicate);
    int i;
    uint32_t status_array_index=0;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_remove_comp_fn[%d], caller_handle_index = %u\n",
                 index, resp_p->u.tree_remove.caller_handle_index);

    assert(m_resp->op == PVFS_SERV_TREE_REMOVE);

    if (m_resp->status != 0)
    {
        PVFS_perror_gossip("Remove failure", m_resp->status);
        return resp_p->status;
    }

    /* stash the status for each file handle */
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: m_resp->u.tree_remove.handle_count"
                                     " is %d\n"
                                    ,__func__
                                    ,m_resp->u.tree_remove.handle_count);

    for (i = 0; i < m_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: caller_handle_index:%u "
                                         "\tarray_local_count:%d\n"
                                        ,__func__
                                        ,m_tree->caller_handle_index
                                        ,s_tree_comm->handle_array_local_count);
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: status for file %d is %d\n"
                                        ,__func__
                                        ,i
                                        ,m_tree->status[i]);

        status_array_index = s_op->u.tree_communicate.remote_join_size[ i +
                              resp_p->u.tree_remove.caller_handle_index];

        op_tree->status[status_array_index] = m_tree->status[i];
    }

    return 0;
}

static int tree_remove_work_cleanup(struct PINT_smcb *smcb,
                                    job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_servresp_tree_remove *s_tree = &(s_op->resp.u.tree_remove);
    int i, j, k, task_id, error_code;
    uint32_t status_array_index=0;
    PINT_server_op *old_frame;
    struct PVFS_servreq_tree_remove *tree_req = NULL;
    PINT_sm_msgpair_state *tree_msgarray = NULL;
    PINT_sm_msgarray_op *tree_msgop = NULL;

    assert(s_op->req->op == PVFS_SERV_TREE_REMOVE);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "%s: num_pjmp_frames = %d\n"
                ,__func__ ,s_op->u.tree_communicate.num_pjmp_frames);

    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->u.tree_communicate.num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (old_frame)
        {
            /* sub-tree msgpair array*/
            tree_msgarray  = old_frame->msgarray_op.msgarray;

            /* sub-tree msgop structure */
            tree_msgop = &(old_frame->msgarray_op);
        }

        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Value of task_id is %d\n"
                                        ,__func__,task_id);
        gossip_debug(GOSSIP_SERVER_DEBUG
                    ,"%s: Value of handle_count is %d\n"
                    ,__func__
                    ,old_frame->resp.u.tree_remove.handle_count);
        gossip_debug(GOSSIP_SERVER_DEBUG
                     ,"%s: Value of error_code is %d\n"
                     ,__func__
                     ,error_code);

        if (task_id == PJMP_REMOTE)
        {
            if (error_code != 0)
            {   
                /* sub-tree request failed; all handles identified in 
                 * each msgpair must be retried.  response structure
                 * is invalid; use request.
                 */
                gossip_debug(GOSSIP_SERVER_DEBUG
                            ,"%s: REMOTE OPERATION encountered error:%d\n"
                            ,__func__ ,error_code);
                for (j = 0; j < tree_msgop->count; j++)
                {
                    uint32_t index = 0;

                    tree_req = &(tree_msgarray[j].req.u.tree_remove);
                    for (k = 0; k < tree_req->handle_count; k++)
                    {
                        index = tree_req->caller_handle_index
                              + k
                              + s_op->u.tree_communicate.handle_array_local_count;
                        s_op->resp.u.tree_remove.status[index] = error_code;
                        gossip_err("%s:index:%d \terror[%d]:%d\n"
                                  ,__func__ ,index ,index
                                  ,s_op->resp.u.tree_remove.status[index]);
                    }/*end for*/
                }/*end for*/
            }/*end if non-zero error-code*/

            PINT_msgpairarray_destroy(&old_frame->msgarray_op);
        }
        else
        { /* LOCAL OPERATION */
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "%s: status of local file is %d\n"
                         ,__func__
                         ,error_code);
            gossip_debug(GOSSIP_SERVER_DEBUG,"%s:handle_index:%d\n"
                                            ,__func__
                                            ,old_frame->local_index);
            status_array_index = s_op->u.tree_communicate.local_join_size[
                                     old_frame->local_index];
            s_op->resp.u.tree_remove.status[status_array_index] = error_code;

            PINT_cleanup_capability(&old_frame->req->capability);
        }
        free(old_frame);
    }/*end for*/

    for (i = 0; i < s_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->status[%d]:%d\n"
                                        ,__func__
                                        ,i
                                        ,s_tree->status[i]);
    }

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Resp op:%d \tResp status:%d\n"
                                    ,__func__
                                    ,s_op->resp.op
                                    ,s_op->resp.status);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: s_op->addr:%d\n"
                                    ,__func__
                                    ,(int)s_op->addr);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->caller_handle_index:%u "
                                     "\tresp->handle_count:%d\n"
                                    ,__func__
                                    ,s_tree->caller_handle_index
                                    ,s_tree->handle_count);

    /*deallocate resources*/
    if (s_op->u.tree_communicate.handle_array_local)
    {
        free(s_op->u.tree_communicate.handle_array_local);
    }
    if (s_op->u.tree_communicate.handle_array_remote)
    {
        free(s_op->u.tree_communicate.handle_array_remote);
    }
    if (s_op->u.tree_communicate.local_join_size)
    {
        free(s_op->u.tree_communicate.local_join_size);
    }
    if (s_op->u.tree_communicate.remote_join_size)
    {
        free(s_op->u.tree_communicate.remote_join_size);
    }
    s_op->u.tree_communicate.handle_array_local  = NULL;
    s_op->u.tree_communicate.handle_array_remote = NULL;
    s_op->u.tree_communicate.local_join_size     = NULL;
    s_op->u.tree_communicate.remote_join_size    = NULL;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}/*end tree_remove_work_cleanup*/
 
void tree_remove_free(PINT_server_op *s_op)
{
    struct PVFS_servresp_tree_remove *s_tree = &(s_op->resp.u.tree_remove);

    /*cleanup response structure*/
    if (s_tree->status)
       free(s_tree->status);
}

static int tree_remove_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    tree_remove_free(s_op);

    return(server_state_machine_complete(smcb));
}

/*--------------------------------------------------------------------------*/
static PINT_sm_action tree_get_file_size_setup(struct PINT_smcb *smcb,
                                               job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_server_req *req = s_op->req;
    struct PVFS_server_resp *resp = &s_op->resp;
    PINT_sm_msgpair_state *msg_p = NULL;

    /* the request was built in msg_p->req */
    msg_p = &s_op->msgarray_op.msgpair;

    assert(msg_p->req.op == PVFS_SERV_TREE_GET_FILE_SIZE);

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s:req->retry_msgpair_at_leaf:%s\n",
           __func__,
           (req->u.tree_get_file_size.retry_msgpair_at_leaf ? "YES" : "NO"));

    resp->u.tree_get_file_size.caller_handle_index =
            req->u.tree_get_file_size.caller_handle_index;
    resp->u.tree_get_file_size.handle_count =
            req->u.tree_get_file_size.num_data_files;
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "%s: frame:%p \ttree.caller_handle_index:%u\n"
                 "\t\ttree.handle_count:%d \ttree.op:%d\n", __func__,
                 s_op, resp->u.tree_get_file_size.caller_handle_index,
                 resp->u.tree_get_file_size.handle_count, resp->op);

    /* allocate response arrays */
    resp->u.tree_get_file_size.error = (PVFS_error *)
            calloc(req->u.tree_get_file_size.num_data_files,    
                   sizeof(PVFS_error));
    resp->u.tree_get_file_size.size = (PVFS_size *)
            calloc(req->u.tree_get_file_size.num_data_files,
                   sizeof(PVFS_size));
    if (! resp->u.tree_get_file_size.error ||
        ! resp->u.tree_get_file_size.size)
    {
        gossip_err("tree_get_file_size: failed to allocate arrays\n");
        free(resp->u.tree_get_file_size.error);
        free(resp->u.tree_get_file_size.size);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_SERVER_DEBUG, "%s: calling partition_handles\n",
                 __func__);

    return (tree_communicate_partition_handles(
                             smcb,
                             js_p,
                             req->u.tree_get_file_size.num_data_files,
                             req->u.tree_get_file_size.sid_count,
                             req->u.tree_get_file_size.fs_id,
                             PVFS_SERV_TREE_GET_FILE_SIZE,
                             req->u.tree_get_file_size.handle_array,
                             req->u.tree_get_file_size.sid_array));
} /* tree_get_file_size_setup */

static int tree_get_file_size_comp_fn(void *v_p,
                                      struct PVFS_server_resp *resp_p,
                                      int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op = PINT_sm_frame(smcb, (PINT_MSGPAIR_PARENT_SM));
    struct PVFS_server_resp *op_resp = &(s_op->resp); /*op resp structure*/
    struct PVFS_server_resp *m_resp = resp_p;         /*msgpair resp structure*/
    struct PVFS_servresp_tree_get_file_size *op_tree =
                                      &(op_resp->u.tree_get_file_size);
    struct PVFS_servresp_tree_get_file_size *m_tree  =
                                      &(m_resp->u.tree_get_file_size);
    struct PINT_server_tree_communicate_op *s_tree_comm =
                                      &(s_op->u.tree_communicate); 
    int i;
    uint32_t size_array_index=0,
             error_array_index=0;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_get_file_size_comp_fn[%d], caller_handle_index = %u\n",
                 index, resp_p->u.tree_get_file_size.caller_handle_index);

    assert(m_resp->op == PVFS_SERV_TREE_GET_FILE_SIZE);

    if (m_resp->status != 0)
    {
        PVFS_perror_gossip("Get file size failure", m_resp->status);
        return resp_p->status;
    }

    /* stash the sizes and error codes for each file handle */
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "%s: m_resp->u.tree_get_file_size.handle_count"
                                     " is %d\n"
                                    ,__func__
                                    ,m_resp->u.tree_get_file_size.handle_count);

    for (i = 0; i < m_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: size of datafile[%d] is %lld\n"
                                        ,__func__
                                        ,i
                                        ,lld(m_tree->size[i]));
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: caller_handle_index:%u "
                                         "\tarray_local_count:%d\n"
                                        ,__func__
                                        ,m_tree->caller_handle_index
                                        ,s_tree_comm->handle_array_local_count);
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "%s: error code for datafile %d is %d\n"
                                        ,__func__
                                        ,i
                                        ,m_tree->error[i]);

        size_array_index = s_op->u.tree_communicate.remote_join_size[ i +
                              resp_p->u.tree_get_file_size.caller_handle_index];
        error_array_index = size_array_index;

        op_tree->size[size_array_index]   = m_tree->size[i];

        op_tree->error[error_array_index] = m_tree->error[i];
    }

    return 0;
}

static int tree_get_dirent_count_comp_fn(void *v_p,
                                         struct PVFS_server_resp *resp_p,
                                         int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op = PINT_sm_frame(smcb, (PINT_MSGPAIR_PARENT_SM));
    struct PVFS_server_resp *op_resp = &(s_op->resp); /*op resp structure*/
    struct PVFS_server_resp *m_resp = resp_p;         /*msgpair resp structure*/
    struct PVFS_servresp_tree_get_dirent_count *op_tree =
                                      &(op_resp->u.tree_get_dirent_count);
    struct PVFS_servresp_tree_get_dirent_count *m_tree  =
                                      &(m_resp->u.tree_get_dirent_count);
    struct PINT_server_tree_communicate_op *s_tree_comm =
                                      &(s_op->u.tree_communicate);
    int i;
    uint32_t dentcnt_array_index=0,
             error_array_index=0;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_get_dirent_count_comp_fn[%d], "
                 "caller_handle_index = %u\n", index,
                 resp_p->u.tree_get_dirent_count.caller_handle_index);

    assert(m_resp->op == PVFS_SERV_TREE_GET_FILE_SIZE);

    if (m_resp->status != 0)
    {
        PVFS_perror_gossip("get_dirent_count failure", m_resp->status);
        return resp_p->status;
    }

    /* stash the sizes and error codes for each file handle */
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "%s: m_resp->u.tree_get_dirent_count.handle_count"
                 " is %d\n", __func__,
                 m_resp->u.tree_get_dirent_count.handle_count);

    for (i = 0; i < m_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: size of datafile[%d] is %lld\n",
                     __func__, i, lld(m_tree->dentcnt[i]));

        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: caller_handle_index:%u "
                     "\tarray_local_count:%d\n",
                     __func__, m_tree->caller_handle_index,
                     s_tree_comm->handle_array_local_count);

        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "%s: error code for datafile %d is %d\n",
                     __func__, i, m_tree->error[i]);

        dentcnt_array_index = s_op->u.tree_communicate.remote_join_size[ i +
                          resp_p->u.tree_get_dirent_count.caller_handle_index];
        error_array_index = dentcnt_array_index;

        op_tree->dentcnt[dentcnt_array_index]   = m_tree->dentcnt[i];

        op_tree->error[error_array_index] = m_tree->error[i];
    }

    return 0;
} /* tree_get_file_size_completion_function */

static int tree_get_file_size_work_cleanup(struct PINT_smcb *smcb,
                                           job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_servresp_tree_get_file_size *s_tree =
                                  &(s_op->resp.u.tree_get_file_size);
    int i, j, k, task_id, error_code;
    uint32_t size_array_index = 0, error_array_index = 0;
    PINT_server_op *old_frame;
    struct PVFS_servreq_tree_get_file_size *tree_req = NULL;
    PINT_sm_msgpair_state *tree_msgarray = NULL;
    PINT_sm_msgarray_op *tree_msgop = NULL;
    struct PINT_server_tree_communicate_op *s_tree_comm =
                                  &(s_op->u.tree_communicate); 


    assert(s_op->req->op == PVFS_SERV_TREE_GET_FILE_SIZE);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "%s: num_pjmp_frames = %d\n"
                ,__func__
                ,s_op->u.tree_communicate.num_pjmp_frames);

    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->u.tree_communicate.num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (old_frame)
        {  
           /* sub-tree msgpair array*/
           tree_msgarray  = old_frame->msgarray_op.msgarray;

           /* sub-tree msgop structure */
           tree_msgop = &(old_frame->msgarray_op);
        }

        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Value of task_id is %d\n"
                                        ,__func__,task_id);
        gossip_debug(GOSSIP_SERVER_DEBUG
                    ,"%s: Value of handle_count is %d\n"
                    ,__func__
                    ,old_frame->resp.u.tree_get_file_size.handle_count);
        gossip_debug(GOSSIP_SERVER_DEBUG
                     ,"%s: Value of error_code is %d\n"
                     ,__func__
                     ,error_code);

        if (task_id == PJMP_REMOTE) 
        {
            if (error_code != 0)
            {
                /*sub-tree request failed; all handles identified in each msgpair 
                 *must be retried.  response structure is invalid; use request.
                 */
                gossip_debug(GOSSIP_SERVER_DEBUG
                            ,"%s: REMOTE OPERATION encountered error:%d\n"
                            ,__func__
                            ,error_code);
                for (j = 0; j < tree_msgop->count; j++)
                {
                    tree_req = &(tree_msgarray[j].req.u.tree_get_file_size);
                    uint32_t index = 0;
                    for (k=0; k < tree_req->num_data_files; k++)
                    {
                        index = tree_req->caller_handle_index 
                            + k
                            + s_op->u.tree_communicate.handle_array_local_count;
                        s_op->resp.u.tree_get_file_size.size[index]  = 0;
                        s_op->resp.u.tree_get_file_size.error[index] =
                            error_code;
                        gossip_err("%s:index:%d \terror[%d]:%d\n"
                                  ,__func__
                                  ,index
                                  ,index
                                 ,s_op->resp.u.tree_get_file_size.error[index]);
                    }/*end for*/
                }/*end for*/
            }/*end if non-zero error-code*/

            PINT_msgpairarray_destroy(&old_frame->msgarray_op);
        }
        else
        {
            /* LOCAL OPERATION */
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "%s: size of local datafile is %lld\n"
                         ,__func__
                         ,lld(old_frame->resp.u.getattr.attr.u.data.size));
            gossip_debug(GOSSIP_SERVER_DEBUG,"%s:handle_index:%d\n"
                                            ,__func__
                                            ,old_frame->local_index);
            size_array_index = s_op->u.tree_communicate.local_join_size[
                                     old_frame->local_index];
            error_array_index=size_array_index;
            s_op->resp.u.tree_get_file_size.size[size_array_index]   = 
                         old_frame->resp.u.getattr.attr.u.data.size;
            s_op->resp.u.tree_get_file_size.error[error_array_index] =
                         error_code;

            PINT_cleanup_capability(&old_frame->req->capability);
        }
        free(old_frame);
    }/*end for each frame*/

    for (i = 0; i < s_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->size[%d]:%u "
                                         "\tresp->error[%d]:%d\n"
                                        ,__func__
                                        ,i
                                        ,(unsigned int)s_tree->size[i]
                                        ,i
                                        ,s_tree->error[i]);
    }

    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: Resp op:%d \tResp status:%d\n"
                                    ,__func__
                                    ,s_op->resp.op
                                    ,s_op->resp.status);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: s_op->addr:%d\n"
                                    ,__func__
                                    ,(int)s_op->addr);
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: resp->caller_handle_index:%u "
                                     "\tresp->handle_count:%d\n"
                                    ,__func__
                                    ,s_tree->caller_handle_index
                                    ,s_tree->handle_count);

    /*cleanup tree-communicate structure*/
    if (s_tree_comm->handle_array_local)
    {
        free(s_tree_comm->handle_array_local);
    }
    if (s_tree_comm->handle_array_remote)
    {
        free(s_tree_comm->handle_array_remote);
    }
    if (s_tree_comm->local_join_size)
    {
        free(s_tree_comm->local_join_size);
    }
    if (s_tree_comm->remote_join_size)
    {
        free(s_tree_comm->remote_join_size);
    }
    s_tree_comm->handle_array_local  = NULL;
    s_tree_comm->handle_array_remote = NULL;
    s_tree_comm->local_join_size     = NULL;
    s_tree_comm->remote_join_size    = NULL;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}/*end tree_get_file_size_work_cleanup*/
 
static int tree_get_file_size_cleanup(struct PINT_smcb *smcb,
                                      job_status_s *js_p)
{
   PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
   struct PVFS_servresp_tree_get_file_size *s_tree =
                         &(s_op->resp.u.tree_get_file_size);
 
   /*cleanup response structure*/
   if (s_tree->size)
   {
       free(s_tree->size);
   }
   if (s_tree->error)
   {
       free(s_tree->error);
   }
    
   return(server_state_machine_complete(smcb));
}

/*--------------------------------------------------------------------------*/
static int tree_get_dirent_count_setup(struct PINT_smcb *smcb,
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_server_req *req = &s_op->msgarray_op.msgpair.req;
    struct PVFS_server_resp *resp = &s_op->resp;
    /* PINT_sm_msgpair_state *msg_p = &s_op->msgarray_op.msgpair; */

    /* assert(s_op->req->op == PVFS_SERV_TREE_GET_DIRENT_COUNT); */
    assert(req->op == PVFS_SERV_TREE_GET_DIRENT_COUNT);

    gossip_debug(GOSSIP_SERVER_DEBUG, "%s:req->retry_msgpair_at_leaf:%s\n",
          __func__,
          (req->u.tree_get_dirent_count.retry_msgpair_at_leaf ? "YES" : "NO"));

    gossip_debug(GOSSIP_GETATTR_DEBUG, "%s: dirent_count request:\n"
                 "\t\t caller_handle_index: %u\n"
                 "\t\t dirdata_count: %d\n"
                 "\t\t sid_count: %d\n",
                 __func__,
                 req->u.tree_get_dirent_count.caller_handle_index,
                 req->u.tree_get_dirent_count.num_dirdata,
                 req->u.tree_get_dirent_count.sid_count);

    resp->u.tree_get_dirent_count.caller_handle_index =
            req->u.tree_get_dirent_count.caller_handle_index;
    resp->u.tree_get_dirent_count.handle_count =
            req->u.tree_get_dirent_count.num_dirdata;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "%s: Response frame:(%p)\n"
                 "\t\t tree.caller_handle_index:%u\n"
                 "\t\t tree.handle_count:%d\n"
                 "\t\t tree.op:%d\n",
                 __func__,
                 s_op,
                 resp->u.tree_get_dirent_count.caller_handle_index,
                 resp->u.tree_get_dirent_count.handle_count,
                 resp->op);

    /* allocate response arrays */
    resp->u.tree_get_dirent_count.error = (PVFS_error *)
            calloc(req->u.tree_get_dirent_count.num_dirdata,
                   sizeof(PVFS_error));
    resp->u.tree_get_dirent_count.dentcnt = (PVFS_size *)
            calloc(req->u.tree_get_dirent_count.num_dirdata,
                   sizeof(PVFS_size));
    if (! resp->u.tree_get_dirent_count.error ||
        ! resp->u.tree_get_dirent_count.dentcnt)
    {
        gossip_err("%s: failed to allocate arrays\n", __func__);
        free(resp->u.tree_get_dirent_count.error);
        free(resp->u.tree_get_dirent_count.dentcnt);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_SERVER_DEBUG, "%s: calling partition_handles\n",
                 __func__);

    return (tree_communicate_partition_handles(
                             smcb,
                             js_p,
                             req->u.tree_get_dirent_count.num_dirdata,
                             req->u.tree_get_dirent_count.sid_count,
                             req->u.tree_get_dirent_count.fs_id,
                             PVFS_SERV_TREE_GET_DIRENT_COUNT,
                             req->u.tree_get_dirent_count.handle_array,
                             req->u.tree_get_dirent_count.sid_array));
} /* tree_get_dirent_count_setup */

static int tree_get_dirent_count_cleanup(struct PINT_smcb *smcb,
                                         job_status_s *js_p)
{
   PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
   struct PVFS_servresp_tree_get_dirent_count *s_tree =
                         &(s_op->resp.u.tree_get_dirent_count);

   /*cleanup response structure*/
   if (s_tree->dentcnt)
   {
       free(s_tree->dentcnt);
   }
   if (s_tree->error)
   {
       free(s_tree->error);
   }

   return(server_state_machine_complete(smcb));
}

static int tree_get_dirent_count_work_cleanup(struct PINT_smcb *smcb,
                                               job_status_s *js_p)
{
    return SM_ACTION_COMPLETE;
}

/*--------------------------------------------------------------------------*/

static PINT_sm_action tree_getattr_setup(struct PINT_smcb *smcb,
                                         job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_server_req *req = s_op->req;
    int ret = 0;

    assert(s_op->req->op == PVFS_SERV_TREE_GETATTR);

    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"req->retry_msgpair_at_leaf:%s\n"
                ,(req->u.tree_getattr.retry_msgpair_at_leaf ? "YES" : "NO"));

    s_op->resp.u.tree_getattr.caller_handle_index =
            s_op->req->u.tree_getattr.caller_handle_index;
    s_op->resp.u.tree_getattr.handle_count =
            s_op->req->u.tree_getattr.handle_count;

    gossip_lsdebug(GOSSIP_SERVER_DEBUG,
                 "frame:%p tree.caller_handle_index:%u\n"
                 "\t\ttree.handle_count:%d tree.op:%d\n"
                 ,s_op
                 ,s_op->resp.u.tree_getattr.caller_handle_index
                 ,s_op->resp.u.tree_getattr.handle_count
                 ,s_op->resp.op);

    /* allocate response arrays */
    s_op->resp.u.tree_getattr.error = (PVFS_error *)
        calloc(s_op->req->u.tree_getattr.handle_count, sizeof(PVFS_error));

    s_op->resp.u.tree_getattr.attr = (PVFS_object_attr *)
        calloc(s_op->req->u.tree_getattr.handle_count,
               sizeof(PVFS_object_attr));

    if (! s_op->resp.u.tree_getattr.error ||
        ! s_op->resp.u.tree_getattr.attr)
    {
        gossip_err("%s: failed to allocate arrays\n", __func__);
        js_p->error_code = -PVFS_ENOMEM;
        ret = SM_ACTION_COMPLETE;
    }
    else
    {
        ret = (tree_communicate_partition_handles(smcb,
                                                  js_p,
                                                  s_op->req->u.tree_getattr.handle_count,
                                                  s_op->req->u.tree_getattr.sid_count,
                                                  s_op->req->u.tree_getattr.fs_id,
                                                  PVFS_SERV_TREE_GETATTR,
                                                  s_op->req->u.tree_getattr.handle_array,
                                                  s_op->req->u.tree_getattr.sid_array));
    }

    gossip_lsdebug(GOSSIP_SERVER_DEBUG, "Done. returning %d\n", ret);
    return ret;
}

static int tree_getattr_comp_fn(void *v_p,
                                struct PVFS_server_resp *resp_p,
                                int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op = PINT_sm_frame(smcb, (PINT_MSGPAIR_PARENT_SM));
    struct PVFS_server_resp *op_resp = &(s_op->resp); /*op resp structure*/
    struct PVFS_server_resp *m_resp = resp_p;         /*msgpair resp structure*/
    struct PVFS_servresp_tree_getattr *op_tree = &(op_resp->u.tree_getattr);
    struct PVFS_servresp_tree_getattr *m_tree  = &(m_resp->u.tree_getattr);
    struct PINT_server_tree_communicate_op *s_tree_comm = &(s_op->u.tree_communicate);
    int i;
    uint32_t attr_array_index=0,
             error_array_index=0;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_getattr_comp_fn[%d], caller_handle_index = %u\n",
                 index, resp_p->u.tree_getattr.caller_handle_index);

    assert(m_resp->op == PVFS_SERV_TREE_GETATTR);

    if (m_resp->status != 0)
    {
        PVFS_perror_gossip("Getattr failure", m_resp->status);
        return resp_p->status;
    }

    /* stash the attrs and error codes for each file handle */
    gossip_debug(GOSSIP_SERVER_DEBUG,"%s: m_resp->u.tree_getattr.handle_count"
                                     " is %d\n"
                                    ,__func__
                                    ,m_resp->u.tree_getattr.handle_count);

    for (i = 0; i < m_tree->handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: caller_handle_index:%u "
                                         "\tarray_local_count:%d\n"
                                        ,__func__
                                        ,m_tree->caller_handle_index
                                        ,s_tree_comm->handle_array_local_count);
        gossip_debug(GOSSIP_SERVER_DEBUG,"%s: error code for handle %d is %d\n"
                                        ,__func__
                                        ,i
                                        ,m_tree->error[i]);

        attr_array_index = s_op->u.tree_communicate.remote_join_size[ i +
                              resp_p->u.tree_getattr.caller_handle_index];
        error_array_index = attr_array_index;

        PINT_copy_object_attr(&op_tree->attr[attr_array_index],
                              &m_tree->attr[i]);

        op_tree->error[error_array_index] = m_tree->error[i];
    }

    return 0;
}

static int tree_getattr_work_cleanup(struct PINT_smcb *smcb,
                                     job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_servresp_tree_getattr *s_tree = &(s_op->resp.u.tree_getattr);
    int i, j, k, task_id, error_code;
    uint32_t attr_array_index=0, error_array_index=0;
    PINT_server_op *old_frame;
    struct PVFS_servreq_tree_getattr *tree_req = NULL;
    PINT_sm_msgpair_state *tree_msgarray = NULL;
    PINT_sm_msgarray_op *tree_msgop = NULL;
    struct PINT_server_tree_communicate_op *s_tree_comm = &(s_op->u.tree_communicate);

    assert(s_op->req->op == PVFS_SERV_TREE_GETATTR);
    gossip_lsdebug(GOSSIP_SERVER_DEBUG,
                 "num_pjmp_frames = %d\n"
                ,s_op->u.tree_communicate.num_pjmp_frames);

    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->u.tree_communicate.num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (old_frame)
        {
           /* sub-tree msgpair array*/
           tree_msgarray  = old_frame->msgarray_op.msgarray;

           /* sub-tree msgop structure */
           tree_msgop = &(old_frame->msgarray_op);
        }

        gossip_lsdebug(GOSSIP_SERVER_DEBUG,"Value of task_id is %d\n"
                                        ,task_id);
        gossip_lsdebug(GOSSIP_SERVER_DEBUG
                    ,"Value of handle_count is %d\n"
                    ,old_frame->resp.u.tree_getattr.handle_count);
        gossip_lsdebug(GOSSIP_SERVER_DEBUG
                     ,"Value of error_code is %d\n"
                     ,error_code);

        if (task_id == PJMP_REMOTE)
        {
            if (error_code != 0)
            { /*sub-tree request failed; all handles identified in each msgpair
               *must be retried.  response structure is invalid; use request.
              */
              gossip_lsdebug(GOSSIP_SERVER_DEBUG
                          ,"REMOTE OPERATION encountered error:%d\n"
                          ,error_code);
              for (j=0; j < tree_msgop->count; j++)
              {
                 tree_req = &(tree_msgarray[j].req.u.tree_getattr);
                 uint32_t index = 0;
                 for (k=0; k < tree_req->handle_count; k++)
                 {
                    index = tree_req->caller_handle_index
                            + k
                            + s_op->u.tree_communicate.handle_array_local_count;
                    PINT_copy_object_attr(&s_op->resp.u.tree_getattr.attr[index],
                           &old_frame->resp.u.getattr.attr);
                    s_op->resp.u.tree_getattr.error[index] = error_code;
                    gossip_err("%s:index:%d \terror[%d]:%d\n"
                              ,__func__
                              ,index
                              ,index
                              ,s_op->resp.u.tree_getattr.error[index]);
                 }/*end for*/
              }/*end for*/
            }/*end if non-zero error-code*/

            PINT_msgpairarray_destroy(&old_frame->msgarray_op);
        }
        else { /* LOCAL OPERATION */
            gossip_lsdebug(GOSSIP_SERVER_DEBUG,"handle_index:%d\n"
                                            ,old_frame->local_index);
            attr_array_index = s_op->u.tree_communicate.local_join_size[
                                     old_frame->local_index];
            error_array_index=attr_array_index;
            PINT_copy_object_attr(&s_op->resp.u.tree_getattr.attr[attr_array_index],
                   &old_frame->resp.u.getattr.attr);
            s_op->resp.u.tree_getattr.error[error_array_index] = error_code;

            PINT_cleanup_capability(&old_frame->req->capability);
        }
        free(old_frame);
    }/*end for*/

    for (i=0; i<s_tree->handle_count; i++)
    {
        gossip_lsdebug(GOSSIP_SERVER_DEBUG,"resp->error[%d]:%d\n"
                                        ,i
                                        ,s_tree->error[i]);
    }

    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"Resp op:%d \tResp status:%d\n"
                                    ,s_op->resp.op
                                    ,s_op->resp.status);
    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"s_op->addr:%d\n"
                                    ,(int)s_op->addr);
    gossip_lsdebug(GOSSIP_SERVER_DEBUG,"resp->caller_handle_index:%d "
                                     "\tresp->handle_count:%d\n"
                                    ,s_tree->caller_handle_index
                                    ,s_tree->handle_count);

    /*cleanup tree-communicate structure*/
    if (s_tree_comm->handle_array_local)
    {
       free(s_tree_comm->handle_array_local);
    }
    if (s_tree_comm->handle_array_remote)
    {
       free(s_tree_comm->handle_array_remote);
    }
    if (s_tree_comm->local_join_size)
    {
       free(s_tree_comm->local_join_size);
    }
    if (s_tree_comm->remote_join_size)
    {
       free(s_tree_comm->remote_join_size);
    }
    s_tree_comm->handle_array_local  = NULL;
    s_tree_comm->handle_array_remote = NULL;
    s_tree_comm->local_join_size     = NULL;
    s_tree_comm->remote_join_size    = NULL;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}/*end tree_getattr_work_cleanup*/

void tree_getattr_free(PINT_server_op *s_op)
{
   struct PVFS_servresp_tree_getattr *s_tree = &(s_op->resp.u.tree_getattr);
   int i;

   /*cleanup response structure*/
   if (s_tree->attr)
   {
      for (i = 0; i < s_op->req->u.tree_getattr.handle_count; i++) {
         PINT_free_object_attr(&s_tree->attr[i]);
      }
      free(s_tree->attr);
   }
   if (s_tree->error)
   {
      free(s_tree->error);
   }
}

static int tree_getattr_cleanup(struct PINT_smcb *smcb,
                                job_status_s *js_p)
{
   PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

   tree_getattr_free(s_op);
   return(server_state_machine_complete(smcb));
}

/*--------------------------------------------------------------------------*/
static inline int PINT_get_object_ref_tree_setattr(struct PVFS_server_req *req,
                                                   PVFS_fs_id *fs_id,
                                                   PVFS_handle *handle)
{   
    *fs_id = req->u.tree_setattr.fs_id;
    *handle = req->u.tree_setattr.handle_array[0];
    return 0;
};

static int perm_tree_setattr(struct PINT_server_op *s_op)
{
    int ret;

    /* TODO - permission not required */
    ret = 0;

    return ret;
}

PINT_GET_CREDENTIAL_DEFINE(tree_setattr);

struct PINT_server_req_params pvfs2_tree_setattr_params =
{
    .string_name = "tree_setattr",
    .get_object_ref = PINT_get_object_ref_tree_setattr,
    .perm = perm_tree_setattr,
    .access_type = PINT_server_req_modify,
    .get_credential = PINT_get_credential_tree_setattr,
    .state_machine = &pvfs2_tree_setattr_sm
};
    
static inline int PINT_get_object_ref_tree_remove(struct PVFS_server_req *req,
                                                  PVFS_fs_id *fs_id,
                                                  PVFS_handle *handle)
{
    *fs_id = req->u.tree_remove.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
}

static int perm_tree_remove(struct PINT_server_op *s_op)
{
    int ret;

    /* this capability is for the parent of the target object */
    if (s_op->req->capability.op_mask & PINT_CAP_REMOVE)
    {
        ret = 0;
    }
    else
    {
        ret = -PVFS_EACCES;
    }

    return ret;
}

PINT_GET_CREDENTIAL_DEFINE(tree_remove);

struct PINT_server_req_params pvfs2_tree_remove_params =
{
    .string_name = "tree_remove",
    .get_object_ref = PINT_get_object_ref_tree_remove,
    .perm = perm_tree_remove,
    .access_type = PINT_server_req_modify,
    .get_credential = PINT_get_credential_tree_remove,
    .state_machine = &pvfs2_tree_remove_sm
};

/*--------------------------------------------------------------------------*/
static inline int PINT_get_object_ref_tree_get_file_size(
                                             struct PVFS_server_req *req,
                                             PVFS_fs_id *fs_id,
                                             PVFS_handle *handle)
{
    *fs_id = req->u.tree_get_file_size.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
}

static int perm_tree_get_file_size(PINT_server_op *s_op)
{
    int ret;

    /* permission not required */
    ret = 0;

    return ret;
}

struct PINT_server_req_params pvfs2_tree_get_file_size_params =
{
    .string_name = "tree_get_file_size",
    .get_object_ref = PINT_get_object_ref_tree_get_file_size,
    .perm = perm_tree_get_file_size,
    .access_type = PINT_server_req_readonly,
    .state_machine = &pvfs2_tree_get_file_size_sm
};

/*--------------------------------------------------------------------------*/
static inline int PINT_get_object_ref_tree_get_dirent_count(
                                             struct PVFS_server_req *req,
                                             PVFS_fs_id *fs_id,
                                             PVFS_handle *handle)
{
    *fs_id = req->u.tree_get_dirent_count.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
}

static int perm_tree_get_dirent_count(PINT_server_op *s_op)
{
    int ret;

    /* permission not required */
    ret = 0;

    return ret;
}

struct PINT_server_req_params pvfs2_tree_get_dirent_count_params =
{
    .string_name = "tree_get_dirent_count",
    .get_object_ref = PINT_get_object_ref_tree_get_dirent_count,
    .perm = perm_tree_get_dirent_count,
    .access_type = PINT_server_req_readonly,
    .state_machine = &pvfs2_tree_get_dirent_count_sm
};

/*--------------------------------------------------------------------------*/
static inline int PINT_get_object_ref_tree_getattr(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id = req->u.tree_getattr.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

static int perm_tree_getattr(PINT_server_op *s_op)
{
    int ret;

    /* permission not required */
    ret = 0;

    return ret;
}

struct PINT_server_req_params pvfs2_tree_getattr_params =
{
    .string_name = "tree_getattr",
    .get_object_ref = PINT_get_object_ref_tree_getattr,
    .perm = perm_tree_getattr,
    .access_type = PINT_server_req_readonly,
    .state_machine = &pvfs2_tree_getattr_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
